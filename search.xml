<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>区分机械、固态和M2</title>
      <link href="/c74dd02.html"/>
      <url>/c74dd02.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何快速从型号上鉴别电脑硬盘是机械、固态和M2"><a href="#如何快速从型号上鉴别电脑硬盘是机械、固态和M2" class="headerlink" title="如何快速从型号上鉴别电脑硬盘是机械、固态和M2"></a>如何快速从型号上鉴别电脑硬盘是机械、固态和M2</h1><ol><li><p>机械硬盘：<br><img src="/../images/hhd.png" alt="机械硬盘"><br>机械硬盘的型号通常以“HDD”（Hard Disk Drive）结尾，例如“Seagate Barracuda 2TB HDD”。</p></li><li><p>固态硬盘：</p></li></ol><p>固态硬盘的型号通常以“SSD”（Solid State Drive）结尾，例如“Samsung 860 EVO 1TB SSD”。<br><img src="/../images/ssd.png" alt="固态硬盘"></p><ol start="3"><li>M2硬盘：</li></ol><p>M2硬盘的型号通常以“M.2”结尾，例如“WD Blue 1TB M.2 2280 Internal SSD”。<br><img src="/../images/m2.png" alt="M2硬盘"></p><p>通过硬盘型号的后缀，可以快速鉴别电脑硬盘是机械、固态还是M2硬盘。</p>]]></content>
      
      
      <categories>
          
          <category> IT科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电脑硬件 </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑优化的方法</title>
      <link href="/85378675.html"/>
      <url>/85378675.html</url>
      
        <content type="html"><![CDATA[<h1 id="电脑卡的原因和优化方法"><a href="#电脑卡的原因和优化方法" class="headerlink" title="电脑卡的原因和优化方法"></a>电脑卡的原因和优化方法</h1><p>电脑卡的原因可能有很多，比如系统过于老旧、软件冲突、病毒感染等等。以下是一些电脑优化的基本方法：</p><ol><li><p>清理垃圾文件：使用系统自带的磁盘清理工具或第三方清理软件，清理系统中的垃圾文件，释放硬盘空间。</p></li><li><p>卸载不必要的软件：卸载不常用或不必要的软件，减少系统负担。</p></li><li><p>更新系统和驱动程序：更新系统和驱动程序可以修复一些已知的问题和漏洞，提高系统的稳定性和性能。</p></li><li><p>关闭不必要的启动项：在系统启动时，关闭不必要的启动项，减少系统启动时间和资源占用。</p></li><li><p>安装杀毒软件：安装杀毒软件可以保护系统免受病毒和恶意软件的攻击，提高系统的安全性和稳定性。</p></li><li><p>清理注册表：使用注册表清理工具清理系统中的无效注册表项，提高系统的稳定性和性能。</p></li><li><p>增加内存：如果电脑配置较低，可以考虑增加内存，提高系统的运行速度和稳定性。</p></li><li><p>优化硬盘：使用硬盘优化工具对硬盘进行优化，提高硬盘读写速度和稳定性。</p></li><li><p>关闭特效：关闭系统特效可以减少系统资源占用，提高系统的运行速度和稳定性。</p></li><li><p>定期清理系统：定期清理系统中的临时文件、缓存文件等，保持系统的清洁和稳定。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> IT科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 系统优化 </tag>
            
            <tag> Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础环境安装教程</title>
      <link href="/74b57a6d.html"/>
      <url>/74b57a6d.html</url>
      
        <content type="html"><![CDATA[<p>好的，以下是使用Markdown方式写Python环境安装和Pycharm环境安装的教程，并附带图片，图片也使用Markdown方式进行显示。</p><h1 id="Python环境安装和Pycharm环境安装"><a href="#Python环境安装和Pycharm环境安装" class="headerlink" title="Python环境安装和Pycharm环境安装"></a>Python环境安装和Pycharm环境安装</h1><h2 id="Python环境安装"><a href="#Python环境安装" class="headerlink" title="Python环境安装"></a>Python环境安装</h2><ol><li>打开Python官网：<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></li><li>在下载页面中，选择适合你操作系统的Python版本，点击下载。<br><img src="/../images/pythonversion.jpg" alt="Python下载页面"></li><li>下载完成后，双击安装程序，按照提示进行安装。</li><li>在安装过程中，记得勾选“Add Python to PATH”选项，这样可以方便在命令行中使用Python。<br><img src="/../images/pythonpath.jpg" alt="Python安装页面"></li><li>安装完成后，打开命令行，输入<code>python</code>，如果出现以下信息，则说明Python环境已经安装成功。<pre><code>Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32</code></pre></li></ol><h2 id="Pycharm环境安装"><a href="#Pycharm环境安装" class="headerlink" title="Pycharm环境安装"></a>Pycharm环境安装</h2><ol><li>打开Pycharm官网：<a href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a></li><li>在下载页面中，选择适合你操作系统的Pycharm版本，点击下载。<br><img src="/../images/pycharmd.png" alt="Pycharm下载页面"></li><li>下载完成后，双击安装程序，按照提示进行安装。</li><li>在安装过程中，可以选择安装的组件，也可以使用默认设置。<br><img src="/../images/pycharmpath.png" alt="Pycharm安装页面"></li><li>安装完成后，打开Pycharm，选择创建一个新项目，或者打开一个已有的项目。<br><img src="/../images/pythonpro.png" alt="Pycharm主界面"></li></ol><p>至此，Python环境和Pycharm环境已经安装完成。可以开始愉快的Python编程啦！</p>]]></content>
      
      
      <categories>
          
          <category> 编程教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小爱音箱智能家居控制</title>
      <link href="/4a08a452.html"/>
      <url>/4a08a452.html</url>
      
        <content type="html"><![CDATA[<p>小爱音箱是一款智能音箱，可以通过语音控制智能家居设备。以下是小爱音箱智能家居控制的介绍：</p><h2 id="支持的智能家居设备"><a href="#支持的智能家居设备" class="headerlink" title="支持的智能家居设备"></a>支持的智能家居设备</h2><p>小爱音箱支持多种智能家居设备，包括但不限于：</p><ul><li>灯光设备：如智能灯泡、智能灯带等；</li><li>空调设备：如智能空调、智能风扇等；</li><li>家电设备：如智能电视、智能音响等；</li><li>安防设备：如智能门锁、智能摄像头等；</li><li>其他设备：如智能窗帘、智能插座等。<br><img src="/../images/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85.png" alt="image"></li></ul><h2 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h2><p>小爱音箱可以通过语音控制智能家居设备，也可以通过小爱同学App进行控制。以下是具体的控制方式：</p><h3 id="语音控制"><a href="#语音控制" class="headerlink" title="语音控制"></a>语音控制</h3><p>用户可以通过语音控制小爱音箱，例如：</p><ul><li>“小爱同学，打开卧室的灯。”</li><li>“小爱同学，关闭客厅的电视。”</li><li>“小爱同学，调高客厅的温度。”</li></ul><h3 id="小爱同学App控制"><a href="#小爱同学App控制" class="headerlink" title="小爱同学App控制"></a>小爱同学App控制</h3><p>用户可以通过小爱同学App进行智能家居设备的控制，例如：</p><ul><li>在App中添加智能家居设备；</li><li>在App中设置智能家居设备的定时开关；</li><li>在App中查看智能家居设备的使用记录。<br><img src="/../images/xiaomiapp.jpg" alt="image"></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小爱音箱是一款智能音箱，可以通过语音控制智能家居设备。用户可以通过语音控制或者小爱同学App进行控制，支持多种智能家居设备。</p>]]></content>
      
      
      <categories>
          
          <category> IT科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小米 </tag>
            
            <tag> 智能家居 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp内容穿透后台启动</title>
      <link href="/fe1704c8.html"/>
      <url>/fe1704c8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Frp后台自动启动的几个方法"><a href="#Frp后台自动启动的几个方法" class="headerlink" title="Frp后台自动启动的几个方法"></a>Frp后台自动启动的几个方法</h1><p>本文介绍了在Linux和Windows系统中实现Frp后台自动启动的几种方法。</p><h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><h3 id="方法一：使用nohup来启动"><a href="#方法一：使用nohup来启动" class="headerlink" title="方法一：使用nohup来启动"></a>方法一：使用nohup来启动</h3><p>使用nohup命令可以在后台启动Frp，具体步骤如下：</p><ol><li>打开终端，输入以下命令启动frps：</li></ol><pre><code>nohup /path/to/your/fprs -c-c /path/to/your/frps.ini &amp;</code></pre><ol start="2"><li>如果要查看日志，可以使用以下命令：</li></ol><pre><code>cat nohup.out</code></pre><ol start="3"><li>同样的，使用以下命令启动frpc：</li></ol><pre><code>nohup /path/to/your/fprc -c-c /path/to/your/frpc.ini &amp;</code></pre><h3 id="方法二：使用systemctl来控制启动"><a href="#方法二：使用systemctl来控制启动" class="headerlink" title="方法二：使用systemctl来控制启动"></a>方法二：使用systemctl来控制启动</h3><p>使用systemctl命令可以方便地控制Frp的启动和停止，具体步骤如下：</p><ol><li>在<code>/lib/systemd/system/frps.service</code>文件中写入以下内容：</li></ol><pre><code>[Unit]Description=fraps serviceAfter=network.target syslog.targetWants=network.target[Service]Type=simpleExecStart=/your/path/frps -c /your/path/frps.ini[Install]WantedBy=multi-user.target</code></pre><ol start="2"><li>启动frps：</li></ol><pre><code>sudo systemctl start frps</code></pre><ol start="3"><li>打开自启动：</li></ol><pre><code>sudo systemctl enable frps</code></pre><ol start="4"><li>重启应用：</li></ol><pre><code>sudo systemctl restart frps</code></pre><ol start="5"><li>停止应用：</li></ol><pre><code>sudo systemctl stop frps</code></pre><ol start="6"><li>查看应用的日志：</li></ol><pre><code>sudo systemctl status frps</code></pre><h3 id="方法三：使用supervisor来控制"><a href="#方法三：使用supervisor来控制" class="headerlink" title="方法三：使用supervisor来控制"></a>方法三：使用supervisor来控制</h3><p>使用supervisor可以方便地控制Frp的启动和停止，具体步骤如下：</p><ol><li>安装supervisor：</li></ol><pre><code>sudo apt install supervisor</code></pre><ol start="2"><li>在<code>/etc/supervisor/conf.d</code>目录下创建<code>frp.conf</code>文件，写入以下内容：</li></ol><pre><code>[program:frp]command = /your/path/frps -c /your/path/frps.iniautostart = true</code></pre><ol start="3"><li>重新加载supervisor：</li></ol><pre><code>sudo systemctl restart supervisor</code></pre><ol start="4"><li>查看supervisor运行状态：</li></ol><pre><code>sudo supervisorctl status</code></pre><h2 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h2><h3 id="方法一：使用任务计划程序"><a href="#方法一：使用任务计划程序" class="headerlink" title="方法一：使用任务计划程序"></a>方法一：使用任务计划程序</h3><p>使用任务计划程序可以实现Frp开机自启，具体步骤如下：</p><ol><li>打开任务计划程序，点击“创建任务”按钮。</li><li>输入任务名称，选择“使用最高权限运行”选项卡，然后选择“配置为Windows 7、Windows Server 2008 R2”。</li><li>在“触发器”选项卡中，选择“开机时”作为触发器。</li><li>在“操作”选项卡中，输入Frp的启动命令，比如：</li></ol><pre><code>C:\frp\frpc.exe -c C:\frp\frpc.ini</code></pre><ol start="5"><li>点击“确定”按钮，保存任务。</li></ol><h3 id="方法二：使用注册表"><a href="#方法二：使用注册表" class="headerlink" title="方法二：使用注册表"></a>方法二：使用注册表</h3><p>使用注册表可以实现Frp开机自启，具体步骤如下：</p><ol><li>按下Win+R键，打开运行对话框，输入“regedit”打开注册表编辑器。</li><li>找到以下路径：</li></ol><pre><code>HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code></pre><ol start="3"><li>在右侧窗口中，右键点击空白处，选择“新建”-&gt;“字符串值”。</li><li>输入一个名称，比如“Frp”，然后双击该项，输入Frp的启动命令，比如：</li></ol><pre><code>C:\frp\frpc.exe -c C:\frp\frpc.ini</code></pre><ol start="5"><li>关闭注册表编辑器，重启电脑，Frp客户端就会自动启动了。</li></ol><p>以上是在Linux和Windows系统中实现Frp后台自动启动的几种方法。</p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> frp </tag>
            
            <tag> win </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门Ansible</title>
      <link href="/4f3a6d14.html"/>
      <url>/4f3a6d14.html</url>
      
        <content type="html"><![CDATA[<h3 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h3><ul><li>运维自动化发展历程及技术应用</li><li>Ansible命令使用</li><li>Ansible常用模块详解</li><li>YAML语法简介</li><li>Ansible playbook基础</li><li>Playbook变量、tags、handlers使用</li><li>Playbook模板templates</li><li>Playbook条件判断 when</li><li>Playbook字典 with_items</li><li>Ansible Roles</li></ul><h3 id="运维自动化发展历程及技术应用"><a href="#运维自动化发展历程及技术应用" class="headerlink" title="运维自动化发展历程及技术应用"></a>运维自动化发展历程及技术应用</h3><p><img src="/../images/%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="image"></p><h3 id="企业实际应用场景分析"><a href="#企业实际应用场景分析" class="headerlink" title="企业实际应用场景分析"></a>企业实际应用场景分析</h3><pre><code>Dev开发环境    使用者：程序员    功能：程序员开发软件，测试BUG的环境    管理者：程序员测试环境        使用者：QA测试工程师    功能：测试经过Dev环境测试通过的软件的功能    管理者：运维说明：测试环境往往有多套,测试环境满足测试功能即可，不宜过多1、测试人员希望测试环境有多套,公司的产品多产品线并发，即多个版本，意味着多个版本同步测试2、通常测试环境有多少套和产品线数量保持一样发布环境：代码发布机，有些公司为堡垒机（安全屏障）    使用者：运维    功能：发布代码至生产环境    管理者：运维（有经验）    发布机：往往需要有2台（主备）生产环境    使用者：运维，少数情况开放权限给核心开发人员，极少数公司将权限完全    开放给开发人员并其维护    功能：对用户提供公司产品的服务管理者：只能是运维    生产环境服务器数量：一般比较多，且应用非常重要。往往需要自动工具协助部署配置应用灰度环境（生产环境的一部分）    使用者：运维    功能：在全量发布代码前将代码的功能面向少量精准用户发布的环境,可基    于主机或用户执行灰度发布    案例：共100台生产服务器，先发布其中的10台服务器，这10台服务器就是灰度服务器    管理者：运维    灰度环境：往往该版本功能变更较大，为保险起见特意先让一部分用户优化体验该功能，              待这部分用户使用没有重大问题的时候，再全量发布至所有服务器</code></pre><h3 id="程序发布"><a href="#程序发布" class="headerlink" title="程序发布"></a>程序发布</h3><pre><code>程序发布要求：    不能导致系统故障或造成系统完全不可用    不能影响用户体验预发布验证：    新版本的代码先发布到服务器（跟线上环境配置完全相同，只是未接入到调度器）灰度发布：    基于主机，用户，业务发布路径：    /webapp/tuangou    /webapp/tuangou-1.1    /webapp/tuangou-1.2发布过程：在调度器上下线一批主机(标记为maintanance状态) --&gt; 关闭服务 --&gt;          部署新版本的应用程序 --&gt; 启动服务 --&gt; 在调度器上启用这一批服务器自动化灰度发布：脚本、发布平台</code></pre><h3 id="运维自动化发展历程及技术应用-1"><a href="#运维自动化发展历程及技术应用-1" class="headerlink" title="运维自动化发展历程及技术应用"></a>运维自动化发展历程及技术应用</h3><p><img src="/../images/skill.png" alt="image"></p><h3 id="自动化运维应用场景"><a href="#自动化运维应用场景" class="headerlink" title="自动化运维应用场景"></a>自动化运维应用场景</h3><pre><code>文件传输应用部署配置管理任务流编排</code></pre><h3 id="常用自动化运维工具"><a href="#常用自动化运维工具" class="headerlink" title="常用自动化运维工具"></a>常用自动化运维工具</h3><pre><code>Ansible：python，Agentless，中小型应用环境Saltstack：python，一般需部署agent，执行效率更高Puppet：ruby, 功能强大，配置复杂，重型,适合大型环境Fabric：python，agentlessChef：ruby，国内应用少Cfenginefunc</code></pre><h3 id="企业级自动化运维工具应用实战ansible"><a href="#企业级自动化运维工具应用实战ansible" class="headerlink" title="企业级自动化运维工具应用实战ansible"></a>企业级自动化运维工具应用实战ansible</h3><pre><code>公司计划在年底做一次大型市场促销活动，全面冲刺下交易额，为明年的上市做准备。公司要求各业务组对年底大促做准备，运维部要求所有业务容量进行三倍的扩容，并搭建出多套环境可以共开发和测试人员做测试，运维老大为了在年底有所表现，要求运维部门同学尽快实现，当你接到这个任务时，有没有更快的解决方案？</code></pre><h3 id="Ansible发展史"><a href="#Ansible发展史" class="headerlink" title="Ansible发展史"></a>Ansible发展史</h3><pre><code>AnsibleMichael DeHaan（ Cobbler 与 Func 作者）名称来自《安德的游戏》中跨越时空的即时通信工具2012-03-09，发布0.0.1版，2015-10-17，Red Hat宣布收购官网：https://www.ansible.com/官方文档：https://docs.ansible.com/同类自动化工具GitHub关注程度（2016-07-10）</code></pre><p><img src="/../images/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7.png" alt="image"></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><pre><code>1&gt; 模块化：调用特定的模块，完成特定任务2&gt; Paramiko（python对ssh的实现），PyYAML，Jinja2（模板语言）三个关键模块3&gt; 支持自定义模块4&gt; 基于Python语言实现5&gt; 部署简单，基于python和SSH(默认已安装)，agentless6&gt; 安全，基于OpenSSH7&gt; 支持playbook编排任务8&gt; 幂等性：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况9&gt; 无需代理不依赖PKI（无需ssl）10&gt; 可使用任何编程语言写模块11&gt; YAML格式，编排任务，支持丰富的数据结构12&gt; 较强大的多层解决方案</code></pre><h3 id="Ansible架构"><a href="#Ansible架构" class="headerlink" title="Ansible架构"></a>Ansible架构</h3><p><img src="/../images/Ansible%E6%9E%B6%E6%9E%84.png" alt="image"></p><pre><code>ansible的作用以及工作结构1、ansible简介：ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。主要包括：    (1)、连接插件connection plugins：负责和被监控端实现通信；    (2)、host inventory：指定操作的主机，是一个配置文件里面定义监控的主机；    (3)、各种模块核心模块、command模块、自定义模块；    (4)、借助于插件完成记录日志邮件等功能；    (5)、playbook：剧本执行多个任务时，非必需可以让节点一次性运行多个任务。2、ansible的架构：连接其他主机默认使用ssh协议</code></pre><h3 id="Ansible工作原理"><a href="#Ansible工作原理" class="headerlink" title="Ansible工作原理"></a>Ansible工作原理</h3><p><img src="/../images/Ansible%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="image"></p><h3 id="Ansible主要组成部分"><a href="#Ansible主要组成部分" class="headerlink" title="Ansible主要组成部分"></a>Ansible主要组成部分</h3><pre><code>ANSIBLE PLAYBOOKS：任务剧本（任务集），编排定义Ansible任务集的配置文件，                   由Ansible顺序依次执行，通常是JSON格式的YML文件INVENTORY：Ansible管理主机的清单  /etc/anaible/hostsMODULES：  Ansible执行命令的功能模块，多数为内置核心模块，也可自定义PLUGINS：  模块功能的补充，如连接类型插件、循环插件、变量插件、过滤插件等，该功能不常用API：      供第三方程序调用的应用程序编程接口 ANSIBLE：  组合INVENTORY、API、MODULES、PLUGINS的绿框，可以理解为是ansible命令工具，其为核心执行工具</code></pre><pre><code>Ansible命令执行来源：    1&gt; USER，普通用户，即SYSTEM ADMINISTRATOR    2&gt; CMDB（配置管理数据库） API 调用    3&gt; PUBLIC/PRIVATE CLOUD API调用  (公有私有云的API接口调用)    4&gt; USER-&gt; Ansible Playbook -&gt; Ansibile利用ansible实现管理的方式：    1&gt; Ad-Hoc 即ansible单条命令，主要用于临时命令使用场景    2&gt; Ansible-playbook 主要用于长期规划好的，大型项目的场景，需要有前期的规划过程</code></pre><pre><code>Ansible-playbook（剧本）执行过程    将已有编排好的任务集写入Ansible-Playbook    通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行Ansible主要操作对象   HOSTS主机   NETWORKING网络设备注意事项:   执行ansible的主机一般称为主控端，中控，master或堡垒机   主控端Python版本需要2.6或以上   被控端Python版本小于2.4需要安装python-simplejson   被控端如开启SELinux需要安装libselinux-python   windows不能做为主控端   ansible不是服务,不会一直启动,只是需要的时候启动</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>rpm包安装: EPEL源    yum install ansible编译安装:    yum -y install python-jinja2 PyYAML python-paramiko python-babel    python-crypto    tar xf ansible-1.5.4.tar.gz    cd ansible-1.5.4    python setup.py build    python setup.py install    mkdir /etc/ansible    cp -r examples/* /etc/ansibleGit方式:    git clone git://github.com/ansible/ansible.git --recursive    cd ./ansible    source ./hacking/env-setuppip安装： pip是安装Python包的管理器，类似yum    yum install python-pip python-devel    yum install gcc glibc-devel zibl-devel rpm-bulid openssl-devel    pip install --upgrade pip    pip install ansible --upgrade确认安装：    ansible --version</code></pre><h3 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h3><pre><code>配置文件    /etc/ansible/ansible.cfg  主配置文件,配置ansible工作特性(一般无需修改)    /etc/ansible/hosts        主机清单(将被管理的主机放到此文件)    /etc/ansible/roles/       存放角色的目录程序    /usr/bin/ansible          主程序，临时命令执行工具    /usr/bin/ansible-doc      查看配置文档，模块功能查看工具    /usr/bin/ansible-galaxy   下载/上传优秀代码或Roles模块的官网平台    /usr/bin/ansible-playbook 定制自动化任务，编排剧本工具    /usr/bin/ansible-pull     远程执行命令的工具    /usr/bin/ansible-vault    文件加密工具    /usr/bin/ansible-console  基于Console界面与用户交互的执行工具</code></pre><h3 id="主机清单inventory"><a href="#主机清单inventory" class="headerlink" title="主机清单inventory"></a>主机清单inventory</h3><pre><code>Inventory 主机清单1&gt; ansible的主要功用在于批量主机操作，为了便捷地使用其中的部分主机，可以在inventory file中将其分组命名 2&gt; 默认的inventory file为/etc/ansible/hosts3&gt; inventory file可以有多个，且也可以通过Dynamic Inventory来动态生成/etc/ansible/hosts文件格式inventory文件遵循INI文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；此外，当如若目标主机使用了非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来标明    ntp.magedu.com   不分组,直接加        [webservers]     webservers组    www1.magedu.com:2222  可以指定端口    www2.magedu.com        [dbservers]    db1.magedu.com    db2.magedu.com    db3.magedu.com如果主机名称遵循相似的命名模式，还可以使用列表的方式标识各主机示例：    [websrvs]    www[1:100].example.com   ip: 1-100        [dbsrvs]    db-[a:f].example.com     dba-dbff</code></pre><h3 id="ansible-配置文件"><a href="#ansible-配置文件" class="headerlink" title="ansible 配置文件"></a>ansible 配置文件</h3><pre><code>Ansible 配置文件/etc/ansible/ansible.cfg （一般保持默认）vim /etc/ansible/ansible.cfg[defaults]#inventory     = /etc/ansible/hosts      # 主机列表配置文件#library       = /usr/share/my_modules/  # 库文件存放目录#remote_tmp    = $HOME/.ansible/tmp      # 临时py命令文件存放在远程主机目录#local_tmp     = $HOME/.ansible/tmp      # 本机的临时命令执行目录  #forks         = 5                       # 默认并发数,同时可以执行5次#sudo_user     = root                    # 默认sudo 用户#ask_sudo_pass = True                    # 每次执行ansible命令是否询问ssh密码#ask_pass      = True                    # 每次执行ansible命令是否询问ssh口令#remote_port   = 22                      # 远程主机的端口号(默认22)建议优化项： host_key_checking = False               # 检查对应服务器的host_key，建议取消注释log_path=/var/log/ansible.log           # 日志文件,建议取消注释module_name   = command                 # 默认模块</code></pre><h3 id="ansible系列命令"><a href="#ansible系列命令" class="headerlink" title="ansible系列命令"></a>ansible系列命令</h3><pre><code>Ansible系列命令    ansible ansible-doc ansible-playbook ansible-vault ansible-console    ansible-galaxy ansible-pullansible-doc: 显示模块帮助    ansible-doc [options] [module...]        -a            显示所有模块的文档        -l, --list    列出可用模块        -s, --snippet 显示指定模块的playbook片段(简化版,便于查找语法)示例：    ansible-doc -l      列出所有模块    ansible-doc ping    查看指定模块帮助用法    ansible-doc -s ping 查看指定模块帮助用法</code></pre><h3 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h3><pre><code>ansible通过ssh实现配置管理、应用部署、任务执行等功能，建议配置ansible端能基于密钥认证的方式联系各被管理节点ansible &lt;host-pattern&gt; [-m module_name] [-a args]ansible +被管理的主机(ALL) +模块  +参数    --version              显示版本    -m module              指定模块，默认为command    -v                     详细过程 –vv -vvv更详细    --list-hosts           显示主机列表，可简写 --list    -k, --ask-pass         提示输入ssh连接密码,默认Key验证    -C, --check            检查，并不执行    -T, --timeout=TIMEOUT  执行命令的超时时间,默认10s    -u, --user=REMOTE_USER 执行远程执行的用户    -b, --become           代替旧版的sudo切换        --become-user=USERNAME 指定sudo的runas用户,默认为root    -K, --ask-become-pass  提示输入sudo时的口令</code></pre><pre><code>ansible all --list  列出所有主机ping模块: 探测网络中被管理主机是否能够正常使用  走ssh协议          如果对方主机网络正常,返回pongansible-doc -s ping   查看ping模块的语法 检测所有主机的网络状态1&gt;  默认情况下连接被管理的主机是ssh基于key验证,如果没有配置key,权限将会被拒绝    因此需要指定以谁的身份连接,输入用户密码,必须保证被管理主机用户密码一致    ansible all -m ping -k2&gt; 或者实现基于key验证 将公钥ssh-copy-id到被管理的主机上 , 实现免密登录   ansible all -m ping</code></pre><h3 id="ansible的Host-pattern"><a href="#ansible的Host-pattern" class="headerlink" title="ansible的Host-pattern"></a>ansible的Host-pattern</h3><pre><code>ansible的Host-pattern匹配主机的列表    All ：表示所有Inventory中的所有主机        ansible all –m ping    * :通配符        ansible &quot;*&quot; -m ping  (*表示所有主机)        ansible 192.168.1.* -m ping        ansible &quot;*srvs&quot; -m ping    或关系 &quot;:&quot;        ansible &quot;websrvs:appsrvs&quot; -m ping        ansible “192.168.1.10:192.168.1.20” -m ping    逻辑与 &quot;:&amp;&quot;        ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping        在websrvs组并且在dbsrvs组中的主机    逻辑非 &quot;:!&quot;        ansible &#39;websrvs:!dbsrvs&#39; –m ping        在websrvs组，但不在dbsrvs组中的主机        注意：此处为单引号    综合逻辑        ansible &#39;websrvs:dbsrvs:&amp;appsrvs:!ftpsrvs&#39; –m ping    正则表达式        ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping        ansible &quot;~(web|db).*\.magedu\.com&quot; –m ping</code></pre><h3 id="ansible命令执行过程"><a href="#ansible命令执行过程" class="headerlink" title="ansible命令执行过程"></a>ansible命令执行过程</h3><pre><code>ansible命令执行过程    1. 加载自己的配置文件 默认/etc/ansible/ansible.cfg    2. 加载自己对应的模块文件，如command    3. 通过ansible将模块或命令生成对应的临时py文件，       并将该文件传输至远程服务器的对应执行用户$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件    4. 给文件+x执行    5. 执行并返回结果    6. 删除临时py文件，sleep 0退出执行状态：    绿色：执行成功并且不需要做改变的操作    黄色：执行成功并且对目标主机做变更    红色：执行失败</code></pre><h3 id="ansible使用示例"><a href="#ansible使用示例" class="headerlink" title="ansible使用示例"></a>ansible使用示例</h3><pre><code>示例    以wang用户执行ping存活检测        ansible all -m ping -u wang -k    以wang sudo至root执行ping存活检测        ansible all -m ping -u wang -k -b    以wang sudo至mage用户执行ping存活检测        ansible all -m ping -u wang -k -b --become-user=mage    以wang sudo至root用户执行ls        ansible all -m command -u wang -a &#39;ls /root&#39; -b --become-user=root -k -Kansible ping模块测试连接    ansible 192.168.38.126,192.168.38.127 -m ping -k </code></pre><h3 id="ansible常用模块"><a href="#ansible常用模块" class="headerlink" title="ansible常用模块"></a>ansible常用模块</h3><pre><code>模块文档：https://docs.ansible.com/ansible/latest/modules/modules_by_category.htmlCommand：在远程主机执行命令，默认模块，可忽略-m选项    &gt; ansible srvs -m command -a &#39;service vsftpd start&#39;    &gt; ansible srvs -m command -a &#39;echo adong |passwd --stdin 123456&#39;此命令不支持 $VARNAME &lt; &gt; | ; &amp; 等,用shell模块实现    chdir:   进入到被管理主机目录    creates: 如果有一个目录是存在的,步骤将不会运行Command命令    ansible websrvs -a &#39;chdir=/data/ ls&#39;Shell：和command相似，用shell执行命令    &gt; ansible all -m shell  -a &#39;getenforce&#39;  查看SELINUX状态    &gt;  ansible all -m shell  -a &quot;sed -i &#39;s/SELINUX=.*/SELINUX=disabled&#39; /etc/selinux/config&quot;    &gt; ansible srv -m shell -a &#39;echo magedu |passwd –stdin wang&#39;          调用bash执行命令 类似 cat /tmp/stanley.md | awk -F&#39;|&#39; &#39;&#123;print $1,$2&#125;&#39; &amp;&gt; /tmp/example.txt         这些复杂命令，即使使用shell也可能会失败，    解决办法：写到脚本时，copy到远程执行，再把需要的结果拉回执行命令的机器    修改配置文件,使shell作为默认模块            vim /etc/ansible/ansible.cfg        module_name = shellScript：在远程主机上运行ansible服务器上的脚本    &gt; -a &quot;/PATH/TO/SCRIPT_FILE&quot;    &gt; ansible websrvs -m script -a /data/test.shCopy：从主控端复制文件到远程主机      src : 源文件  指定拷贝文件的本地路径  (如果有/ 则拷贝目录内容,比拷贝目录本身)      dest: 指定目标路径      mode: 设置权限      backup: 备份源文件      content: 代替src  指定本机文件内容,生成目标主机文件            &gt; ansible websrvs -m copy -a &quot;src=/root/test1.sh dest=/tmp/test2.showner=wang mode=600 backup=yes&quot;        如果目标存在，默认覆盖，此处指定先备份      &gt; ansible websrvs -m copy -a &quot;content=&#39;test content\nxxx&#39; dest=/tmp/test.txt&quot;        指定内容，直接生成目标文件Fetch：从远程主机提取文件至主控端，copy相反，目前不支持目录,可以先打包,再提取文件     &gt; ansible websrvs -m fetch -a &#39;src=/root/test.sh dest=/data/scripts&#39;     会生成每个被管理主机不同编号的目录,不会发生文件名冲突          &gt; ansible all -m shell -a &#39;tar jxvf test.tar.gz /root/test.sh&#39;     &gt; ansible all -m fetch -a &#39;src=/root/test.tar.gz dest=/data/&#39;File：设置文件属性    path: 要管理的文件路径 (强制添加)    recurse: 递归,文件夹要用递归    src:  创建硬链接,软链接时,指定源目标,配合&#39;state=link&#39; &#39;state=hard&#39; 设置软链接,硬链接    state: 状态          absent 缺席,删除              &gt; ansible websrvs -m file -a &#39;path=/app/test.txt state=touch&#39;       创建文件    &gt; ansible websrvs -m file -a &quot;path=/data/testdir state=directory&quot;   创建目录        &gt; ansible websrvs -m file -a &quot;path=/root/test.sh owner=wang mode=755&quot;  设置权限755    &gt; ansible websrvs -m file -a &#39;src=/data/testfile dest=/data/testfile-link state=link&#39; 创建软链接        unarchive：解包解压缩，有两种用法：    1、将ansible主机上的压缩包传到远程主机后解压缩至特定目录，设置copy=yes.    2、将远程主机上的某个压缩包解压缩到指定路径下，设置copy=no    常见参数：        copy：默认为yes，当copy=yes，拷贝的文件是从ansible主机复制到远程主机上，              如果设置为copy=no，会在远程主机上寻找src源文件        src： 源路径，可以是ansible主机上的路径，也可以是远程主机上的路径，              如果是远程主机上的路径，则需要设置copy=no        dest：远程主机上的目标路径        mode：设置解压缩后的文件权限        示例：        ansible websrvs -m unarchive -a &#39;src=foo.tgz dest=/var/lib/foo&#39;            #默认copy为yes ,将本机目录文件解压到目标主机对应目录下        ansible websrvs -m unarchive -a &#39;src=/tmp/foo.zip dest=/data copy=no mode=0777&#39;          # 解压被管理主机的foo.zip到data目录下, 并设置权限777        ansible websrvs -m unarchive -a &#39;src=https://example.com/example.zip dest=/data copy=no&#39;Archive：打包压缩    &gt; ansible all -m archive -a &#39;path=/etc/sysconfig dest=/data/sysconfig.tar.bz2 format=bz2 owner=wang mode=0777&#39;    将远程主机目录打包         path:   指定路径        dest:   指定目标文件        format: 指定打包格式        owner:  指定所属者        mode:   设置权限Hostname：管理主机名    ansible appsrvs -m hostname -a &quot;name=app.adong.com&quot;  更改一组的主机名    ansible 192.168.38.103 -m hostname -a &quot;name=app2.adong.com&quot; 更改单个主机名Cron：计划任务    支持时间：minute,hour,day,month,weekday    &gt; ansible websrvs -m cron -a &quot;minute=*/5 job=&#39;/usr/sbin/ntpdate 172.16.0.1 &amp;&gt;/dev/null&#39; name=Synctime&quot;     创建任务    &gt; ansible websrvs -m cron -a &#39;state=absent name=Synctime&#39;     删除任务    &gt; ansible websrvs -m cron -a &#39;minute=*/10 job=&#39;/usr/sbin/ntpdate 172.30.0.100&quot; name=synctime disabled=yes&#39;    注释任务,不在生效Yum：管理包    ansible websrvs -m yum -a &#39;list=httpd&#39;  查看程序列表        ansible websrvs -m yum -a &#39;name=httpd state=present&#39; 安装    ansible websrvs -m yum -a &#39;name=httpd state=absent&#39;  删除    可以同时安装多个程序包    Service：管理服务    ansible srv -m service -a &#39;name=httpd state=stopped&#39;  停止服务    ansible srv -m service -a &#39;name=httpd state=started enabled=yes&#39; 启动服务,并设为开机自启    ansible srv -m service -a &#39;name=httpd state=reloaded&#39;  重新加载    ansible srv -m service -a &#39;name=httpd state=restarted&#39; 重启服务User：管理用户    home   指定家目录路径    system 指定系统账号    group  指定组    remove 清除账户    shell  指定shell类型        ansible websrvs -m user -a &#39;name=user1 comment=&quot;test user&quot; uid=2048 home=/app/user1 group=root&#39;    ansible websrvs -m user -a &#39;name=sysuser1 system=yes home=/app/sysuser1&#39;    ansible websrvs -m user -a &#39;name=user1 state=absent remove=yes&#39;  清空用户所有数据    ansible websrvs -m user -a &#39;name=app uid=88 system=yes home=/app groups=root shell=/sbin/nologin password=&quot;$1$zfVojmPy$ZILcvxnXljvTI2PhP2Iqv1&quot;&#39;  创建用户    ansible websrvs -m user -a &#39;name=app state=absent&#39;  不会删除家目录        安装mkpasswd     yum insatll expect     mkpasswd 生成口令    openssl passwd -1  生成加密口令    删除用户及家目录等数据    Group：管理组        ansible srv -m group -a &quot;name=testgroup system=yes&quot;   创建组        ansible srv -m group -a &quot;name=testgroup state=absent&quot; 删除组</code></pre><h3 id="ansible系列命令-1"><a href="#ansible系列命令-1" class="headerlink" title="ansible系列命令"></a>ansible系列命令</h3><pre><code>可以通过网上写好的ansible-galaxy    &gt; 连接 https://galaxy.ansible.com       下载相应的roles(角色)        &gt; 列出所有已安装的galaxy        ansible-galaxy list        &gt; 安装galaxy        ansible-galaxy install geerlingguy.redis        &gt; 删除galaxy        ansible-galaxy remove geerlingguy.redis        ansible-pull    推送命令至远程，效率无限提升，对运维要求较高    ansible-playbook  可以引用按照标准的yml语言写的脚本    执行playbook    示例：ansible-playbook hello.yml        cat hello.yml        #hello world yml file        - hosts: websrvs          remote_user: root          tasks:            - name: hello world              command: /usr/bin/wall hello worldansible-vault  (了解)功能：管理加密解密yml文件    ansible-vault [create|decrypt|edit|encrypt|rekey|view]        ansible-vault encrypt hello.yml 加密        ansible-vault decrypt hello.yml 解密        ansible-vault view hello.yml    查看        ansible-vault edit hello.yml    编辑加密文件        ansible-vault rekey hello.yml   修改口令        ansible-vault create new.yml    创建新文件Ansible-console：2.0+新增，可交互执行命令，支持tab  (了解)    root@test (2)[f:10] $    执行用户@当前操作的主机组 (当前组的主机数量)[f:并发数]$    设置并发数：         forks n   例如： forks 10    切换组：             cd 主机组 例如： cd web    列出当前组主机列表： list    列出所有的内置命令： ?或help    示例：        root@all (2)[f:5]$ list        root@all (2)[f:5]$ cd appsrvs        root@appsrvs (2)[f:5]$ list        root@appsrvs (2)[f:5]$ yum name=httpd state=present        root@appsrvs (2)[f:5]$ service name=httpd state=started</code></pre><h3 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h3><pre><code>&gt; playbook是由一个或多个&quot;play&quot;组成的列表&gt; play的主要功能在于将预定义的一组主机，装扮成事先通过ansible中的task定义好的角色。  Task实际是调用ansible的一个module，将多个play组织在一个playbook中，  即可以让它们联合起来，按事先编排的机制执行预定义的动作&gt; Playbook采用YAML语言编写</code></pre><h3 id="playbook图解"><a href="#playbook图解" class="headerlink" title="playbook图解"></a>playbook图解</h3><p><img src="/../images/playbook%E5%9B%BE%E8%A7%A3.png" alt="image">  </p><pre><code>用户通过ansible命令直接调用yml语言写好的playbook,playbook由多条play组成每条play都有一个任务(task)相对应的操作,然后调用模块modules，应用在主机清单上,通过ssh远程连接从而控制远程主机或者网络设备</code></pre><h3 id="YAML介绍"><a href="#YAML介绍" class="headerlink" title="YAML介绍"></a>YAML介绍</h3><pre><code>YAML是一个可读性高的用来表达资料序列的格式。    YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822等。    Clark Evans在2001年在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者YAML Ain&#39;t Markup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）特性    YAML的可读性好    YAML和脚本语言的交互性好    YAML使用实现语言的数据类型    YAML有一个一致的信息模型    YAML易于实现    YAML可以基于流来处理    YAML表达能力强，扩展性好更多的内容及规范参见：http://www.yaml.org</code></pre><h3 id="YAML语法简介"><a href="#YAML语法简介" class="headerlink" title="YAML语法简介"></a>YAML语法简介</h3><pre><code>&gt; 在单一档案中，可用连续三个连字号(——)区分多个档案。  另外，还有选择性的连续三个点号( ... )用来表示档案结尾&gt; 次行开始正常写Playbook的内容，一般建议写明该Playbook的功能&gt; 使用#号注释代码&gt; 缩进必须是统一的，不能空格和tab混用&gt; 缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结合换行来实现的&gt; YAML文件内容是区别大小写的，k/v的值均需大小写敏感&gt; 多个k/v可同行写也可换行写，同行使用:分隔&gt; v可是个字符串，也可是另一个列表[]&gt; 一个完整的代码块功能需最少元素需包括 name 和 task&gt; 一个name只能包括一个task&gt; YAML文件扩展名通常为yml或yaml</code></pre><h3 id="YAML语法简介-1"><a href="#YAML语法简介-1" class="headerlink" title="YAML语法简介"></a>YAML语法简介</h3><pre><code>List：列表，其所有元素均使用“-”打头      列表代表同一类型的元素示例：# A list of tasty fruits- Apple- Orange- Strawberry- MangoDictionary：字典，通常由多个key与value构成 键值对示例：---# An employee recordname: Example Developerjob: Developerskill: Elite也可以将key:value放置于&#123;&#125;中进行表示，用,分隔多个key:value示例：---# An employee record&#123;name: Example Developer, job: Developer, skill: Elite&#125;  有空格</code></pre><h3 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h3><pre><code>YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用&quot;-&quot;来代表，Map里的键值对用&quot;:&quot;分隔示例    name: John Smith    age: 41    gender: Male    spouse:      name: Jane Smith      age: 37      gender: Female    children:      - name: Jimmy Smith        age: 17        gender: Male      - name: Jenny Smith        age 13        gender: Female</code></pre><h3 id="三种常见的数据交换格式"><a href="#三种常见的数据交换格式" class="headerlink" title="三种常见的数据交换格式"></a>三种常见的数据交换格式</h3><p><img src="/../images/threedata.png" alt="image"></p><h3 id="Playbook核心元素"><a href="#Playbook核心元素" class="headerlink" title="Playbook核心元素"></a>Playbook核心元素</h3><pre><code>Hosts          执行的远程主机列表(应用在哪些主机上)Tasks          任务集Variables      内置变量或自定义变量在playbook中调用Templates模板  可替换模板文件中的变量并实现一些简单逻辑的文件Handlers和notify结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行tags标签       指定某条任务执行，用于选择运行playbook中的部分代码。                ansible具有幂等性，因此会自动跳过没有变化的部分，                即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。                此时，如果确信其没有变化，就可以通过tags跳过此些代码片断                ansible-playbook -t tagsname useradd.yml</code></pre><h3 id="playbook基础组件"><a href="#playbook基础组件" class="headerlink" title="playbook基础组件"></a>playbook基础组件</h3><pre><code>Hosts：    &gt; playbook中的每一个play的目的都是为了让特定主机以某个指定的用户身份执行任务。      hosts用于指定要执行指定任务的主机，须事先定义在主机清单中    &gt; 可以是如下形式：        one.example.com        one.example.com:two.example.com        192.168.1.50        192.168.1.*    &gt; Websrvs:dbsrvs       或者，两个组的并集    &gt; Websrvs:&amp;dbsrvs      与，两个组的交集    &gt; webservers:!phoenix  在websrvs组，但不在dbsrvs组    示例: - hosts: websrvs：dbsrvsremote_user:     可用于Host和task中。    也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；    此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户    - hosts: websrvs        remote_user: root   (可省略,默认为root)  以root身份连接      tasks:    指定任务    - name: test connection        ping:        remote_user: magedu        sudo: yes           默认sudo为root        sudo_user:wang      sudo为wang    task列表和action    任务列表task:由多个动作,多个任务组合起来的,每个任务都调用的模块,一个模块一个模块执行    1&gt; play的主体部分是task list，task list中的各任务按次序逐个在hosts中指定的所有主机上执行，       即在所有主机上完成第一个任务后，再开始第二个任务    2&gt; task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。       模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致    3&gt; 每个task都应该有其name，用于playbook的执行结果输出，建议其内容能清晰地描述任务执行步骤。       如果未提供name，则action的结果将用于输出</code></pre><pre><code>tasks：任务列表两种格式：    (1) action: module arguments    (2) module: arguments 建议使用  模块: 参数    注意：shell和command模块后面跟命令，而非key=value某任务的状态在运行后为changed时，可通过&quot;notify&quot;通知给相应的handlers任务可以通过&quot;tags&quot;打标签，可在ansible-playbook命令上使用-t指定进行调用示例：tasks:  - name: disable selinux   描述    command: /sbin/setenforce 0   模块名: 模块对应的参数</code></pre><pre><code>如果命令或脚本的退出码不为零，可以使用如下方式替代tasks:  - name: run this command and ignore the result    shell: /usr/bin/somecommand || /bin/true      转错为正  如果命令失败则执行 true或者使用ignore_errors来忽略错误信息tasks:  - name: run this command and ignore the result    shell: /usr/bin/somecommand    ignore_errors: True  忽略错误</code></pre><h3 id="运行playbook"><a href="#运行playbook" class="headerlink" title="运行playbook"></a>运行playbook</h3><pre><code>运行playbook的方式    ansible-playbook &lt;filename.yml&gt; ... [options]常见选项    --check -C       只检测可能会发生的改变，但不真正执行操作                      (只检查语法,如果执行过程中出现问题,-C无法检测出来)                     (执行playbook生成的文件不存在,后面的程序如果依赖这些文件,也会导致检测失败)    --list-hosts     列出运行任务的主机    --list-tags      列出tag  (列出标签)    --list-tasks     列出task (列出任务)    --limit 主机列表 只针对主机列表中的主机执行    -v -vv -vvv      显示过程示例    ansible-playbook hello.yml --check 只检测    ansible-playbook hello.yml --list-hosts  显示运行任务的主机    ansible-playbook hello.yml --limit websrvs  限制主机</code></pre><h3 id="Playbook-VS-ShellScripts"><a href="#Playbook-VS-ShellScripts" class="headerlink" title="Playbook VS ShellScripts"></a>Playbook VS ShellScripts</h3><p>安装httpd</p><pre><code>SHELL脚本#!/bin/bash# 安装Apacheyum install --quiet -y httpd# 复制配置文件cp /tmp/httpd.conf /etc/httpd/conf/httpd.confcp/tmp/vhosts.conf /etc/httpd/conf.d/# 启动Apache，并设置开机启动service httpd startchkconfig httpd on</code></pre><pre><code>Playbook定义---- hosts: all  remote_user: root    tasks:    - name: &quot;安装Apache&quot;      yum: name=httpd       yum模块:安装httpd    - name: &quot;复制配置文件&quot;      copy: src=/tmp/httpd.conf dest=/etc/httpd/conf/  copy模块: 拷贝文件    - name: &quot;复制配置文件&quot;      copy: src=/tmp/vhosts.conf dest=/etc/httpd/conf.d/      - name: &quot;启动Apache，并设置开机启动&quot;      service: name=httpd state=started enabled=yes   service模块: 启动服务 </code></pre><h3 id="示例-Playbook-创建用户"><a href="#示例-Playbook-创建用户" class="headerlink" title="示例:Playbook 创建用户"></a>示例:Playbook 创建用户</h3><pre><code>示例：sysuser.yml---- hosts: all  remote_user: root  tasks:    - name: create mysql user      user: name=mysql system=yes uid=36    - name: create a group      group: name=httpd system=yes</code></pre><h3 id="Playbook示例-安装httpd服务"><a href="#Playbook示例-安装httpd服务" class="headerlink" title="Playbook示例  安装httpd服务"></a>Playbook示例  安装httpd服务</h3><pre><code>示例：httpd.yml- hosts: websrvs  remote_user: root  tasks:    - name: Install httpd      yum: name=httpd state=present    - name: Install configure file      copy: src=files/httpd.conf dest=/etc/httpd/conf/    - name: start service      service: name=httpd state=started enabled=yes</code></pre><h3 id="Playbook示例-安装nginx服务"><a href="#Playbook示例-安装nginx服务" class="headerlink" title="Playbook示例  安装nginx服务"></a>Playbook示例  安装nginx服务</h3><pre><code>示例 nginx.yml- hosts: all  remote_user: root  tasks:    - name: add group nginx      user: name=nginx state=present    - name: add user nginx      user: name=nginx state=present group=nginx    - name: Install Nginx      yum: name=nginx state=present    - name: Start Nginx      service: name=nginx state=started enabled=yes</code></pre><h3 id="handlers和notify结合使用触发条件"><a href="#handlers和notify结合使用触发条件" class="headerlink" title="handlers和notify结合使用触发条件"></a>handlers和notify结合使用触发条件</h3><pre><code>Handlers 实际上就是一个触发器是task列表，这些task与前述的task并没有本质上的不同,用于当关注的资源发生变化时，才会采取一定的操作Notify此action可用于在每个play的最后被触发，这样可避免多次有改变发生时每次都执行指定的操作，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作</code></pre><h3 id="Playbook中handlers使用"><a href="#Playbook中handlers使用" class="headerlink" title="Playbook中handlers使用"></a>Playbook中handlers使用</h3><pre><code>- hosts: websrvs  remote_user: root  tasks:    - name: Install httpd      yum: name=httpd state=present    - name: Install configure file      copy: src=files/httpd.conf dest=/etc/httpd/conf/      notify: restart httpd    - name: ensure apache is running      service: name=httpd state=started enabled=yes    handlers:    - name: restart httpd      service: name=httpd state=restarted</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>- hosts: webnodes  vars:    http_port: 80    max_clients: 256  remote_user: root    tasks:    - name: ensure apache is at the latest version      yum: name=httpd state=latest    - name: ensure apache is running      service: name=httpd state=started    - name: Install configure file      copy: src=files/httpd.conf dest=/etc/httpd/conf/      notify: restart httpd    handlers:      - name: restart httpd         service: name=httpd state=restarted</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><pre><code>- hosts: websrvs  remote_user: root    tasks:    - name: add group nginx      tags: user      user: name=nginx state=present    - name: add user nginx      user: name=nginx state=present group=nginx    - name: Install Nginx      yum: name=nginx state=present    - name: config      copy: src=/root/config.txt dest=/etc/nginx/nginx.conf      notify:        - Restart Nginx        - Check Nginx Process    handlers:    - name: Restart Nginx      service: name=nginx state=restarted enabled=yes    - name: Check Nginx process      shell: killall -0 nginx &gt; /tmp/nginx.log</code></pre><h3 id="Playbook中tags使用"><a href="#Playbook中tags使用" class="headerlink" title="Playbook中tags使用"></a>Playbook中tags使用</h3><pre><code>tage: 添加标签 可以指定某一个任务添加一个标签,添加标签以后,想执行某个动作可以做出挑选来执行多个动作可以使用同一个标签示例：httpd.yml- hosts: websrvs  remote_user: root    tasks:    - name: Install httpd      yum: name=httpd state=present      tage: install     - name: Install configure file      copy: src=files/httpd.conf dest=/etc/httpd/conf/      tags: conf    - name: start httpd service      tags: service      service: name=httpd state=started enabled=yesansible-playbook –t install,conf httpd.yml   指定执行install,conf 两个标签</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><pre><code>//heartbeat.yaml- hosts: hbhosts  remote_user: root    tasks:    - name: ensure heartbeat latest version      yum: name=heartbeat state=present    - name: authkeys configure file      copy: src=/root/hb_conf/authkeys dest=/etc/ha.d/authkeys    - name: authkeys mode 600      file: path=/etc/ha.d/authkeys mode=600      notify:        - restart heartbeat    - name: ha.cf configure file      copy: src=/root/hb_conf/ha.cf dest=/etc/ha.d/ha.cf      notify:        - restart heartbeat  handlers:    - name: restart heartbeat      service: name=heartbeat state=restarted</code></pre><h3 id="Playbook中tags使用-1"><a href="#Playbook中tags使用-1" class="headerlink" title="Playbook中tags使用"></a>Playbook中tags使用</h3><pre><code>- hosts: testsrv  remote_user: root  tags: inshttpd   针对整个playbook添加tage  tasks:    - name: Install httpd      yum: name=httpd state=present    - name: Install configure file      copy: src=files/httpd.conf dest=/etc/httpd/conf/      tags: rshttpd      notify: restart httpd  handlers:    - name: restart httpd      service: name=httpd status=restarted     ansible-playbook –t rshttpd httpd2.yml</code></pre><h3 id="Playbook中变量的使用"><a href="#Playbook中变量的使用" class="headerlink" title="Playbook中变量的使用"></a>Playbook中变量的使用</h3><pre><code>变量名：仅能由字母、数字和下划线组成，且只能以字母开头变量来源：    1&gt; ansible setup facts 远程主机的所有变量都可直接调用 (系统自带变量)       setup模块可以实现系统中很多系统信息的显示                可以返回每个主机的系统信息包括:版本、主机名、cpu、内存       ansible all -m setup -a &#39;filter=&quot;ansible_nodename&quot;&#39;     查询主机名       ansible all -m setup -a &#39;filter=&quot;ansible_memtotal_mb&quot;&#39;  查询主机内存大小       ansible all -m setup -a &#39;filter=&quot;ansible_distribution_major_version&quot;&#39;  查询系统版本       ansible all -m setup -a &#39;filter=&quot;ansible_processor_vcpus&quot;&#39; 查询主机cpu个数        2&gt; 在/etc/ansible/hosts(主机清单)中定义变量        普通变量：主机组中主机单独定义，优先级高于公共变量(单个主机 )        公共(组)变量：针对主机组中所有主机定义统一变量(一组主机的同一类别)        3&gt; 通过命令行指定变量，优先级最高       ansible-playbook –e varname=value        4&gt; 在playbook中定义       vars:        - var1: value1        - var2: value2        5&gt; 在独立的变量YAML文件中定义        6&gt; 在role中定义变量命名:    变量名仅能由字母、数字和下划线组成，且只能以字母开头变量定义：key=value    示例：http_port=80变量调用方式：    1&gt; 通过&#123;&#123; variable_name &#125;&#125; 调用变量，且变量名前后必须有空格，有时用“&#123;&#123; variable_name &#125;&#125;”才生效    2&gt; ansible-playbook –e 选项指定       ansible-playbook test.yml -e &quot;hosts=www user=magedu&quot;</code></pre><pre><code>在主机清单中定义变量,在ansible中使用变量vim /etc/ansible/hosts[appsrvs]192.168.38.17 http_port=817 name=www192.168.38.27 http_port=827 name=web调用变量ansible appsrvs -m hostname -a&#39;name=&#123;&#123;name&#125;&#125;&#39;  更改主机名为各自被定义的变量 针对一组设置变量[appsrvs:vars]make=&quot;-&quot;ansible appsrvs -m hostname -a &#39;name=&#123;&#123;name&#125;&#125;&#123;&#123;mark&#125;&#125;&#123;&#123;http_port&#125;&#125;&#39;  ansible调用变量</code></pre><pre><code>将变量写进单独的配置文件中引用vim vars.ymlpack: vsftpdservice: vsftpd引用变量文件vars_files:  - vars.yml     </code></pre><h3 id="Ansible基础元素"><a href="#Ansible基础元素" class="headerlink" title="Ansible基础元素"></a>Ansible基础元素</h3><pre><code>Facts：是由正在通信的远程目标主机发回的信息，这些信息被保存在ansible变量中。       要获取指定的远程主机所支持的所有facts，可使用如下命令进行       ansible websrvs -m setup通过命令行传递变量    在运行playbook的时候也可以传递一些变量供playbook使用    示例：        ansible-playbook test.yml -e &quot;hosts=www user=magedu&quot;        register把任务的输出定义为变量，然后用于其他任务示例:tasks:- shell: /usr/bin/foo  register: foo_result  ignore_errors: True</code></pre><h3 id="示例：使用setup变量"><a href="#示例：使用setup变量" class="headerlink" title="示例：使用setup变量"></a>示例：使用setup变量</h3><pre><code>示例：var.yml- hosts: websrvs  remote_user: root  tasks:    - name: create log file      file: name=/var/log/ &#123;&#123; ansible_fqdn &#125;&#125; state=touchansible-playbook var.yml</code></pre><h3 id="示例：变量"><a href="#示例：变量" class="headerlink" title="示例：变量"></a>示例：变量</h3><pre><code>示例：var.yml- hosts: websrvs  remote_user: root  tasks:    - name: install package      yum: name=&#123;&#123; pkname &#125;&#125; state=present      ansible-playbook –e pkname=httpd var.yml</code></pre><h3 id="示例：变量-1"><a href="#示例：变量-1" class="headerlink" title="示例：变量"></a>示例：变量</h3><pre><code>示例：var.yml- hosts: websrvs  remote_user: rootvars:  - username: user1  - groupname: group1tasks:  - name: create group    group: name=&#123;&#123; groupname &#125;&#125; state=present  - name: create user    user: name=&#123;&#123; username &#125;&#125; state=presentansible-playbook var.ymlansible-playbook -e &quot;username=user2 groupname=group2” var2.yml</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code>主机变量可以在inventory中定义主机时为其添加主机变量以便于在playbook中使用示例：[websrvs]www1.magedu.com http_port=80 maxRequestsPerChild=808www2.magedu.com http_port=8080 maxRequestsPerChild=909组变量组变量是指赋予给指定组内所有主机上的在playbook中可用的变量示例：    [websrvs]    www1.magedu.com    www2.magedu.com    [websrvs:vars]    ntp_server=ntp.magedu.com    nfs_server=nfs.magedu.com</code></pre><h3 id="示例：变量-2"><a href="#示例：变量-2" class="headerlink" title="示例：变量"></a>示例：变量</h3><pre><code>普通变量    [websrvs]    192.168.99.101 http_port=8080 hname=www1    192.168.99.102 http_port=80 hname=www2公共（组）变量    [websvrs:vars]    http_port=808    mark=&quot;_&quot;    [websrvs]    192.168.99.101 http_port=8080 hname=www1    192.168.99.102 http_port=80 hname=www2    ansible websvrs –m hostname –a ‘name=&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; http_port &#125;&#125;’命令行指定变量：    ansible websvrs –e http_port=8000 –m hostname –a&#39;name=&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; http_port &#125;&#125;&#39;</code></pre><h3 id="使用变量文件"><a href="#使用变量文件" class="headerlink" title="使用变量文件"></a>使用变量文件</h3><pre><code>cat vars.ymlvar1: httpdvar2: nginxcat var.yml- hosts: web  remote_user: root  vars_files:    - vars.yml  tasks:    - name: create httpd log      file: name=/app/&#123;&#123; var1 &#125;&#125;.log state=touch    - name: create nginx log      file: name=/app/&#123;&#123; var2 &#125;&#125;.log state=touch      hostname app_81.magedu.com  hostname 不支持&quot;_&quot;,认为&quot;_&quot;是非法字符hostnamectl set-hostname app_80.magedu.com  可以更改主机名</code></pre><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><pre><code>组嵌套inventory中，组还可以包含其它的组，并且也可以向组中的主机指定变量。这些变量只能在ansible-playbook中使用，而ansible命令不支持示例：    [apache]    httpd1.magedu.com    httpd2.magedu.com        [nginx]    ngx1.magedu.com    ngx2.magedu.com        [websrvs:children]    apache    nginx        [webservers:vars]    ntp_server=ntp.magedu.com</code></pre><h3 id="invertory参数"><a href="#invertory参数" class="headerlink" title="invertory参数"></a>invertory参数</h3><pre><code>invertory参数：用于定义ansible远程连接目标主机时使用的参数，而非传递给playbook的变量    ansible_ssh_host    ansible_ssh_port    ansible_ssh_user    ansible_ssh_pass    ansbile_sudo_pass示例：    cat /etc/ansible/hosts    [websrvs]    192.168.0.1 ansible_ssh_user=root ansible_ssh_pass=magedu    192.168.0.2 ansible_ssh_user=root ansible_ssh_pass=magedu</code></pre><h3 id="invertory参数-1"><a href="#invertory参数-1" class="headerlink" title="invertory参数"></a>invertory参数</h3><pre><code>inventory参数ansible基于ssh连接inventory中指定的远程主机时，还可以通过参数指定其交互方式；这些参数如下所示：ansible_ssh_hostThe name of the host to connect to, if different from the alias you wishto give to it.ansible_ssh_portThe ssh port number, if not 22ansible_ssh_userThe default ssh user name to use.ansible_ssh_passThe ssh password to use (this is insecure, we strongly recommendusing --ask-pass or SSH keys)ansible_sudo_passThe sudo password to use (this is insecure, we strongly recommendusing --ask-sudo-pass)ansible_connectionConnection type of the host. Candidates are local, ssh or paramiko.The default is paramiko before Ansible 1.2, and &#39;smart&#39; afterwards whichdetects whether usage of &#39;ssh&#39; would be feasible based on whetherControlPersist is supported.ansible_ssh_private_key_filePrivate key file used by ssh. Useful if using multiple keys and you don&#39;t want to use SSH agent.ansible_shell_typeThe shell type of the target system. By default commands are formattedusing &#39;sh&#39;-style syntax by default. Setting this to &#39;csh&#39; or &#39;fish&#39; will causecommands executed on target systems to follow those shell&#39;s syntax instead.ansible_python_interpreterThe target host python path. This is useful for systems with morethan one Python or not located at &quot;/usr/bin/python&quot; such as \*BSD, or where /usr/bin/pythonis not a 2.X series Python. We do not use the &quot;/usr/bin/env&quot; mechanism as that requires the remote user&#39;spath to be set right and also assumes the &quot;python&quot; executable is named python,where the executable mightbe named something like &quot;python26&quot;.ansible\_\*\_interpreterWorks for anything such as ruby or perl and works just like ansible_python_interpreter.This replaces shebang of modules which will run on that host.</code></pre><h3 id="模板templates"><a href="#模板templates" class="headerlink" title="模板templates"></a>模板templates</h3><pre><code>文本文件，嵌套有脚本（使用模板编程语言编写） 借助模板生成真正的文件Jinja2语言，使用字面量，有下面形式    字符串：使用单引号或双引号    数字：整数，浮点数    列表：[item1, item2, ...]    元组：(item1, item2, ...)    字典：&#123;key1:value1, key2:value2, ...&#125;    布尔型：true/false算术运算：+, -, *, /, //, %, **比较操作：==, !=, &gt;, &gt;=, &lt;, &lt;=逻辑运算：and，or，not流表达式：For，If，When</code></pre><h3 id="Jinja2相关"><a href="#Jinja2相关" class="headerlink" title="Jinja2相关"></a>Jinja2相关</h3><pre><code>字面量    1&gt; 表达式最简单的形式就是字面量。字面量表示诸如字符串和数值的 Python对象。如“Hello World”    双引号或单引号中间的一切都是字符串。    2&gt; 无论何时你需要在模板中使用一个字符串（比如函数调用、过滤器或只是包含或继承一个模板的参数），如4242.23    3&gt; 数值可以为整数和浮点数。如果有小数点，则为浮点数，否则为整数。在Python 里， 42 和 42.0 是不一样的</code></pre><h3 id="Jinja2-算术运算"><a href="#Jinja2-算术运算" class="headerlink" title="Jinja2:算术运算"></a>Jinja2:算术运算</h3><pre><code>算术运算Jinja 允许你用计算值。这在模板中很少用到，但为了完整性允许其存在支持下面的运算符    +：把两个对象加到一起。       通常对象是素质，但是如果两者是字符串或列表，你可以用这 种方式来衔接它们。       无论如何这不是首选的连接字符串的方式！连接字符串见 ~ 运算符。 &#123;&#123; 1 + 1 &#125;&#125; 等于 2    -：用第一个数减去第二个数。 &#123;&#123; 3 - 2 &#125;&#125; 等于 1    /：对两个数做除法。返回值会是一个浮点数。 &#123;&#123; 1 / 2 &#125;&#125; 等于 &#123;&#123; 0.5 &#125;&#125;    //：对两个数做除法，返回整数商。 &#123;&#123; 20 // 7 &#125;&#125; 等于 2    %：计算整数除法的余数。 &#123;&#123; 11 % 7 &#125;&#125; 等于 4    *：用右边的数乘左边的操作数。 &#123;&#123; 2 * 2 &#125;&#125; 会返回 4 。       也可以用于重 复一个字符串多次。&#123;&#123; ‘=’ * 80 &#125;&#125; 会打印 80 个等号的横条    **：取左操作数的右操作数次幂。 &#123;&#123; 2**3 &#125;&#125; 会返回 8</code></pre><h3 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h3><pre><code>比较操作符== 比较两个对象是否相等!= 比较两个对象是否不等&gt; 如果左边大于右边，返回 true&gt;= 如果左边大于等于右边，返回 true&lt; 如果左边小于右边，返回 true&lt;= 如果左边小于等于右边，返回 true逻辑运算符对于 if 语句，在 for 过滤或 if 表达式中，它可以用于联合多个表达式and    如果左操作数和右操作数同为真，返回 trueor    如果左操作数和右操作数有一个为真，返回 truenot    对一个表达式取反（见下）(expr)    表达式组[&#39;list&#39;, &#39;of&#39;, &#39;objects&#39;]:一对中括号括起来的东西是一个列表。列表用于存储和迭代序列化的数据。例如 你可以容易地在 for循环中用列表和元组创建一个链接的列表    &lt;ul&gt;    &#123;% for href, caption in [('index.html', 'Index'), ('about.html', 'About'), ('downloads.html','Downloads')] %&#125;     <li> <a href="&#123;&#123; href &#125;&#125;"> &#123;&#123; caption &#125;&#125; </a>   </li>    &#123;% endfor %&#125;    &lt;/ul&gt;    (&#39;tuple&#39;, &#39;of&#39;, &#39;values&#39;):元组与列表类似，只是你不能修改元组。如果元组中只有一个项，你需要以逗号结尾它。元组通常用于表示两个或更多元素的项。更多细节见上面的例子    &#123;&#39;dict&#39;: &#39;of&#39;, &#39;key&#39;: &#39;and&#39;, &#39;value&#39;: &#39;pairs&#39;&#125;:Python 中的字典是一种关联键和值的结构。键必须是唯一的，并且键必须只有一个 值。字典在模板中很少使用，罕用于诸如 xmlattr() 过滤器之类    true / false:    true 永远是 true ，而 false 始终是 false</code></pre><h3 id="template-的使用"><a href="#template-的使用" class="headerlink" title="template 的使用"></a>template 的使用</h3><pre><code>template功能：根据模块文件动态生成对应的配置文件   &gt; template文件必须存放于templates目录下，且命名为 .j2 结尾   &gt; yaml/yml 文件需和templates目录平级，目录结构如下：    ./     ├── temnginx.yml     └── templates        └── nginx.conf.j2</code></pre><h3 id="template示例"><a href="#template示例" class="headerlink" title="template示例"></a>template示例</h3><pre><code>示例：利用template 同步nginx配置文件准备templates/nginx.conf.j2文件vim temnginx.yml- hosts: websrvs  remote_user: root    tasks:    - name: template config to remote hosts      template: src=nginx.conf.j2 dest=/etc/nginx/nginx.confansible-playbook temnginx.yml</code></pre><h3 id="Playbook中template变更替换"><a href="#Playbook中template变更替换" class="headerlink" title="Playbook中template变更替换"></a>Playbook中template变更替换</h3><pre><code>修改文件nginx.conf.j2 下面行为worker_processes &#123;&#123; ansible_processor_vcpus &#125;&#125;;cat temnginx2.yml- hosts: websrvs  remote_user: root  tasks:    - name: template config to remote hosts      template: src=nginx.conf.j2 dest=/etc/nginx/nginx.confansible-playbook temnginx2.yml</code></pre><h3 id="Playbook中template算术运算"><a href="#Playbook中template算术运算" class="headerlink" title="Playbook中template算术运算"></a>Playbook中template算术运算</h3><pre><code>算法运算：示例：    vim nginx.conf.j2    worker_processes &#123;&#123; ansible_processor_vcpus**2 &#125;&#125;;    worker_processes &#123;&#123; ansible_processor_vcpus+2 &#125;&#125;;</code></pre><h3 id="when-实现条件判断"><a href="#when-实现条件判断" class="headerlink" title="when  实现条件判断"></a>when  实现条件判断</h3><pre><code>条件测试:如果需要根据变量、facts或此前任务的执行结果来做为某task执行与否的前提时要用到条件测试,通过when语句实现，在task中使用，jinja2的语法格式when语句    在task后添加when子句即可使用条件测试；when语句支持Jinja2表达式语法示例：tasks:  - name: &quot;shutdown RedHat flavored systems&quot;    command: /sbin/shutdown -h now    when: ansible_os_family == &quot;RedHat&quot;  当系统属于红帽系列,执行command模块  when语句中还可以使用Jinja2的大多&quot;filter&quot;，例如要忽略此前某语句的错误并基于其结果(failed或者success)运行后面指定的语句，可使用类似如下形式：tasks:  - command: /bin/false    register: result    ignore_errors: True  - command: /bin/something    when: result|failed  - command: /bin/something_else    when: result|success  - command: /bin/still/something_else    when: result|skipped此外，when语句中还可以使用facts或playbook中定义的变量</code></pre><h3 id="示例：when条件判断"><a href="#示例：when条件判断" class="headerlink" title="示例：when条件判断"></a>示例：when条件判断</h3><pre><code>- hosts: websrvs  remote_user: root  tasks:    - name: add group nginx      tags: user      user: name=nginx state=present    - name: add user nginx      user: name=nginx state=present group=nginx    - name: Install Nginx      yum: name=nginx state=present    - name: restart Nginx      service: name=nginx state=restarted      when: ansible_distribution_major_version == &quot;6&quot;</code></pre><h3 id="示例：when条件判断-1"><a href="#示例：when条件判断-1" class="headerlink" title="示例：when条件判断"></a>示例：when条件判断</h3><pre><code>示例：tasks:  - name: install conf file to centos7    template: src=nginx.conf.c7.j2 dest=/etc/nginx/nginx.conf    when: ansible_distribution_major_version == &quot;7&quot;  - name: install conf file to centos6    template: src=nginx.conf.c6.j2 dest=/etc/nginx/nginx.conf    when: ansible_distribution_major_version == &quot;6&quot;</code></pre><h3 id="Playbook中when条件判断"><a href="#Playbook中when条件判断" class="headerlink" title="Playbook中when条件判断"></a>Playbook中when条件判断</h3><pre><code>---- hosts: srv120  remote_user: root  tasks:    - name:      template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf      when: ansible_distribution_major_version == &quot;7&quot;</code></pre><p><img src="/../images/whenplaybook.png" alt="image"></p><h3 id="迭代：with-items"><a href="#迭代：with-items" class="headerlink" title="迭代：with_items"></a>迭代：with_items</h3><pre><code>迭代：当有需要重复性执行的任务时，可以使用迭代机制    &gt; 对迭代项的引用，固定变量名为&quot;item&quot;    &gt; 要在task中使用with_items给定要迭代的元素列表    &gt; 列表格式：         字符串         字典</code></pre><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><pre><code>示例： 创建用户- name: add several users  user: name=&#123;&#123; item &#125;&#125; state=present groups=wheel   #&#123;&#123; item &#125;&#125; 系统自定义变量  with_items:       # 定义&#123;&#123; item &#125;&#125; 的值和个数    - testuser1    - testuser2上面语句的功能等同于下面的语句：- name: add user testuser1  user: name=testuser1 state=present groups=wheel- name: add user testuser2  user: name=testuser2 state=present groups=wheel  with_items中可以使用元素还可为hashes示例：- name: add several users  user: name=&#123;&#123; item.name &#125;&#125; state=present groups=&#123;&#123; item.groups &#125;&#125;  with_items:    - &#123; name: &#39;testuser1&#39;, groups: &#39;wheel&#39; &#125;    - &#123; name: &#39;testuser2&#39;, groups: &#39;root&#39; &#125;ansible的循环机制还有更多的高级功能，具体请参见官方文档http://docs.ansible.com/playbooks_loops.html</code></pre><h3 id="示例：迭代"><a href="#示例：迭代" class="headerlink" title="示例：迭代"></a>示例：迭代</h3><pre><code>示例：将多个文件进行copy到被控端---- hosts: testsrv  remote_user: root  tasks  - name: Create rsyncd config    copy: src=&#123;&#123; item &#125;&#125; dest=/etc/&#123;&#123; item &#125;&#125;    with_items:  - rsyncd.secrets  - rsyncd.conf</code></pre><h3 id="示例：迭代-1"><a href="#示例：迭代-1" class="headerlink" title="示例：迭代"></a>示例：迭代</h3><pre><code>- hosts: websrvs  remote_user: root  tasks:    - name: copy file      copy: src=&#123;&#123; item &#125;&#125; dest=/tmp/&#123;&#123; item &#125;&#125;      with_items:    - file1    - file2    - file3- name: yum install httpd  yum: name=&#123;&#123; item &#125;&#125; state=present  with_items:    - apr    - apr-util    - httpd</code></pre><h3 id="示例：迭代-2"><a href="#示例：迭代-2" class="headerlink" title="示例：迭代"></a>示例：迭代</h3><pre><code>- hosts：websrvs  remote_user: root  tasks    - name: install some packages      yum: name=&#123;&#123; item &#125;&#125; state=present      with_items:        - nginx        - memcached        - php-fpm</code></pre><h3 id="示例：迭代嵌套子变量"><a href="#示例：迭代嵌套子变量" class="headerlink" title="示例：迭代嵌套子变量"></a>示例：迭代嵌套子变量</h3><pre><code>- hosts：websrvs  remote_user: root    tasks:    - name: add some groups      group: name=&#123;&#123; item &#125;&#125; state=present      with_items:        - group1        - group2        - group3    - name: add some users      user: name=&#123;&#123; item.name &#125;&#125; group=&#123;&#123; item.group &#125;&#125; state=present      with_items:        - &#123; name: &#39;user1&#39;, group: &#39;group1&#39; &#125;        - &#123; name: &#39;user2&#39;, group: &#39;group2&#39; &#125;        - &#123; name: &#39;user3&#39;, group: &#39;group3&#39; &#125;</code></pre><h3 id="with-itmes-嵌套子变量"><a href="#with-itmes-嵌套子变量" class="headerlink" title="with_itmes 嵌套子变量"></a>with_itmes 嵌套子变量</h3><pre><code>with_itmes 嵌套子变量示例---- hosts: testweb  remote_user: root  tasks:    - name: add several users      user: name=&#123;&#123; item.name &#125;&#125; state=present groups=&#123;&#123; item.groups &#125;&#125;      with_items:    - &#123; name: &#39;testuser1&#39; , groups: &#39;wheel&#39;&#125;    - &#123; name: &#39;testuser2&#39; , groups: &#39;root&#39;&#125;</code></pre><h3 id="Playbook字典-with-items"><a href="#Playbook字典-with-items" class="headerlink" title="Playbook字典 with_items"></a>Playbook字典 with_items</h3><pre><code>- name: 使用ufw模块来管理哪些端口需要开启  ufw:  rule: “&#123;&#123; item.rule &#125;&#125;”  port: “&#123;&#123; item.port &#125;&#125;”  proto: “&#123;&#123; item.proto &#125;&#125;”  with_items:    - &#123; rule: &#39;allow&#39;, port: 22, proto: &#39;tcp&#39; &#125;    - &#123; rule: &#39;allow&#39;, port: 80, proto: &#39;tcp&#39; &#125;    - &#123; rule: &#39;allow&#39;, port: 123, proto: &#39;udp&#39; &#125;- name: 配置网络进出方向的默认规则  ufw:  direction: &quot;&#123;&#123; item.direction &#125;&#125;&quot;  policy: &quot;&#123;&#123; item.policy &#125;&#125;&quot;  state: enabled  with_items:    - &#123; direction: outgoing, policy: allow &#125;    - &#123; direction: incoming, policy: deny &#125;</code></pre><h3 id="Playbook中template-for-if-when循环"><a href="#Playbook中template-for-if-when循环" class="headerlink" title="Playbook中template for if  when循环"></a>Playbook中template for if  when循环</h3><pre><code>&#123;% for vhost in nginx_vhosts %&#125;server &#123;    #重复执行server代码listen &#123;&#123; vhost.listen | default('80 default_server') &#125;&#125;;&#123;% if vhost.server_name is defined %&#125;server_name &#123;&#123; vhost.server_name &#125;&#125;;&#123;% endif %&#125;&#123;% if vhost.root is defined %&#125;root &#123;&#123; vhost.root &#125;&#125;;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><pre><code>// temnginx.yml---- hosts: testweb  remote_user: root  vars:      # 调用变量    nginx_vhosts:      - listen: 8080  #列表 键值对//templates/nginx.conf.j2&#123;% for vhost in nginx_vhosts %&#125;  server &#123;  listen &#123;&#123; vhost.listen &#125;&#125;&#125;&#123;% endfor %&#125;生成的结果server &#123;  listen 8080&#125;</code></pre><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><pre><code>// temnginx.yml---- hosts: mageduweb  remote_user: root  vars:    nginx_vhosts:      - web1      - web2      - web3  tasks:    - name: template config      template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf// templates/nginx.conf.j2&#123;% for vhost in nginx_vhosts %&#125;server &#123;    listen &#123;&#123; vhost &#125;&#125;&#125;&#123;% endfor %&#125;生成的结果：server &#123;    listen web1&#125;server &#123;    listen web2&#125;server &#123;    listen web3&#125;</code></pre><h3 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h3><pre><code>roles    ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。    roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。    要使用roles只需要在playbook中使用include指令即可。    简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，    并可以便捷地include它们的一种机制。    角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中复杂场景：建议使用roles，代码复用度高    变更指定主机或主机组    如命名不规范维护和传承成本大    某些功能需多个Playbook，通过includes即可实现</code></pre><h3 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h3><pre><code>角色(roles)：角色集合roles/    mysql/    httpd/    nginx/    memcached/    可以互相调用</code></pre><h3 id="Ansible-Roles目录编排"><a href="#Ansible-Roles目录编排" class="headerlink" title="Ansible Roles目录编排"></a>Ansible Roles目录编排</h3><p><img src="/../images/roles.png" alt="image"> </p><h3 id="roles目录结构"><a href="#roles目录结构" class="headerlink" title="roles目录结构"></a>roles目录结构</h3><pre><code>每个角色，以特定的层级目录结构进行组织roles目录结构：playbook.yml  调用角色roles/  project/ (角色名称)    tasks/    files/    vars/    templates/    handlers/    default/ 不常用    meta/    不常用</code></pre><h3 id="Roles各目录作用"><a href="#Roles各目录作用" class="headerlink" title="Roles各目录作用"></a>Roles各目录作用</h3><pre><code>/roles/project/ :项目名称,有以下子目录    files/ ：存放由copy或script模块等调用的文件    templates/：template模块查找所需要模板文件的目录    tasks/：定义task,role的基本元素，至少应该包含一个名为main.yml的文件；            其它的文件需要在此文件中通过include进行包含    handlers/：至少应该包含一个名为main.yml的文件；               其它的文件需要在此文件中通过include进行包含    vars/：定义变量，至少应该包含一个名为main.yml的文件；           其它的文件需要在此文件中通过include进行包含    meta/：定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，           其它文件需在此文件中通过include进行包含    default/：设定默认变量时使用此目录中的main.yml文件    roles/appname 目录结构    tasks目录：至少应该包含一个名为main.yml的文件，其定义了此角色的任务列表；               此文件可以使用include包含其它的位于此目录中的task文件    files目录：存放由copy或script等模块调用的文件；    templates目录：template模块会自动在此目录中寻找Jinja2模板文件    handlers目录：此目录中应当包含一个main.yml文件，用于定义此角色用到的各handler；                  在handler中使用include包含的其它的handler文件也应该位于此目录中；    vars目录：应当包含一个main.yml文件，用于定义此角色用到的变量；    meta目录：应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；              ansible1.3及其以后的版本才支持；    default目录：为当前角色设定默认变量时使用此目录；应当包含一个main.yml文件roles/example_role/files/             所有文件，都将可存放在这里roles/example_role/templates/         所有模板都存放在这里roles/example_role/tasks/main.yml：   主函数，包括在其中的所有任务将被执行roles/example_role/handlers/main.yml：所有包括其中的 handlers 将被执行roles/example_role/vars/main.yml：    所有包括在其中的变量将在roles中生效roles/example_role/meta/main.yml：    roles所有依赖将被正常登入</code></pre><h3 id="创建role"><a href="#创建role" class="headerlink" title="创建role"></a>创建role</h3><pre><code>创建role的步骤(1) 创建以roles命名的目录(2) 在roles目录中分别创建以各角色名称命名的目录，如webservers等(3) 在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录；    用不到的目录可以创建为空目录，也可以不创建(4) 在playbook文件中，调用各角色</code></pre><h3 id="实验-创建httpd角色"><a href="#实验-创建httpd角色" class="headerlink" title="实验: 创建httpd角色"></a>实验: 创建httpd角色</h3><pre><code>1&gt; 创建roles目录   mkdir roles/&#123;httpd,mysql,redis&#125;/tasks -pv   mkdir  roles/httpd/&#123;handlers,files&#125;查看目录结构tree roles/    roles/    ├── httpd    │   ├── files    │   ├── handlers    │   └── tasks    ├── mysql    │   └── tasks    └── redis        └── tasks2&gt; 创建目标文件   cd roles/httpd/tasks/   touch install.yml config.yml service.yml3&gt; vim install.yml   - name: install httpd package     yum: name=httpd        vim config.yml   - name: config file       copy: src=httpd.conf dest=/etc/httpd/conf/ backup=yes       vim service.yml   - name: start service      service: name=httpd state=started enabled=yes     4&gt; 创建main.yml主控文件,调用以上单独的yml文件,   main.yml定义了谁先执行谁后执行的顺序   vim main.yml   - include: install.yml   - include: config.yml   - include: service.yml   5&gt; 准备httpd.conf文件,放到httpd单独的文件目录下   cp /app/ansible/flies/httpd.conf ../files/   6&gt; 创建一个网页   vim flies/index.html   &lt;h1&gt; welcome to weixiaodong home &lt;\h1&gt;7&gt; 创建网页的yml文件   vim tasks/index.yml   - name: index.html     copy: src=index.html dest=/var/www/html 8&gt; 将网页的yml文件写进mian.yml文件中   vim mian.yml   - include: install.yml   - include: config.yml   - include: index.yml   - include: service.yml9&gt; 在handlers目录下创建handler文件mian.yml   vim handlers/main.yml   - name: restart service httpd     service: name=httpd state=restarted10&gt; 创建文件调用httpd角色    cd /app/ansidle/roles    vim role_httpd.yml    ---    # httpd role    - hosts: appsrvs      remote_user: root       roles:       #调用角色        - role: httpd          11&gt; 查看目录结构    tree     .    httpd    ├── files    │   ├── httpd.conf    │   └── index.html    ├── handlers    │   └── main.yml    └── tasks        ├── config.yml        ├── index.yml        ├── install.yml        ├── main.yml        └── service.yml12&gt; ansible-playbook role_httpd.yml</code></pre><h3 id="针对大型项目使用Roles进行编排"><a href="#针对大型项目使用Roles进行编排" class="headerlink" title="针对大型项目使用Roles进行编排"></a>针对大型项目使用Roles进行编排</h3><pre><code>roles目录结构：playbook.ymlroles/  project/    tasks/    files/    vars/    templates/    handlers/    default/ # 不经常用    meta/    # 不经常用示例：nginx-role.ymlroles/└── nginx    ├── files    │ └── main.yml    ├── tasks    │ ├── groupadd.yml    │ ├── install.yml    │ ├── main.yml    │ ├── restart.yml    │ └── useradd.yml    └── vars        └── main.yml</code></pre><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><pre><code>roles的示例如下所示：site.ymlwebservers.ymldbservers.ymlroles/  common/    files/    templates/    tasks/    handlers/    vars/    meta/  webservers/    files/    templates/    tasks/  handlers/    vars/    meta/</code></pre><h3 id="实验：-创建一个nginx角色"><a href="#实验：-创建一个nginx角色" class="headerlink" title="实验： 创建一个nginx角色"></a>实验： 创建一个nginx角色</h3><pre><code>建立nginx角色在多台主机上来部署nginx需要安装 创建账号1&gt; 创建nginx角色目录     cd /app/ansible/role     mkdir nginx&#123;tesks,templates,hanslers&#125; -pv2&gt; 创建任务目录     cd tasks/     touch insatll.yml config.yml service.yml file.yml user.yml   创建main.yml文件定义任务执行顺序     vim main.yml     - include: user.yml     - include: insatll.yml     - include: config.yml     - include: file.yml     - include: service.yml  3&gt; 准备配置文件(centos7、8)   ll /app/ansible/role/nginx/templates/   nginx7.conf.j2   nginx8.conf.j24&gt; 定义任务   vim tasks/install.yml   - name: install     yum: name=nginx        vim tasks/config.yml    - name: config file      template: src=nginx7.conf.j2 dest=/etc/nginx/nginx.conf      when: ansible_distribution_major_version==&quot;7&quot;      notify: restrat          - name: config file      template: src=nginx8.conf.j2 dest=/etc/nginx/nginx.conf      when: ansible_distribution_major_version==&quot;8&quot;      notify: restrat          vim tasks/file.yml   跨角色调用file.yum文件,实现文件复用    - name: index.html      copy: src=roles/httpd/files/index.html dest=/usr/share/nginx/html/        vim tasks/service.yml    - nmae: start service      service: name=nginx state=started enabled=yes          vim handlers/main.yml    - name: restrat      service: name=nginx state=restarted          vim roles/role_nginix.yml    ---     #test rcle    - hosts: appsrvs          roles:         - role: nginx        5&gt; 测试安装   ansible-playbook role_nginx.yml</code></pre><h3 id="Roles案例"><a href="#Roles案例" class="headerlink" title="Roles案例"></a>Roles案例</h3><p>Roles目录编排<br><img src="/../images/roles1.png" alt="image"></p><p>Playbook中调用<br><img src="/../images/roles2.png" alt="image"></p><h3 id="playbook调用角色"><a href="#playbook调用角色" class="headerlink" title="playbook调用角色"></a>playbook调用角色</h3><pre><code>调用角色方法1：- hosts: websrvs  remote_user: root    roles:    - mysql    - memcached    - nginx    调用角色方法2：传递变量给角色- hosts:  remote_user:  roles:    - mysql    - &#123; role: nginx, username: nginx &#125;   #不同的角色调用不同的变量      键role用于指定角色名称    后续的k/v用于传递变量给角色调用角色方法3：还可基于条件测试实现角色调用roles:  - &#123; role: nginx, username: nginx, when: ansible_distribution_major_version == &#39;7&#39; &#125;</code></pre><h3 id="通过roles传递变量"><a href="#通过roles传递变量" class="headerlink" title="通过roles传递变量"></a>通过roles传递变量</h3><pre><code>通过roles传递变量当给一个主机应用角色的时候可以传递变量，然后在角色内使用这些变量示例：- hosts: webservers  roles:    - common    - &#123; role: foo_app_instance, dir: &#39;/web/htdocs/a.com&#39;, port: 8080 &#125;</code></pre><h3 id="向roles传递参数"><a href="#向roles传递参数" class="headerlink" title="向roles传递参数"></a>向roles传递参数</h3><pre><code>而在playbook中，可以这样使用roles：---- hosts: webservers  roles:    - common    - webservers也可以向roles传递参数示例：---- hosts: webservers  roles:    - common    - &#123; role: foo_app_instance, dir: &#39;/opt/a&#39;, port: 5000 &#125;    - &#123; role: foo_app_instance, dir: &#39;/opt/b&#39;, port: 5001 &#125;</code></pre><h3 id="条件式地使用roles"><a href="#条件式地使用roles" class="headerlink" title="条件式地使用roles"></a>条件式地使用roles</h3><pre><code>甚至也可以条件式地使用roles示例：---- hosts: webservers  roles:    - &#123; role: some_role, when: &quot;ansible_os_family == &#39;RedHat&#39;&quot; &#125;</code></pre><h3 id="Roles条件及变量等案例"><a href="#Roles条件及变量等案例" class="headerlink" title="Roles条件及变量等案例"></a>Roles条件及变量等案例</h3><pre><code>When条件    roles:      - &#123;role: nginx, when: &quot;ansible_distribution_major_version == &#39;7&#39; &quot; ,username: nginx &#125;变量调用- hosts: zabbix-proxy  sudo: yes  roles:    - &#123; role: geerlingguy.php-mysql &#125;    - &#123; role: dj-wasabi.zabbix-proxy, zabbix_server_host: 192.168.37.167 &#125;</code></pre><h3 id="完整的roles架构"><a href="#完整的roles架构" class="headerlink" title="完整的roles架构"></a>完整的roles架构</h3><pre><code>// nginx-role.yml 顶层任务调用yml文件---- hosts: testweb  remote_user: root  roles:    - role: nginx    - role: httpd 可执行多个rolecat roles/nginx/tasks/main.yml---- include: groupadd.yml- include: useradd.yml- include: install.yml- include: restart.yml- include: filecp.yml// roles/nginx/tasks/groupadd.yml---- name: add group nginx  user: name=nginx state=presentcat roles/nginx/tasks/filecp.yml---- name: file copy  copy: src=tom.conf dest=/tmp/tom.conf以下文件格式类似：useradd.yml,install.yml,restart.ymlls roles/nginx/files/tom.conf</code></pre><h3 id="roles-playbook-tags使用"><a href="#roles-playbook-tags使用" class="headerlink" title="roles playbook tags使用"></a>roles playbook tags使用</h3><pre><code>roles playbook tags使用    ansible-playbook --tags=&quot;nginx,httpd,mysql&quot; nginx-role.yml  对标签进行挑选执行// nginx-role.yml---- hosts: testweb  remote_user: root  roles:    - &#123; role: nginx ,tags: [ &#39;nginx&#39;, &#39;web&#39; ] ,when: ansible_distribution_major_version == &quot;6“ &#125;    - &#123; role: httpd ,tags: [ &#39;httpd&#39;, &#39;web&#39; ] &#125;    - &#123; role: mysql ,tags: [ &#39;mysql&#39;, &#39;db&#39; ] &#125;    - &#123; role: marridb ,tags: [ &#39;mysql&#39;, &#39;db&#39; ] &#125;    - &#123; role: php &#125;</code></pre><h3 id="实验-创建角色memcached"><a href="#实验-创建角色memcached" class="headerlink" title="实验: 创建角色memcached"></a>实验: 创建角色memcached</h3><pre><code>memcacched 当做缓存用,会在内存中开启一块空间充当缓存cat /etc/sysconfig/memcached     PORT=&quot;11211&quot;    USER=&quot;memcached&quot;    MAXCONN=&quot;1024&quot;    CACHESIZE=&quot;64&quot;    # 缓存空间默认64M     OPTIONS=&quot;&quot;1&gt; 创建对用目录   cd /app/ansible   mkdir roles/memcached/&#123;tasks,templates&#125; -pv   2&gt; 拷贝memcached配置文件模板   cp /etc/sysconfig/memcached  templates/memcached.j2   vim templates/memcached.j2   CACHESIZE=&quot;&#123;&#123;ansible_memtotal_mb//4&#125;&#125;&quot;   #物理内存的1/4用做缓存   3&gt; 创建对应yml文件,并做相应配置   cd tasks/   touch install.yml config.yml service.yml   创建main.yml文件定义任务执行顺序   vim main.yml   - include: install.yml   - include: config.yml   - include: service.yml        vim install.yml   - name: install      yum: name=memcached        vim config.yml   - name: config file     template: src=memcached.j2 dets=/etc/sysconfig/memcached   vim service.yml   - name: service     service: name=memcached state=started enabled=yes4&gt; 创建调用角色文件   cd /app/ansible/roles/   vim role_memcached.yml    ---    - hosts: appsrvs          roles:         - role: memcached5&gt; 安装   ansible-playbook  role_memcached.yml    memcached端口号11211</code></pre><h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><pre><code>委任（指定某一台机器做某一个task）    delegate_to    local_action (专指针对ansible命令执行的机器做的变更操作)交互提示    prompt*暂停（java）    wait_forDebug    debug: msg=&quot;This always executes.&quot;IncludeTemplate 多值合并Template 动态变量配置</code></pre><h3 id="Ansible-Roles"><a href="#Ansible-Roles" class="headerlink" title="Ansible Roles"></a>Ansible Roles</h3><pre><code>委任    delegate_to交互提示    prompt暂停    wait_forDebug    debug: msg=&quot;This always executes.&quot;IncludeTemplate 多值合并Template 动态变量配置</code></pre><h3 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h3><pre><code>http://galaxy.ansible.comhttps://galaxy.ansible.com/explore#/http://github.com/http://ansible.com.cn/https://github.com/ansible/ansiblehttps://github.com/ansible/ansible-examples</code></pre><h3 id="实验-实现二进制安装mysql的卸载"><a href="#实验-实现二进制安装mysql的卸载" class="headerlink" title="实验: 实现二进制安装mysql的卸载"></a>实验: 实现二进制安装mysql的卸载</h3><pre><code>cat remove_mysql.yml ---# install mariadb server - hosts: appsrvs:!192.168.38.108  remote_user: root  tasks:    - name: stop service       shell: /etc/init.d/mysqld stop    - name: delete user       user: name=mysql state=absent remove=yes    - name: delete      file: path=&#123;&#123;item&#125;&#125; state=absent      with_items:         - /usr/local/mysql        - /usr/local/mariadb-10.2.27-linux-x86_64        - /etc/init.d/mysqld        - /etc/profile.d/mysql.sh        - /etc/my.cnf        - /data/mysqlansible-playbook  remove_mysql.yml</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mdadm命令详解</title>
      <link href="/c901ebd9.html"/>
      <url>/c901ebd9.html</url>
      
        <content type="html"><![CDATA[<p>Linux内核中有一个md(multiple devices)模块在底层管理RAID设备，它会在应用层给我们提供一个应用程序的工具mdadm ，mdadm是linux下用于创建和管理软件RAID的命令。</p><h2 id="mdadm命令常见参数解释："><a href="#mdadm命令常见参数解释：" class="headerlink" title="mdadm命令常见参数解释："></a>mdadm命令常见参数解释：</h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>检测设备名称，添加磁盘</td></tr><tr><td>-n</td><td>指定设备数量</td></tr><tr><td>-l</td><td>指定RAID级别</td></tr><tr><td>-C</td><td>创建</td></tr><tr><td>-v</td><td>显示过程</td></tr><tr><td>-f</td><td>模拟设备损坏</td></tr><tr><td>-r</td><td>移除设备</td></tr><tr><td>-Q</td><td>查看摘要信息</td></tr><tr><td>-D</td><td>查看详细信息</td></tr><tr><td>-S</td><td>停止RAID磁盘阵列</td></tr></tbody></table><h2 id="搭建raid10阵列"><a href="#搭建raid10阵列" class="headerlink" title="搭建raid10阵列"></a>搭建raid10阵列</h2><ol><li>新添加4块硬盘——在centos关机的情况下添加4块新的硬盘。</li></ol><pre><code># ls /dev/sd*</code></pre><ol start="2"><li>下载mdadm</li></ol><pre><code># yum install mdadm -y</code></pre><ol start="3"><li>创建RAID10阵列</li></ol><pre><code># mdadm -C -v /dev/md10 -l 10 -n 4 /dev/sd&#123;b,c,d,e&#125;</code></pre><p>这里的选项是多个，对照上表查看。磁盘阵列名需要以md开头，这里创建的是md10。</p><ol start="4"><li>查看阵列信息</li></ol><pre><code># mdadm -D /dev/md10</code></pre><ol start="5"><li>格式化</li></ol><pre><code># mkfs.xfs /dev/md10</code></pre><ol start="6"><li>挂载使用</li></ol><pre><code># mount /dev/md10 /ken</code></pre><ol start="7"><li>写入到文件</li></ol><p>方法一、</p><pre><code># echo “mount /dev/md10 /ken” &gt;&gt; /etc/rc.local</code></pre><p>方法二、</p><pre><code># echo “/dev/md10 /ken xfs defaults 0 0 ” &gt;&gt; /etc/fstab</code></pre><h2 id="mdadm管理RAID10阵列–模拟磁盘损坏后的处理方式"><a href="#mdadm管理RAID10阵列–模拟磁盘损坏后的处理方式" class="headerlink" title="mdadm管理RAID10阵列–模拟磁盘损坏后的处理方式"></a>mdadm管理RAID10阵列–模拟磁盘损坏后的处理方式</h2><ol><li>模拟损坏磁盘</li></ol><pre><code># mdadm /dev/md10 -f /dev/sdd</code></pre><p>选项f是用于模拟磁盘损坏。</p><pre><code># mdadm -D /dev/md10</code></pre><p>查看详细信息，这时候已经显示磁盘损坏了。</p><ol start="2"><li><p>重启</p></li><li><p>添加磁盘</p></li></ol><pre><code># mdadm /dev/md10 -a /dev/sdd</code></pre><p>选项a是用于添加磁盘。</p><pre><code># mdadm -D /dev/md10</code></pre><p>添加成功，然后照常使用。</p><h2 id="mdadm创建RAID阵列–RAID5-热备盘"><a href="#mdadm创建RAID阵列–RAID5-热备盘" class="headerlink" title="mdadm创建RAID阵列–RAID5+热备盘"></a>mdadm创建RAID阵列–RAID5+热备盘</h2><ol><li>添加四块磁盘并查看。</li></ol><pre><code># ls /dev/sd*</code></pre><ol start="2"><li>创建磁盘阵列RAID5</li></ol><pre><code># mdadm -C /dev/md5 -l 5 -n 3 -x 1 /dev/sd&#123;b,c,d,e&#125;</code></pre><ol start="3"><li>查看阵列信息</li></ol><pre><code># mdadm -D /dev/md5</code></pre><ol start="4"><li>格式化</li></ol><pre><code># mkfs.xfs /dev/md5</code></pre><ol start="5"><li>挂载</li></ol><pre><code># mkdir /ken# mount /dev/md5 /ken</code></pre><ol start="6"><li>补充</li></ol><p>在使用mdadm命令创建RAID阵列时，需要先将磁盘分区并格式化，然后再将分区设备加入到RAID阵列中。如果RAID阵列中的磁盘出现故障，可以使用mdadm命令进行磁盘的移除和添加，以及磁盘阵列的重建。</p><p>在创建RAID阵列时，需要注意以下几点：</p><ol><li><p>磁盘数量必须是偶数，且至少需要两个磁盘。</p></li><li><p>磁盘容量应该相同，否则会浪费磁盘空间。</p></li><li><p>RAID级别的选择应该根据实际需求进行，不同的RAID级别有不同的优缺点。</p></li><li><p>在创建RAID阵列时，可以使用-x选项指</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT使用</title>
      <link href="/36c4f4bb.html"/>
      <url>/36c4f4bb.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、获取openAI-的key"><a href="#一、获取openAI-的key" class="headerlink" title="一、获取openAI 的key"></a><strong>一、获取openAI 的key</strong></h1><h2 id="1-关注公众号"><a href="#1-关注公众号" class="headerlink" title="1.关注公众号"></a>1.关注公众号</h2><p><img src="/../images/pwxgz.jpg" alt="微信公众号"></p><h2 id="2-输入关键字获取key"><a href="#2-输入关键字获取key" class="headerlink" title="2.输入关键字获取key"></a>2.输入关键字获取key</h2><p>​在消息输入框回复关键词“小张我需要ChatGPT的key”</p><p><img src="/../images/getkey.png" alt="获取密钥"></p><h1 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a><strong>二、使用方法</strong></h1><p>​点击设置里面填充openAI key</p><p><img src="/../images/openkey.jpg" alt="打开密钥.jpg"></p><h1 id="三、测试结果"><a href="#三、测试结果" class="headerlink" title="三、测试结果"></a><strong>三、测试结果</strong></h1><p>再测点击设置，在对话框里面输入“你好”，有正常返回结果就可以了。</p><p><img src="/../images/hi.jpg" alt="嗨.jpg"></p><h1 id="四、网站使用方法"><a href="#四、网站使用方法" class="headerlink" title="四、网站使用方法"></a><strong>四、网站使用方法</strong></h1><h2 id="1-设置选项介绍"><a href="#1-设置选项介绍" class="headerlink" title="1.设置选项介绍"></a>1.设置选项介绍</h2><ul><li>OpenAI API Key:  填写openAI的秘钥</li><li>系统角色指令：发送系统指令的类型，可以不用填写</li><li>思维发散程度： 根据自己需求自行调整</li><li>记录对话内容，刷新不会消失： 保留会话记录</li><li>开启连续对话，将加倍消耗Token: 作用是做到上下文内容联系</li></ul><p><img src="/../images/seting.jpg" alt="设置.jpg"></p><h2 id="2-使用存在的问题介绍"><a href="#2-使用存在的问题介绍" class="headerlink" title="2.使用存在的问题介绍"></a>2.使用存在的问题介绍</h2><ul><li>常见网站错误如下，解决办法刷新网页</li></ul><p>​TypeError: Failed to fetch<br>​error</p><ul><li>对话数据不要太长，网页上下文联系错误长出现error错误，需要刷新网页</li></ul>]]></content>
      
      
      <categories>
          
          <category> AI话题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老陕小张的技能介绍</title>
      <link href="/7d4ff147.html"/>
      <url>/7d4ff147.html</url>
      
        <content type="html"><![CDATA[<h1 id="老陕小张"><a href="#老陕小张" class="headerlink" title="老陕小张"></a>老陕小张</h1><p>我们是一家专注于部署服务器软件、网络环境、企业官网编写以及Linux和Windows系统优化的组织。我们的团队由一群技术精湛、经验丰富的IT专家组成，致力于为客户提供高质量的技术服务。</p><h2 id="服务范围"><a href="#服务范围" class="headerlink" title="服务范围"></a>服务范围</h2><p>我们的服务范围涵盖了各种企业级软件的部署和优化，包括但不限于Web服务器、数据库服务器、邮件服务器、虚拟化平台等。我们还提供网络环境的规划和部署，确保客户的网络安全和稳定性。此外，我们还拥有一支专业的网站开发团队，能够为客户提供高质量的企业官网设计和开发服务。</p><h2 id="技术团队"><a href="#技术团队" class="headerlink" title="技术团队"></a>技术团队</h2><p>我们的技术团队拥有丰富的Linux和Windows系统优化经验，能够为客户提供系统性能优化、安全加固、容灾备份等服务，确保客户的系统运行稳定、高效、安全。我们的目标是为客户提供最优质的技术服务，帮助客户提高业务效率，降低IT成本，让客户在激烈的市场竞争中获得更大的优势。我们相信，通过我们的专业技术和贴心服务，我们能够成为客户信赖的长期合作伙伴。</p><h2 id="网络优化和部署"><a href="#网络优化和部署" class="headerlink" title="网络优化和部署"></a>网络优化和部署</h2><p>我们的网络优化主要是针对家庭网络和中小型企业。我们的专业团队能够为客户提供网络性能优化、网络安全加固、网络拓扑规划等服务，确保客户的网络稳定、高效、安全。我们还能够为客户提供网络部署服务，包括网络设备的选型、配置、安装和调试，确保客户的网络环境能够满足业务需求。我们的目标是为客户提供全方位的网络服务，让客户的网络环境更加稳定、高效、安全。</p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h2><p>总之，我们的团队致力于为客户提供最优质的技术服务，让客户在激烈的市场竞争中获得更大的优势。如果您需要我们的服务，请随时联系我们，我们将竭诚为您服务。<br><img src="/../images/pwx.png" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> 关于我们 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关于我们 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="//404.html"/>
      <url>//404.html</url>
      
        <content type="html"><![CDATA[<h1 id="抱歉，页面未找到"><a href="#抱歉，页面未找到" class="headerlink" title="抱歉，页面未找到"></a>抱歉，页面未找到</h1><p>很抱歉，您所访问的页面不存在或已被删除。</p><p>请检查您输入的网址是否正确，或者返回<a href="/">主页</a>继续浏览其他内容。</p><p>如果您认为这是一个错误，请联系我们的网站管理员进行处理。</p><p>谢谢您的访问！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
