<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python堆栈和队列</title>
      <link href="/143ac943.html"/>
      <url>/143ac943.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-队列Queue"><a href="#1-队列Queue" class="headerlink" title="1.队列Queue"></a>1.队列Queue</h2><p>1.FIFO (first in frst out先进先出)</p><p>2.可以存储不同的数据类型，例如整数、字符串、字典</p><p>3.使用put放数据</p><p>4.使用get取数据 (如果当前队列中没有数据，此时会堵塞)</p><h2 id="2-堆栈Queue"><a href="#2-堆栈Queue" class="headerlink" title="2.堆栈Queue"></a>2.堆栈Queue</h2><p>1.LIFO(last in first out后进先出)</p><p>2.可以存储不同的数据类型，例如整数、字符串、字典</p><p>3.使用put放数据</p><p>4.使用get取数据(如果当前队列中没有数据，此时会堵塞)</p><h2 id="3-优先圾Queue"><a href="#3-优先圾Queue" class="headerlink" title="3.优先圾Queue"></a>3.优先圾Queue</h2><p>1.根据优先级来确定当前要获取的数据</p><p>2.使用put存放</p><ol><li>将一个元组放到里面</li><li>第1个元素是:优先级，数字小优先级越高</li><li>第2个元素是:要存放的据</li></ol><p>3.使用get来获取 (如果当前队列中没有数据，此时会堵塞</p>]]></content>
      
      
      <categories>
          
          <category> 编程教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作纯净PE</title>
      <link href="/d391b6d2.html"/>
      <url>/d391b6d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、软硬件准备"><a href="#一、软硬件准备" class="headerlink" title="一、软硬件准备"></a>一、软硬件准备</h2><table><thead><tr><th>硬件</th><th>U盘不低于8G，一定要提前备份U盘文件</th></tr></thead><tbody><tr><td>软件</td><td><a href="https://mirrors.sdu.edu.cn/software/Windows/WePE/WePE_64_V2.3.exe">https://mirrors.sdu.edu.cn/software/Windows/WePE/WePE_64_V2.3.exe</a></td></tr></tbody></table><h2 id="二、制作PE操作"><a href="#二、制作PE操作" class="headerlink" title="二、制作PE操作"></a>二、制作PE操作</h2><p>1.双击打开PE软件</p><p><img src="/../images/peexe%E5%8F%8C%E5%87%BB.png"></p><p>2.选择U盘安装PE</p><p><img src="/../images/U%E7%9B%98%E9%80%89%E9%A1%B9.png"></p><p>3.选项说明</p><p><img src="/../images/%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E.png"></p><p>4.确人制作PE驱动盘</p><p><img src="/../images/startcreatepe.png"></p><p>5.完成PE制作</p><p><img src="/../images/%E5%AE%8C%E6%88%90PE%E5%88%B6%E4%BD%9C.png"></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> window </tag>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Devops从入门到实战</title>
      <link href="/30edc0d5.html"/>
      <url>/30edc0d5.html</url>
      
        <content type="html"><![CDATA[<h2 id="硬件项目配置"><a href="#硬件项目配置" class="headerlink" title="硬件项目配置"></a>硬件项目配置</h2><table><thead><tr><th>服务器名称</th><th>ip</th><th>系统版本</th><th>服务名称</th></tr></thead><tbody><tr><td>gitlab</td><td>192.168.75.100</td><td>Centos7.8 2vcpu4G</td><td>gitlab</td></tr><tr><td>jenkins</td><td>192.168.75.101</td><td>Centos7.8 2vcpu6G</td><td>jenkins、sonarQube、Client</td></tr><tr><td>harbor</td><td>192.168.75.102</td><td>Centos7.8 2vcpu4G</td><td>harbor</td></tr><tr><td>masternode</td><td>192.168.75.103</td><td>Centos7.8 2vcpu4G</td><td>k8s-master</td></tr><tr><td>node1</td><td>192.168.75.104</td><td>Centos7.8 2vcpu4G</td><td>k8s-node</td></tr></tbody></table><h2 id="一、DevOps介绍"><a href="#一、DevOps介绍" class="headerlink" title="一、DevOps介绍"></a>一、DevOps介绍</h2><p>软件开发最开始是由两个团队组成:</p><ul><li>开发计划由开发团队从头开始设计和整体系统的构建。需要系统不停的迭代更新。</li><li>运维团队将开发团队的Code进行测试后部署上线。希望系统稳定安全运行。</li></ul><p>这看似两个目标不同的团队需要协同完成一个软件的开发。</p><p>在开发团队指定好计划并完成coding后，需要提供到运维团队。</p><p>运维团队向开发团队反馈需要修复的BUG以及一些需要返工的任务。</p><p>这时开发团队需要经常等待运维团队的反馈。这无疑延长了事件并推迟了整个软件开发的周期。</p><p>会有一种方式，在开发团队等待的时候，让开发团队转移到下一个项目中。等待运维团队为之前的代码提供反馈。</p><p>可是这样就意味着一个完整的项目需要一个更长的周期才可以开发出最终代码。</p><hr><p>基于现在的互联网现状，更推崇敏捷式开发，这样就导致项目的迭代速度更快，但是由于开发团队与运维团队的沟通问题，会导致新版本上线的时间成本很高。</p><p>这又违背的敏捷式开发的最初的目的。那么如果让开发团队和运维团队整合到成一个团队，协同应对一套软件呢?这就被称DevOps.DevOps，字面意思是Development &amp;Operations的缩写，也就是开发&amp;运维</p><p>虽然字面意思只涉及到开发团队和运维团队，其实QA测试团队也是参与其中的。</p><p>网上可以查看到DevOops的符合类似一个无穷大符合</p><p><img src="/../images/devopspng.png"></p><h2 id="二、Operate阶段工具"><a href="#二、Operate阶段工具" class="headerlink" title="二、Operate阶段工具"></a>二、Operate阶段工具</h2><p>!部署过程，会采用Docker进行部署，暂时只安装Docker即可，后续还需要安装kubenetes</p><h3 id="2-1-Docker-安装"><a href="#2-1-Docker-安装" class="headerlink" title="2.1 Docker 安装"></a>2.1 Docker 安装</h3><ul><li><p>准备测试环境&amp;生产环境</p></li><li><p>下载Docker依赖组件</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum install -y yum-utils \  device-mapper-persistent-data \  lvm2</code></pre></li><li><p>设置下载Docker的镜像源为阿里云</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum-config-manager \    --add-repo \    http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</code></pre></li><li><p>安装Docker服务</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</code></pre></li><li><p>安装成功后，启动Docker并设置开机自启</p><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl start dockersystemctl enable docker</code></pre></li><li><p>测试安装</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@jenkins ~]# docker versionClient: Docker Engine - Community Version:           24.0.4 API version:       1.43 Go version:        go1.20.5 Git commit:        3713ee1 Built:             Fri Jul  7 14:54:21 2023 OS&#x2F;Arch:           linux&#x2F;amd64 Context:           default</code></pre></li></ul><h3 id="2-2-Docker-Compose安装"><a href="#2-2-Docker-Compose安装" class="headerlink" title="2.2 Docker-Compose安装"></a>2.2 Docker-Compose安装</h3><pre class="language-bash" data-language="bash"><code class="language-bash">#访问下载地址https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;tags#根据需要下载相应的版本wget https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;v2.19.1&#x2F;docker-compose-linux-x86_64 #将docker-compose-linux-x86_64 到&#x2F;usr&#x2F;local&#x2F;binmv docker-compose-linux-x86_64 &#x2F;usr&#x2F;local&#x2F;bin#赋予执行取消chmod a+x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose#验证是否安装成功[root@jenkins ~]# docker-compose  versionDocker Compose version v2.19.1</code></pre><h2 id="三、Code阶段工具"><a href="#三、Code阶段工具" class="headerlink" title="三、Code阶段工具"></a>三、Code阶段工具</h2><h3 id="3-1-Git安装"><a href="#3-1-Git安装" class="headerlink" title="3.1 Git安装"></a>3.1 Git安装</h3><ul><li><p>Linux安装</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum install -y git</code></pre></li><li><p>Window安装</p></li></ul><h3 id="3-2-GitLab安装"><a href="#3-2-GitLab安装" class="headerlink" title="3.2 GitLab安装"></a>3.2 GitLab安装</h3><ul><li><p>硬件配置必须大于4G内存</p></li><li><p>拉取GitLab镜像</p><pre class="language-bash" data-language="bash"><code class="language-bash">docker pull gitlab&#x2F;gitlab-ce</code></pre></li><li><p>准备docker-compose.yml</p><pre class="language-bash" data-language="bash"><code class="language-bash">version: &quot;3.1&quot;services:  gitlab:    image: &quot;gitlab&#x2F;gitlab-ce:latest&quot;    restart: always    environment:      GITLAB_OMNIBUS_CONFIG: |        external_url &quot;http:&#x2F;&#x2F;192.168.75.100:8929&quot;        gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] &#x3D; 2224    ports:      - &quot;8929:8929&quot;      - &quot;2224:2224&quot;    volumes:      - &quot;.&#x2F;config:&#x2F;etc&#x2F;gitlab&quot;      - &quot;.&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab&quot;      - &quot;.&#x2F;data:&#x2F;var&#x2F;opt&#x2F;gitlab&quot;</code></pre></li><li><p>启动容器（需要稍微等一下）</p><pre class="language-bash" data-language="bash"><code class="language-bash">docker-compose  up -d</code></pre></li><li><p>打开浏览器访问GitLab首页<a href="http://192.168.75.100:8929/">http://192.168.75.100:8929/</a></p><p><img src="/../images/gitlaburl.png"></p></li><li><p>登录GitLab</p><p>用户：root</p><p>密码在 initial_root_password文件中</p><pre class="language-bash" data-language="bash"><code class="language-bash">cat config&#x2F;initial_root_password</code></pre></li><li><p>创建新项目在gitlab中</p></li></ul><p><img src="/../images/jsgitnew.png"></p><p><img src="/../images/jsnew1.png"></p><p><img src="/../images/jsnew2.png"></p><ul><li>将源代码上传到gitlab中，我这里使用window中git工具</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">#进入项目代码文件夹cd demoHello#初始化git仓库git init#添加文件git add .#提交到本地git commit -m &quot;代码v1&quot;#配置远端仓库,点击gitlab项目中的clone查找项目仓库地址git remote add origin http:&#x2F;&#x2F;192.168.75.100:8929&#x2F;root&#x2F;demoHello.git#push到远程仓库某分支，完成代码上传git push -u origin &quot;master&quot;</code></pre><ul><li>查看代码上传结果</li></ul><p><img src="/../images/okgit.png"></p><h2 id="四、Build阶段工具"><a href="#四、Build阶段工具" class="headerlink" title="四、Build阶段工具"></a>四、Build阶段工具</h2><p>构建Java项目的工具一般有二种选择，一个是Maven,一个是Gradle。</p><p>这里我们选择Maven作为项目的编译工具。</p><p>具体安装Maven流程不做阐述，但是需要确保配置好Maven仓库以及JDK编译版本。</p><h2 id="五、Integrate工具"><a href="#五、Integrate工具" class="headerlink" title="五、Integrate工具"></a>五、Integrate工具</h2><p>持续集成、持续部署CI、CD的工具很多，其中Jenkins是一个开源的持续集成平台Jenkins涉及到将编写完毕的代码发布到测试环境和生产环境的任务，并且还涉及到了构建项目等任务。<br>Jenkins需要大量的插件保证工作，安装成本较高，下面会基于Docker搭建Jenkins。</p><h3 id="5-1-Jenkins介绍"><a href="#5-1-Jenkins介绍" class="headerlink" title="5.1 Jenkins介绍"></a>5.1 Jenkins介绍</h3><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具Jenkins应用广泛，大多数互联网公司都采用Jenkins配合GitLab、Docker、K8s作为实现DevOps的核心工具.Jenkins最强大的就在于插件，Jenkins官方提供了大量的插件库，来自动化CI&#x2F;CD过程中的各种琐碎功能。</p><p>Jenkins最主要的工作就是将GitLab上可以构建的工程代码拉取并且进行构建，再根据流程可以选择发布到测试环境或是生产环境。</p><p>一般是GitLab上的代码经过大量的测试后，确定发行版本，再发布到生产环境。</p><p><img src="/../images/jenkins.png"></p><p>CI&#x2F;CD可以理解为:</p><ul><li><p>CI过程即是通过Jenkins将代码拉取、构建、制作镜像交给测试人员测试。</p><p>1.持续集成:让软件代码可以持续的集成到主干上，并自动构建和测试。</p></li><li><p>CD过程即是通过Jenkins将打好标签的发行版本代码拉取、构建、制作镜像交给运维人员部署</p><p>1.持续交付:让经过持续集成的代码可以进行手动部署。</p><p>2.持续部署:让可以持续交付的代码随时随地的自动化部署。</p><p><img src="/../images/CICD.png"></p></li></ul><h3 id="5-2-Jenkins安装"><a href="#5-2-Jenkins安装" class="headerlink" title="5.2 Jenkins安装"></a>5.2 Jenkins安装</h3><ul><li>了解一下jenkins官网是jenkins.io</li><li>拉取Jenkins镜像</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">docker pull jenkins&#x2F;jenkins:2.413-jdk11</code></pre><ul><li>编写docker-compose.yml</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">version: &quot;3.1&quot;services:  jenkins:    image: jenkins&#x2F;jenkins:2.413-jdk11    container_name: jenkins    ports:      - 8080:8080      - 50000:50000    volumes:      - .&#x2F;data&#x2F;:&#x2F;var&#x2F;jenkins_home&#x2F;</code></pre><ul><li>启动Jenkins容器</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">[root@jenkins ~]# docker-compose  up -d</code></pre><ul><li>日志报错修改</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"># 查看日志[root@jenkins ~]# docker logs -f  jenkinstouch: cannot touch &#39;&#x2F;var&#x2F;jenkins_home&#x2F;copy_reference_file.log&#39;: Permission deniedCan not write to &#x2F;var&#x2F;jenkins_home&#x2F;copy_reference_file.log. Wrong volume permissions?# 修改bug[root@jenkins ~]# chmod -R  777 data&#x2F;# 重新启动容器[root@jenkins ~]# docker-compose  restart[+] Restarting 1&#x2F;1 ✔ Container jenkins  Started # 查看日志，如果显示密码，则服务正常[root@jenkins ~]# docker logs -f  jenkins</code></pre><ul><li><p>访问Jenkins服务在浏览器<a href="http://192.168.75.101:8080/">http://192.168.75.101:8080</a><br><img src="/../images/jenkinsurl.png"></p></li><li><p>重新启动Jenkins容器后，由于Jenkins需要下载大量内容，但是由于默认下载地址下载速度较慢，需要重新设置下载地址为国内镜像站</p></li><li><p>解锁Jenkins,查看Jenkins密码,并把命名填充</p></li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">[root@jenkins ~]# cat data&#x2F;secrets&#x2F;initialAdminPassword98ff1758a1c34e6aad615361b9975317</code></pre><ul><li>插件安装教学，选择插件来安装，最后选择安装，耐心等待，有可能安装失败，可以点击“继续”，可以进入Jenkins官网进行插件下载</li></ul><p><img src="/../images/jsan.png"></p><ul><li>创建管理员名，并选择默认访问路径</li></ul><p><img src="/../images/mg.png"></p><ul><li>安装完成，来到Jenkins管理界面</li></ul><p><img src="/../images/alerjs.png"></p><ul><li>安装本实验需要的插件，点击Manage Jenkins&#x2F;插件管理&#x2F;可选插件，依次安装本实验需要的基础插件git parameter，Publish Over SSH</li></ul><p><img src="/../images/jsdl.png"></p><h3 id="5-3-Jenkins-入门配置"><a href="#5-3-Jenkins-入门配置" class="headerlink" title="5.3 Jenkins 入门配置"></a>5.3 Jenkins 入门配置</h3><h4 id="5-3-1-配置Maven-构建代码"><a href="#5-3-1-配置Maven-构建代码" class="headerlink" title="5.3.1 配置Maven 构建代码"></a>5.3.1 配置Maven 构建代码</h4><ul><li>安装jdk</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">#jdk文件下载官网https:&#x2F;&#x2F;www.oracle.com&#x2F;java&#x2F;technologies&#x2F;downloads&#x2F;#下载版本jdk-8u141-linux-x64.tar.gz</code></pre><pre class="language-bash" data-language="bash"><code class="language-bash">tar -xvf jdk-8u141-linux-x64.tar.gz  -C &#x2F;usr&#x2F;local&#x2F; #解压文件</code></pre><ul><li>安装Maven</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">#Maven文件下载官网https:&#x2F;&#x2F;maven.apache.org&#x2F;download.cgi#下载版本apache-maven-3.5.4.zip</code></pre><pre class="language-bash" data-language="bash"><code class="language-bash">unzip apache-maven-3.5.4.zipmv apache-maven-3.5.4 &#x2F;usr&#x2F;local&#x2F;maven  #解压文件</code></pre><ul><li>配置maven国内源</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">vim &#x2F;usr&#x2F;local&#x2F;maven&#x2F;conf&#x2F;settings.xml#159行添加国内源配置    &lt;mirror&gt;       &lt;id&gt;alimaven&lt;&#x2F;id&gt;       &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;       &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;       &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;     &lt;&#x2F;mirror&gt;     &lt;&#x2F;mirrors&gt;</code></pre><ul><li>配置jdk编译选项</li></ul><pre class="language-none"><code class="language-none">vim &#x2F;usr&#x2F;local&#x2F;maven&#x2F;conf&#x2F;settings.xml# maven 默认使用 jdk1.8 版本，找到&lt;profiles&gt;标签，往其中添加：#253行添加&lt;profile&gt;    &lt;id&gt;jdk8&lt;&#x2F;id&gt;    &lt;activation&gt;        &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;        &lt;jdk&gt;1.8&lt;&#x2F;jdk&gt;    &lt;&#x2F;activation&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;        &lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt;    &lt;&#x2F;properties&gt;&lt;&#x2F;profile&gt;</code></pre><ul><li>启动jdk8</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">vim &#x2F;usr&#x2F;local&#x2F;maven&#x2F;conf&#x2F;settings.xml# 275行处添加  &lt;activeProfiles&gt;     &lt;activeProfile&gt;jdk8&lt;&#x2F;activeProfile&gt;  &lt;&#x2F;activeProfiles&gt;</code></pre><ul><li>将配置好的jdk和Maven配置到jenkins环境中</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">[root@jenkins ~]# mv &#x2F;usr&#x2F;local&#x2F;jdk&#x2F; data&#x2F;[root@jenkins ~]# mv &#x2F;usr&#x2F;local&#x2F;maven&#x2F; data&#x2F;[root@jenkins ~]# chmod -R  777 data&#x2F;</code></pre><ul><li>在jenkins全局配置中配置jdk和maven的环境</li></ul><p><img src="/../images/jsjdk.png"></p><p><img src="/../images/jsmvn.png"></p><h4 id="5-3-2配置Publish-发布-amp-远程操作"><a href="#5-3-2配置Publish-发布-amp-远程操作" class="headerlink" title="5.3.2配置Publish 发布&amp;远程操作"></a>5.3.2配置Publish 发布&amp;远程操作</h4><p>在系统管理中添加SSH servers配置</p><p><img src="/../images/jsssh.png"></p><p><img src="/../images/jsssh2.png"></p><h2 id="六、CI、CD入门操作"><a href="#六、CI、CD入门操作" class="headerlink" title="六、CI、CD入门操作"></a>六、CI、CD入门操作</h2><h3 id="6-1-持续集成"><a href="#6-1-持续集成" class="headerlink" title="6.1 持续集成"></a>6.1 持续集成</h3><h4 id="6-1-1-构建任务"><a href="#6-1-1-构建任务" class="headerlink" title="6.1.1 构建任务"></a>6.1.1 构建任务</h4><ul><li>选择项目任务</li></ul><p><img src="/../images/jsrw.png"></p><ul><li>配置git拉取仓库地址保存项目</li></ul><p><img src="/../images/%E9%85%8D%E7%BD%AEgit%E4%BB%93%E5%BA%93.png"></p><ul><li><p>执行构建任务并检查空调输出构建内容</p><p><img src="/../images/%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C.png"></p></li></ul><p><img src="/../images/%E6%9E%84%E5%BB%BA%E5%86%85%E5%AE%B9%E8%BE%93%E5%87%BA.png"></p><ul><li>服务器查看git clone 的代码</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">#内容存在，证明任务正确,也可以看执行任务的图标[root@jenkins ~]# ls data&#x2F;workspace&#x2F;demoHello&#x2F;demoHello.iml  pom.xml  src</code></pre><ul><li>配置mave打包Jar包</li></ul><p><img src="/../images/mave%E6%89%93%E5%8C%85.png"></p><ul><li>重新构建任务，并验证打包结果，这次任务构建时间比较长，需要等待一下</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">#查看打包任务[root@jenkins ~]# ls  data&#x2F;workspace&#x2F;demoHello&#x2F;target&#x2F;classes  demoHello-0.0.1.jar  demoHello-0.0.1.jar.original  generated-sources  generated-test-sources  maven-archiver  maven-status  test-classes</code></pre><ul><li>配置将生成的Jar包放到目标服务器上，并构建环境</li></ul><p><img src="/../images/%E5%B0%86jar%E5%A4%8D%E5%88%B6%E5%88%B0%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A.png"></p><ul><li>查看工具中Jar包</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">[root@jenkins ~]# ls &#x2F;usr&#x2F;local&#x2F;test&#x2F;target&#x2F;demoHello-0.0.1.jar</code></pre><p>准备Docker构建环境</p><pre class="language-bash" data-language="bash"><code class="language-bash">#docker文件夹结构$ ls docker&#x2F;Dockerfile  docker-compose.yml#文件DockerfileFROM daocloud.io&#x2F;library&#x2F;java:8u40-jdkCOPY demoHello-0.0.1.jar &#x2F;usr&#x2F;localWORKDIR &#x2F;usr&#x2F;localCMD java -jar demoHello-0.0.1.jar#docker-compose.ymlversion: &quot;3.1&quot;services:  demohello:    build:      context: .&#x2F;      dockerfile: Dockerfile    image: demohello:v1.0.0    container_name: demohello    ports:      - 8081:8081#修改pox.xml    &lt;build&gt;    &lt;finalName&gt;demoHello&lt;&#x2F;finalName&gt; #增加内容，代表项目名称        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;            &lt;&#x2F;plugin&gt;        &lt;&#x2F;plugins&gt;    &lt;&#x2F;build&gt;</code></pre><ul><li>将项目代码更新gitlab上</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">$ git add .$ git commit -m &quot;docker&quot;$ git push</code></pre><ul><li><p>构建配置环境</p><p><img src="/../images/%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AEsshserver.png"></p></li><li><p>构建新的任务，并查看结果</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@jenkins ~]# docker  psCONTAINER ID   IMAGE                         COMMAND                  CREATED          STATUS          PORTS                                                                                      NAMESc01978f0cd8c   demohello:v1.0.0              &quot;&#x2F;bin&#x2F;sh -c &#39;java -j…&quot;   56 seconds ago   Up 56 seconds   0.0.0.0:8081-&gt;8081&#x2F;tcp, :::8081-&gt;8081&#x2F;tcp                                                  demohello[root@jenkins ~]# docker imagesREPOSITORY                 TAG           IMAGE ID       CREATED          SIZEdemohello                  v1.0.0        478867d8574e   52 minutes ago   846MB#可以通过Linux命令访问部署任务，也可以通过浏览器访问[root@jenkins docker]# curl  http:&#x2F;&#x2F;192.168.75.101:8081&#x2F;helloHello World v1.0.1</code></pre></li></ul><h3 id="6-2-持续交付、部署"><a href="#6-2-持续交付、部署" class="headerlink" title="6.2 持续交付、部署"></a>6.2 持续交付、部署</h3><h4 id="6-2-1-通过标签控制版本信息"><a href="#6-2-1-通过标签控制版本信息" class="headerlink" title="6.2.1  通过标签控制版本信息"></a>6.2.1  通过标签控制版本信息</h4><ul><li><p>配置构建环境</p><p><img src="/../images/%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AEtag.png"></p></li></ul><p><img src="/../images/%E6%9B%BF%E6%8D%A2%E5%88%86%E6%94%AF.png"></p><ul><li>配置gitlab中的tag,首先给目前版本创建tag为v1</li></ul><p><img src="/../images/gitcreatetag.png"></p><p><img src="/../images/v1create.png"></p><ul><li>更新代码并提交代码修增加tag为v2可以参考上面教程，提交代码和给代码提交版本</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">#修改docker-compose.yml    image: demohello:v2.0.0#修改src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;demohello&#x2F;controller&#x2F;HelloController.java public String helloWorld() &#123;        return &quot;Hello World v2.0.0&quot;;    &#125;</code></pre><ul><li><p>可以看到构建按钮可以动态选择</p><p><img src="/../images/tag%E6%9E%84%E5%BB%BA%E5%8F%98%E5%8C%96.png"></p></li><li><p>执行构建任务并检查结果</p></li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">[root@jenkins docker]# docker imagesREPOSITORY                 TAG           IMAGE ID       CREATED          SIZEdemohello                  v2.0.0        a5158a6c4e1f   22 minutes ago   846MBdemohello                  v1.0.0        9a623fcc1385   23 minutes ago   846MB[root@jenkins docker]# docker psCONTAINER ID   IMAGE                         COMMAND                  CREATED          STATUS          PORTS                                                                                      NAMES014179370a24   demohello:v2.0.0              &quot;&#x2F;bin&#x2F;sh -c &#39;java -j…&quot;   22 minutes ago   Up 22 minutes   0.0.0.0:8081-&gt;8081&#x2F;tcp, :::8081-&gt;8081&#x2F;tcp                                                  demohello[root@jenkins docker]# curl  http:&#x2F;&#x2F;192.168.75.101:8081&#x2F;helloHello World v2.0.0</code></pre><h2 id="七、集成Sonar-Qube"><a href="#七、集成Sonar-Qube" class="headerlink" title="七、集成Sonar Qube"></a>七、集成Sonar Qube</h2><h3 id="7-1-sonarQube-介绍"><a href="#7-1-sonarQube-介绍" class="headerlink" title="7.1 sonarQube 介绍"></a>7.1 sonarQube 介绍</h3><p>SonarQube是一个开源的代码质量管理平台，旨在帮助开发团队提高代码的可靠性、可维护性和可扩展性。它提供了一系列的静态代码分析工具，能够自动检测代码中的潜在问题和缺陷，比如代码冗余、代码复杂度、潜在的安全漏洞等。</p><p>SonarQube不仅可以对多种编程语言进行分析，如Java、C#、C++、Python等，还支持与各种构建工具和持续集成平台集成，如Maven、Jenkins等。通过在代码开发过程中集成SonarQube，团队可以及早发现和修复潜在的问题，从而提高代码质量和开发效率。</p><p>除了代码分析功能，SonarQube还提供了可视化的仪表板和报告，帮助开发团队监控代码质量的趋势和改进的进展。它还支持规则定制和自定义，可以根据团队或项目的特定需求进行配置和扩展。</p><p>总的来说，SonarQube是一个功能强大、易于使用的工具，可以帮助开发团队不断提升代码质量，并促进持续的项目成功。</p><h3 id="7-2-sonarQube-环境搭建"><a href="#7-2-sonarQube-环境搭建" class="headerlink" title="7.2 sonarQube 环境搭建"></a>7.2 sonarQube 环境搭建</h3><h3 id="7-2-1-sonarQube-安装"><a href="#7-2-1-sonarQube-安装" class="headerlink" title="7.2.1 sonarQube 安装"></a>7.2.1 sonarQube 安装</h3><ul><li>通过docker-compose搭建sonarQube</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">version: &quot;3.1&quot;services:  db:    image: postgres    container_name: db    ports:      - 5432:5432    networks:      - sonarnet    environment:      POSTGRES_USER: sonar      POSTGRES_PASSWORD: sonar  sonarqube:    image: sonarqube:lts-community    container_name: sonarqube    depends_on:      - db    ports:      - 9000:9000    networks:      - sonarnet    environment:      SONAR_JDBC_URL: jdbc:postgresql:&#x2F;&#x2F;db:5432&#x2F;sonar      SONAR_JDBC_USERNAME: sonar      SONAR_JDBC_PASSWORD: sonarnetworks:  sonarnet:    driver: bridge</code></pre><ul><li>当执行docker-compose启动命令，看到sonarQube无法正常启动，修改bug的方法</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">#查看sonarQube无法启动是否这个原因[root@jenkins sonarqube_docker]# docker ps -aCONTAINER ID   IMAGE                         COMMAND                  CREATED          STATUS                     PORTS                                                                                      NAMES6e0930750723   sonarqube:lts-community       &quot;bin&#x2F;run.sh bin&#x2F;sona…&quot;   2 minutes ago    Exited (0) 2 minutes ago[root@jenkins sonarqube_docker]# docker restart 6e0930750723 |docker logs -f 6e0930750723ERROR: [1] bootstrap checks failed. You must address the points described in the following [1] lines before starting Elasticsearch.bootstrap check failure [1] of [1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]ERROR: Elasticsearch did not exit normally - check the logs at &#x2F;opt&#x2F;sonarqube&#x2F;logs&#x2F;sonarqube.log#修改bug,在&#x2F;etc&#x2F;sysctl.conf参加vm.max_map_count&#x3D;262144配置[root@jenkins sonarqube_docker]# vim &#x2F;etc&#x2F;sysctl.confvm.max_map_count&#x3D;262144#使配置生效[root@jenkins sonarqube_docker]# sysctl -pvm.max_map_count &#x3D; 262144#重新启动sonarqube服务器，需要再sonarqube_docker目录[root@jenkins sonarqube_docker]# docker-compose  restart</code></pre><ul><li>访问<a href="http://192.168.75.101:9000网址，登陆">http://192.168.75.101:9000网址，登陆</a> sonarQube服务,初始化用户名和密码都是admin，服务器启动需要时间，需要耐心等待一会</li></ul><p><img src="/../images/sqok.png"></p><ul><li><p>sonarQube服务汉化，需要安装汉化插件</p><p><img src="/../images/sonch.png"></p></li><li><p>安装插件需要重新启动服务，需要耐心等待一会</p><p><img src="/../images/restartsq.png"></p></li></ul><h3 id="7-2-2-sonarQube-使用"><a href="#7-2-2-sonarQube-使用" class="headerlink" title="7.2.2 sonarQube 使用"></a>7.2.2 sonarQube 使用</h3><h4 id="7-2-2-1-mave本地使用sonarQube服务"><a href="#7-2-2-1-mave本地使用sonarQube服务" class="headerlink" title="7.2.2.1 mave本地使用sonarQube服务"></a>7.2.2.1 mave本地使用sonarQube服务</h4><ul><li>可以通过配置maven，使用sonarQube</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">#在settings.xml配置和配置jdk的位置一样&lt;profile&gt;    &lt;id&gt;sonar&lt;&#x2F;id&gt;    &lt;activation&gt;        &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;    &lt;&#x2F;activation&gt;    &lt;properties&gt;      &lt;sonar.login&gt;admin&lt;&#x2F;sonar.login&gt;      &lt;sonar.password&gt;123456789&lt;&#x2F;sonar.password&gt;      &lt;sonar.host.url&gt;http:&#x2F;&#x2F;192.168.75.101:9000&lt;&#x2F;sonar.host.url&gt;    &lt;&#x2F;properties&gt;&lt;&#x2F;profile&gt;     &lt;activeProfile&gt;sonar&lt;&#x2F;activeProfile&gt;</code></pre><ul><li>在idea的终端输入命令</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">mvn sonar:sonar</code></pre><ul><li>登陆sonarQube查看结果内容</li></ul><p><img src="/../images/resq.png"></p><h4 id="7-2-2-2-sonar-scanner使用sonarQube服务"><a href="#7-2-2-2-sonar-scanner使用sonarQube服务" class="headerlink" title="7.2.2.2 sonar-scanner使用sonarQube服务"></a>7.2.2.2 sonar-scanner使用sonarQube服务</h4><ul><li>下载sonar-scanner直接在百度搜索，获取下载地址：<a href="https://docs.sonarsource.com/sonarqube/latest/analyzing-source-code/scanners/sonarscanner/">https://docs.sonarsource.com/sonarqube/latest/analyzing-source-code/scanners/sonarscanner/</a></li></ul><p><img src="/../images/scdl.png"></p><ul><li>将sonar-scanner压缩包解压，并配置环境</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">#解压[root@jenkins ~]# unzip sonar-scanner-cli-4.8.0.2856-linux.zip#配置环境[root@jenkins ~]# mv sonar-scanner-cli-4.8.0.2856-linux .&#x2F;data&#x2F;sonar-scanner#配置sonar-scanner使用sonarQube的文件[root@jenkins ~]# vim data&#x2F;sonar-scanner&#x2F;conf&#x2F;sonar-scanner.propertiessonar.host.url&#x3D;http:&#x2F;&#x2F;192.168.75.101:9000sonar.sourceEncoding&#x3D;UTF-8</code></pre><ul><li>由于sonar-scanner连接sonarQube服务需要秘钥或者用户账号，为了后面的持续集成，我们需要用sonarQube生成一个秘钥给sonar-scanner用</li></ul><p><img src="/../images/%E7%94%9F%E6%88%90%E7%AD%BE%E5%90%8D.png"></p><ul><li>验证sonar-scanner使用sonarQube服务</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">[root@jenkins ~]# cd data&#x2F;workspace&#x2F;demoHello&#x2F;[root@jenkins demoHello]# &#x2F;root&#x2F;data&#x2F;sonar-scanner&#x2F;bin&#x2F;sonar-scanner -Dsoanr.sources&#x3D;.&#x2F; -Dsonar.projectname&#x3D;demoHello -Dsonar.login&#x3D;a0277c64b7c5f6c1e03700fdd9f881eb48c98633 -Dsonar.projectKey&#x3D;demoHello -Dsonar.java.binaries&#x3D;.&#x2F;target&#x2F;……………………INFO: ------------------------------------------------------------------------INFO: EXECUTION SUCCESSINFO: ------------------------------------------------------------------------INFO: Total time: 7.968sINFO: Final Memory: 17M&#x2F;60MINFO: ------------------------------------------------------------------------#删除测试生成目录，方便后续为构建jenkins任务排除bug[root@jenkins demoHello]# rm -fr .scannerwork&#x2F;</code></pre><h4 id="7-2-2-3-Jenkins使用-sonar-scanner配置"><a href="#7-2-2-3-Jenkins使用-sonar-scanner配置" class="headerlink" title="7.2.2.3 Jenkins使用 sonar-scanner配置"></a>7.2.2.3 Jenkins使用 sonar-scanner配置</h4><ul><li>需要给Jenkins安装sonarQube插件，我下面的图片是安装好的</li></ul><p><img src="/../images/%E5%AE%89%E8%A3%85sq%E6%8F%92%E4%BB%B6.png"></p><ul><li>配置sonarQube系统环境</li></ul><p><img src="/../images/%E7%A7%98%E9%92%A5%E9%85%8D%E7%BD%AE.png"></p><p><img src="/../images/%E5%A1%AB%E5%86%99%E7%A7%98%E9%92%A5.png"></p><ul><li><p>安装sonar-scanner</p><p><img src="/../images/sonar-scanner%E5%AE%89%E8%A3%85.png" alt=" "></p></li><li><p>7.2.2.4  任务使用 sonar-scanner配置</p></li></ul><p><img src="/../images/%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AEsq.png"></p><ul><li>执行任务并验证sonar-scanner</li></ul><p><img src="/../images/checksq.png"></p><p><img src="/../images/sqsee.png"></p><h2 id="八、集成harbor"><a href="#八、集成harbor" class="headerlink" title="八、集成harbor"></a>八、集成harbor</h2><h3 id="8-1-安装harbor"><a href="#8-1-安装harbor" class="headerlink" title="8.1 安装harbor"></a>8.1 安装harbor</h3><ul><li><p>下载harbor安装包,在github网站上搜索harbor，回去下载链接</p><pre class="language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;github.com&#x2F;goharbor&#x2F;harbor&#x2F;releases&#x2F;download&#x2F;v2.8.2&#x2F;harbor-offline-installer-v2.8.2.tgz</code></pre></li><li><p>修改harbor配置文件</p><pre class="language-bash" data-language="bash"><code class="language-bash">#解压harbortar -xvf harbor-offline-installer-v2.8.2.tgz -C &#x2F;usr&#x2F;local#进入harbor目录修改配置文件cd  &#x2F;usr&#x2F;local&#x2F;harborcp harbor.yml.tmpl harbor.ymlvim harbor.ymlhostname: 192.168.75.102 #修改服务器IP#https:#  # https port for harbor, default is 443  #注释无效配置#  port: 443#  # The path of cert and key files for nginx#  certificate: &#x2F;your&#x2F;certificate&#x2F;path#  private_key: &#x2F;your&#x2F;private&#x2F;key&#x2F;path</code></pre></li><li><p>安装harbor，前提条件是服务器安装了docker和docker-compose</p><pre class="language-bash" data-language="bash"><code class="language-bash">#需要耐心等待bash install.sh……………………✔ ----Harbor has been installed and started successfully.----</code></pre></li><li><p>验证harbor服务的，服务效果浏览器访问192.168.75.102，默认账号和密码是admin和Harbor12345</p></li></ul><p><img src="/../images/hblogs.png"></p><ul><li><p>创建新仓库名称</p><p><img src="/../images/createreg.png"></p></li><li><p>镜像上传harbor测试结果</p></li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">#修改镜像仓库[root@jenkins ~]# vim  &#x2F;etc&#x2F;docker&#x2F;daemon.json&#123;  &quot;insecure-registries&quot;:[&quot;192.168.11.102:80&quot;]&#125;#重新启动服务，在这里重新启动镜像后，其他容器需要重新启动[root@jenkins ~]# systemctl  restart docker#给镜像重新打上标签[root@jenkins ~]# docker tag 2ea870b320a0 192.168.75.102:80&#x2F;jenkinstest&#x2F;demohello:v1.0.0#查看结果[root@jenkins ~]# docker imagesREPOSITORY                                TAG             IMAGE ID       CREATED         SIZE192.168.75.102:80&#x2F;jenkinstest&#x2F;demohello   v1.0.0          2ea870b320a0   17 hours ago    846MBdocker login -u admin --password Harbor12345 http:&#x2F;&#x2F;192.168.75.102:80#登陆harbor仓库[root@jenkins ~]#  docker login -u admin --password Harbor12345 http:&#x2F;&#x2F;192.168.75.102:80#上传镜像到harbor[root@jenkins ~]# docker push 192.168.75.102:80&#x2F;jenkinstest&#x2F;demohello:v1.0.0The push refers to repository [192.168.75.102:80&#x2F;jenkinstest&#x2F;demohello]</code></pre><ul><li><p>登陆harbor查看上传镜像结果</p><p><img src="/../images/checkimages.png"></p></li></ul><h3 id="8-2-Jenkins构建镜像推送到harbor"><a href="#8-2-Jenkins构建镜像推送到harbor" class="headerlink" title="8.2  Jenkins构建镜像推送到harbor"></a>8.2  Jenkins构建镜像推送到harbor</h3><ul><li><p>配置Jenkins容器有docker功能</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@jenkins ~]# cd &#x2F;var&#x2F;run&#x2F;[root@jenkins run]# ll docker.socksrw-rw---- 1 root docker 0 Jul 13 09:47 docker.sock[root@jenkins run]# chown  root:root docker.sock[root@jenkins run]# chmod  o+rw docker.sock[root@jenkins run]# ll docker.socksrw-rw-rw- 1 root root 0 Jul 13 09:47 docker.sock#更改关于jenkins的docker-compose文件version: &quot;3.1&quot;services:  jenkins:    image: jenkins&#x2F;jenkins:2.413-jdk11    container_name: jenkins    ports:      - 8080:8080      - 50000:50000    volumes:      - .&#x2F;data&#x2F;:&#x2F;var&#x2F;jenkins_home&#x2F;      - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock      - &#x2F;usr&#x2F;bin&#x2F;docker:&#x2F;usr&#x2F;bin&#x2F;docker      - &#x2F;etc&#x2F;docker&#x2F;daemon.json:&#x2F;etc&#x2F;docker&#x2F;daemon.json #重新启动Jenkins容器 [root@jenkins ~]# docker-compose  up -d[+] Running 1&#x2F;1 ✔ Container jenkins  Started  #检查Jenkins容器里面是否有docker环境 [root@jenkins ~]# docker exec -it jenkins docker versionClient: Docker Engine - Community Version:           24.0.4……………………</code></pre></li><li><p>配置构建任务自动构建镜像并推送到harbor仓库，执行构建任务，并查看harbor仓库</p></li></ul><p><img src="/../images/pushh.png"></p><ul><li>并查看harbor仓库</li></ul><p><img src="/../images/cathb.png"></p><h3 id="8-3-服务部署"><a href="#8-3-服务部署" class="headerlink" title="8.3 服务部署"></a>8.3 服务部署</h3><ul><li>在目标服务器编写部署代码</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">[root@jenkins ~]# vim &#x2F;usr&#x2F;bin&#x2F;deploy.sh#!&#x2F;bin&#x2F;bashhorbar_addr&#x3D;$1horbar_repo&#x3D;$2project&#x3D;$3version&#x3D;$4port&#x3D;$5imageName&#x3D;$horbar_addr&#x2F;$horbar_repo&#x2F;$project:$versionecho $imageNamecontainerId&#x3D;&#96;docker ps -a |grep $&#123;project&#125;|awk &#39;&#123;print $1&#125;&#39;&#96;echo $containerIdif [ &quot;$containerId&quot; !&#x3D; &quot;&quot; ];thendocker stop $containerIddocker rm -f $containerIdfitag&#x3D;&#96;docker images |grep $&#123;project&#125; |awk &#39;&#123;print $2&#125;&#39;&#96;echo $tagif [[ &quot;$tag&quot; &#x3D;~ &quot;$version&quot; ]];thendocker rmi -f $imageNamefidocker login -u admin -p Harbor12345 $horbar_addrdocker pull $imageNamedocker run -d -p $port:$port --name $project $imageNameecho &quot;SUCCESS&quot;#给脚本赋予执行权限[root@jenkins ~]# chmod  a+x &#x2F;usr&#x2F;bin&#x2F;deploy.sh</code></pre><ul><li>修改构建任务信息</li></ul><p><img src="/../images/%E6%9E%84%E5%BB%BA%E4%BB%BB%E5%8A%A1%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2.png"></p><h2 id="九、pipeline-集成构建任务"><a href="#九、pipeline-集成构建任务" class="headerlink" title="九、pipeline 集成构建任务"></a>九、pipeline 集成构建任务</h2><h3 id="9-1-初识pipeline"><a href="#9-1-初识pipeline" class="headerlink" title="9.1 初识pipeline"></a>9.1 初识pipeline</h3><ul><li>创建流水线任务，并测试</li></ul><p><img src="/../images/pipline.png"></p><p><img src="/../images/pipelinehello.png"></p><ul><li>执行构建任务</li></ul><p><img src="/../images/pipecres.png"></p><ul><li>编写Pipeline脚本，构建任务</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;所有代码都放到pipelinepipeline &#123;    &#x2F;&#x2F;指定任务在那个集群节点中执行    agent any    &#x2F;&#x2F;声明全局变量，方便后面使用    environment &#123;        key &#x3D; &quot;value&quot;    &#125;    stages &#123;        stage(&#39;拉取git仓库代码&#39;) &#123;            steps &#123;                echo &#39;拉取git仓库代码 - SUCCESS&#39;            &#125;        &#125;        stage(&#39;通过maven构建项目&#39;) &#123;            steps &#123;                echo &#39;通过maven构建项目 - SUCCESS&#39;            &#125;        &#125;        stage(&#39;通过SonarQube做代码质量检查&#39;) &#123;            steps &#123;                echo &#39;通过SonarQube做代码质量检查 - SUCCESS&#39;            &#125;        &#125;        stage(&#39;通过Docker制作自定义镜像&#39;) &#123;            steps &#123;                echo &#39;通过Docker制作自定义镜像 - SUCCESS&#39;            &#125;        &#125;        stage(&#39;将自定义镜像推送到Harbor&#39;) &#123;            steps &#123;                echo &#39;将自定义镜像推送到Harbor - SUCCESS&#39;            &#125;        &#125;        stage(&#39;通过Publish Over SSH通知目标服务器&#39;) &#123;            steps &#123;                echo &#39;通过Publish Over SSH通知目标服务器 - SUCCESS&#39;            &#125;        &#125;    &#125;&#125;</code></pre><p><img src="/../images/crlog.png"></p><ul><li><p>pipeline 集成构建任务编写语法</p><p><img src="/../images/%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%AD%E6%B3%95.png"></p></li></ul><p><img src="/../images/%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%80%89%E9%A1%B9.png"></p><h3 id="9-2-编写项目中的pipeline脚本"><a href="#9-2-编写项目中的pipeline脚本" class="headerlink" title="9.2 编写项目中的pipeline脚本"></a>9.2 编写项目中的pipeline脚本</h3><ul><li>本项目使用scm编写pipeline文件</li></ul><p><img src="/../images/scmpipeline.png"></p><p>在gitlab创建Jenkinsfile</p><p><img src="/../images/pipetag.png"></p><ul><li><p>配置jenkins邮箱服务</p><p><img src="/../images/em1.png"></p><p><img src="/../images/em2.png"></p></li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;所有代码都放到pipelinepipeline &#123;    &#x2F;&#x2F;指定任务在那个集群节点中执行    agent any    &#x2F;&#x2F;声明全局变量，方便后面使用    environment &#123;        harborUser &#x3D; &#39;admin&#39;        harborPasswd &#x3D; &#39;Harbor12345&#39;        harborAddress &#x3D; &#39;192.168.75.102:80&#39;        harborRepo &#x3D; &#39;jenkinstest&#39;    &#125;    stages &#123;        stage(&#39;拉取git仓库代码&#39;) &#123;            steps &#123;               checkout scmGit(branches: [[name: &#39;$&#123;tag&#125;&#39;]], extensions: [], userRemoteConfigs: [[url: &#39;http:&#x2F;&#x2F;192.168.75.100:8929&#x2F;root&#x2F;demoHello.git&#39;]])            &#125;        &#125;        stage(&#39;通过maven构建项目&#39;) &#123;            steps &#123;                sh &#39;&#x2F;var&#x2F;jenkins_home&#x2F;maven&#x2F;bin&#x2F;mvn clean package -DskipTests&#39;                echo &#39;通过maven构建项目 - SUCCESS&#39;            &#125;        &#125;        stage(&#39;通过SonarQube做代码质量检查&#39;) &#123;            steps &#123;                sh &#39;&#x2F;var&#x2F;jenkins_home&#x2F;sonar-scanner&#x2F;bin&#x2F;sonar-scanner   -Dsonar.projectname&#x3D;$&#123;JOB_NAME&#125;   -Dsonar.projectKey&#x3D;$&#123;JOB_NAME&#125;  -Dsonar.source&#x3D;.&#x2F;   -Dsonar.java.binaries&#x3D;target -Dsonar.login&#x3D;a0277c64b7c5f6c1e03700fdd9f881eb48c98633&#39;                echo &#39;通过SonarQube做代码质量检查 - SUCCESS&#39;            &#125;        &#125;        stage(&#39;通过Docker制作自定义镜像&#39;) &#123;            steps &#123;                sh &#39;&#39;&#39;mv .&#x2F;target&#x2F;*.jar docker&#x2F;docker build -t 192.168.75.102:80&#x2F;jenkinstest&#x2F;$&#123;JOB_NAME&#125;:$tag docker&#x2F;docker image prune -f&#39;&#39;&#39;            &#125;        &#125;        stage(&#39;将自定义镜像推送到Harbor&#39;) &#123;            steps &#123;                sh &#39;&#39;&#39;docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborAddress&#125;docker push $&#123;harborAddress&#125;&#x2F;$&#123;harborRepo&#125;&#x2F;$&#123;JOB_NAME&#125;:$tag&#39;&#39;&#39;            &#125;        &#125;        stage(&#39;通过Publish Over SSH通知目标服务器&#39;) &#123;            steps &#123;                &#x2F;&#x2F;这边有个坑，默认生成的脚步命令是单引号需要改成双引号sshPublisher(publishers: [sshPublisherDesc(configName: &#39;test&#39;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &quot;deploy.sh  $&#123;harborAddress&#125;  $&#123;harborRepo&#125;  $&#123;JOB_NAME&#125;  $tag  $port&quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;&#39;, remoteDirectorySDF: false, removePrefix: &#39;&#39;, sourceFiles: &#39;&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: true)])            &#125;        &#125;        &#125;        &#x2F;&#x2F;需要配置jenkin邮箱服务    post&#123;        success &#123;            emailext body: &#39;构建成功&#39;, subject: &#39;构建成功&#39;, to: &#39;1626395559@qq.com&#39;        &#125;        failure&#123;            emailext body: &#39;构建失败&#39;, subject: &#39;构建失败&#39;, to: &#39;1626395559@qq.com&#39;        &#125;    &#125;&#125;</code></pre><h2 id="十、-Kubernetes持续集成和持续交付"><a href="#十、-Kubernetes持续集成和持续交付" class="headerlink" title="十、 Kubernetes持续集成和持续交付"></a>十、 Kubernetes持续集成和持续交付</h2><h3 id="10-1-搭建-Kubernetes集群"><a href="#10-1-搭建-Kubernetes集群" class="headerlink" title="10.1 搭建 Kubernetes集群"></a>10.1 搭建 Kubernetes集群</h3><ul><li>搭建方式使用开源的kuboard进行简单的k8s搭建<a href="https://kuboard.cn/">https://kuboard.cn/</a></li><li>安装v1.19.5版本的k8s集群</li><li>下载Centos7镜像地址：<a href="https://vault.centos.org/7.8.2003/isos/x86_64/CentOS-7-x86_64-Minimal-2003.iso">https://vault.centos.org/7.8.2003/isos/x86_64/CentOS-7-x86_64-Minimal-2003.iso</a></li><li>k8s安装参考安装文档：<a href="https://kuboard.cn/install/history-k8s/install-k8s-1.19.x.html">https://kuboard.cn/install/history-k8s/install-k8s-1.19.x.html</a></li><li>kuboard面板安装参考文档：<a href="https://kuboard.cn/install/v3/install-in-k8s.html#%E6%96%B9%E6%B3%95%E4%B8%80-%E4%BD%BF%E7%94%A8-hostpath-%E6%8F%90%E4%BE%9B%E6%8C%81%E4%B9%85%E5%8C%96">https://kuboard.cn/install/v3/install-in-k8s.html#%E6%96%B9%E6%B3%95%E4%B8%80-%E4%BD%BF%E7%94%A8-hostpath-%E6%8F%90%E4%BE%9B%E6%8C%81%E4%B9%85%E5%8C%96</a></li><li>k8s官网：<a href="https://kubernetes.io/">https://kubernetes.io/</a></li></ul><h3 id="10-2-构建-Kubernetes持续集成和持续交付任务"><a href="#10-2-构建-Kubernetes持续集成和持续交付任务" class="headerlink" title="10.2  构建 Kubernetes持续集成和持续交付任务"></a>10.2  构建 Kubernetes持续集成和持续交付任务</h3><h4 id="10-2-1-持续交付任务"><a href="#10-2-1-持续交付任务" class="headerlink" title="10.2.1 持续交付任务"></a>10.2.1 持续交付任务</h4><ul><li>编写k8s使用的编排文件pipeline.yml放到gitlab仓库</li></ul><pre class="language-yaml" data-language="yaml"><code class="language-yaml">apiVersion: apps&#x2F;v1kind: Deploymentmetadata:  name: pipeline-deployment  namespace: test  labels:    app: pipelinespec:  replicas: 3  selector:    matchLabels:      app: pipeline  template:    metadata:      labels:        app: pipeline    spec:      containers:      - name: pipeline        image: 192.168.75.102:80&#x2F;jenkinstest&#x2F;pipeline:v6        ports:        - containerPort: 8081---apiVersion: v1kind: Servicemetadata:  namespace: test  name: pipeline-deployment  labels:    app: pipeline-deploymentspec:  selector:    app: pipeline  ports:  - port: 8888    targetPort: 8081  type: NodePort---apiVersion: networking.k8s.io&#x2F;v1kind: Ingressmetadata:  namespace: test  name: pipeline-ingressspec:  ingressClassName: ingress  rules:  - host: bobo.nginx.com    http:      paths:      - path: &#x2F;        pathType: Prefix        backend:          service:            name: pipeline-deployment            port:              number: 8888</code></pre><p>修改Jenkinsfile文件，删除ssh推送任务，</p><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;所有代码都放到pipelinepipeline &#123;    &#x2F;&#x2F;指定任务在那个集群节点中执行    agent any    &#x2F;&#x2F;声明全局变量，方便后面使用    environment &#123;        harborUser &#x3D; &#39;admin&#39;        harborPasswd &#x3D; &#39;Harbor12345&#39;        harborAddress &#x3D; &#39;192.168.75.102:80&#39;        harborRepo &#x3D; &#39;jenkinstest&#39;    &#125;    stages &#123;        stage(&#39;拉取git仓库代码&#39;) &#123;            steps &#123;               checkout scmGit(branches: [[name: &#39;$&#123;tag&#125;&#39;]], extensions: [], userRemoteConfigs: [[url: &#39;http:&#x2F;&#x2F;192.168.75.100:8929&#x2F;root&#x2F;demoHello.git&#39;]])            &#125;        &#125;        stage(&#39;通过maven构建项目&#39;) &#123;            steps &#123;                sh &#39;&#x2F;var&#x2F;jenkins_home&#x2F;maven&#x2F;bin&#x2F;mvn clean package -DskipTests&#39;                echo &#39;通过maven构建项目 - SUCCESS&#39;            &#125;        &#125;        stage(&#39;通过SonarQube做代码质量检查&#39;) &#123;            steps &#123;                sh &#39;&#x2F;var&#x2F;jenkins_home&#x2F;sonar-scanner&#x2F;bin&#x2F;sonar-scanner   -Dsonar.projectname&#x3D;$&#123;JOB_NAME&#125;   -Dsonar.projectKey&#x3D;$&#123;JOB_NAME&#125;  -Dsonar.source&#x3D;.&#x2F;   -Dsonar.java.binaries&#x3D;target -Dsonar.login&#x3D;a0277c64b7c5f6c1e03700fdd9f881eb48c98633&#39;                echo &#39;通过SonarQube做代码质量检查 - SUCCESS&#39;            &#125;        &#125;        stage(&#39;通过Docker制作自定义镜像&#39;) &#123;            steps &#123;                sh &#39;&#39;&#39;mv .&#x2F;target&#x2F;*.jar docker&#x2F;docker build -t 192.168.75.102:80&#x2F;jenkinstest&#x2F;$&#123;JOB_NAME&#125;:$tag docker&#x2F;docker image prune -f&#39;&#39;&#39;            &#125;        &#125;        stage(&#39;将自定义镜像推送到Harbor&#39;) &#123;            steps &#123;                sh &#39;&#39;&#39;docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborAddress&#125;docker push $&#123;harborAddress&#125;&#x2F;$&#123;harborRepo&#125;&#x2F;$&#123;JOB_NAME&#125;:$tag&#39;&#39;&#39;            &#125;        &#125;        stage(&#39;复制pipeline.yml文件到 masternode&#39;) &#123;            steps &#123;               sshPublisher(publishers: [sshPublisherDesc(configName: &#39;k8s&#39;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &#39;&#39;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;&#39;, remoteDirectorySDF: false, removePrefix: &#39;&#39;, sourceFiles: &#39;pipeline.yml&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])            &#125;        &#125;        &#125;    post&#123;        success &#123;            emailext body: &#39;构建成功&#39;, subject: &#39;构建成功&#39;, to: &#39;1626395559@qq.com&#39;        &#125;        failure&#123;            emailext body: &#39;构建失败&#39;, subject: &#39;构建失败&#39;, to: &#39;1626395559@qq.com&#39;        &#125;    &#125;&#125;</code></pre><ul><li><p>配置新主机在系统配置里面</p><p><img src="/../images/sshk8s.png"></p></li><li><p>由于jenkins无法自动输入服务器的密码信息，需要给Jenkins容器添加服务器的免没有登陆</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@jenkins controller]# docker exec -it  jenkins &#x2F;bin&#x2F;bashjenkins@0a06591b1a48:&#x2F;$ ssh-keygen #一直回车处理jenkins@0a06591b1a48:&#x2F;$ ssh-copy-id root@192.168.75.103 #需要输入服务器密码账号</code></pre></li><li><p>给新代码打上v6标签，并构建v6版本任务</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@masternode ~]# kubectl  get svc -n testNAME                  TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGEpipeline-deployment   NodePort   10.96.85.191   &lt;none&gt;        8888:32460&#x2F;TCP   3h5m[root@masternode ~]# curl  10.96.85.191:8888&#x2F;helloHello World v6.0.0</code></pre></li></ul><h4 id="10-2-2-配置持续集成任务"><a href="#10-2-2-配置持续集成任务" class="headerlink" title="10.2.2 配置持续集成任务"></a>10.2.2 配置持续集成任务</h4><ul><li>Jenkins项目配置</li></ul><p><img src="/../images/gitlabplugin.png"></p><p><img src="/../images/gitlaben.png"></p><p><img src="/../images/pipeline333.png"></p><p><img src="/../images/%E8%A7%A6%E5%8F%91%E5%99%A8%E5%90%AF%E5%8A%A8.png"></p><ul><li>GitLab配置</li></ul><p><img src="/../images/gitadmin.png"></p><p><img src="/../images/gitnetwork.png"></p><p><img src="/../images/gitrequest.png"></p><p><img src="/../images/prj.png"></p><p><img src="/../images/gitwebhooks.png"></p><p><img src="/../images/giturljenkins.png"></p><p><img src="/../images/jenkinsurl11.png"></p><p><img src="/../images/createweb.png"></p><p><img src="/../images/checkwebhooks.png"></p><p><img src="/../images/webhookresult.png"></p><ul><li>编写构建任务的Jenkinsfile文件，将tag变量改成相关参数，*&#x2F;master和latest</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;所有代码都放到pipelinepipeline &#123;    &#x2F;&#x2F;指定任务在那个集群节点中执行    agent any    &#x2F;&#x2F;声明全局变量，方便后面使用    environment &#123;        harborUser &#x3D; &#39;admin&#39;        harborPasswd &#x3D; &#39;Harbor12345&#39;        harborAddress &#x3D; &#39;192.168.75.102:80&#39;        harborRepo &#x3D; &#39;jenkinstest&#39;    &#125;    stages &#123;        stage(&#39;拉取git仓库代码&#39;) &#123;            steps &#123;               checkout scmGit(branches: [[name: &#39;*&#x2F;master&#39;]], extensions: [], userRemoteConfigs: [[url: &#39;http:&#x2F;&#x2F;192.168.75.100:8929&#x2F;root&#x2F;demoHello.git&#39;]])            &#125;        &#125;        stage(&#39;通过maven构建项目&#39;) &#123;            steps &#123;                sh &#39;&#x2F;var&#x2F;jenkins_home&#x2F;maven&#x2F;bin&#x2F;mvn clean package -DskipTests&#39;                echo &#39;通过maven构建项目 - SUCCESS&#39;            &#125;        &#125;        stage(&#39;通过SonarQube做代码质量检查&#39;) &#123;            steps &#123;                sh &#39;&#x2F;var&#x2F;jenkins_home&#x2F;sonar-scanner&#x2F;bin&#x2F;sonar-scanner   -Dsonar.projectname&#x3D;$&#123;JOB_NAME&#125;   -Dsonar.projectKey&#x3D;$&#123;JOB_NAME&#125;  -Dsonar.source&#x3D;.&#x2F;   -Dsonar.java.binaries&#x3D;target -Dsonar.login&#x3D;a0277c64b7c5f6c1e03700fdd9f881eb48c98633&#39;                echo &#39;通过SonarQube做代码质量检查 - SUCCESS&#39;            &#125;        &#125;        stage(&#39;通过Docker制作自定义镜像&#39;) &#123;            steps &#123;                sh &#39;&#39;&#39;mv .&#x2F;target&#x2F;*.jar docker&#x2F;docker build -t 192.168.75.102:80&#x2F;jenkinstest&#x2F;$&#123;JOB_NAME&#125;:latest docker&#x2F;docker image prune -f&#39;&#39;&#39;            &#125;        &#125;        stage(&#39;将自定义镜像推送到Harbor&#39;) &#123;            steps &#123;                sh &#39;&#39;&#39;docker login -u $&#123;harborUser&#125; -p $&#123;harborPasswd&#125; $&#123;harborAddress&#125;docker push $&#123;harborAddress&#125;&#x2F;$&#123;harborRepo&#125;&#x2F;$&#123;JOB_NAME&#125;:latest&#39;&#39;&#39;            &#125;        &#125;        stage(&#39;复制pipeline.yml文件到 masternode&#39;) &#123;            steps &#123;               sshPublisher(publishers: [sshPublisherDesc(configName: &#39;k8s&#39;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &#39;&#39;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;&#39;, remoteDirectorySDF: false, removePrefix: &#39;&#39;, sourceFiles: &#39;pipeline.yml&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])            &#125;        &#125;    stage(&#39;构建看k8s环境任务&#39;) &#123;        steps &#123;            sh &#39;ssh root@192.168.75.103 kubectl apply -f &#x2F;usr&#x2F;local&#x2F;k8s&#x2F;pipeline.yml&#39;            &#125;        &#125;        &#125;    post&#123;        success &#123;            emailext body: &#39;构建成功&#39;, subject: &#39;构建成功&#39;, to: &#39;1626395559@qq.com&#39;        &#125;        failure&#123;            emailext body: &#39;构建失败&#39;, subject: &#39;构建失败&#39;, to: &#39;1626395559@qq.com&#39;        &#125;    &#125;&#125;</code></pre><ul><li>更新pipeline.yml文件</li></ul><pre class="language-yaml" data-language="yaml"><code class="language-yaml">image: 192.168.75.102:80&#x2F;jenkinstest&#x2F;pipeline:latest #更改镜像版本号</code></pre><ul><li>更改源代码</li></ul><pre class="language-java" data-language="java"><code class="language-java">public String helloWorld() &#123;       return &quot;Hello World v7.0.0&quot;;   &#125;</code></pre><ul><li>gitlab上传更新代码,并查看结果</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">[root@masternode ~]# curl  10.96.85.191:8888&#x2F;helloHello World v7.0.0</code></pre><h2 id="十一、需要本课程的资料文件，请关注微信公众号获取，回复“小张DevOps”"><a href="#十一、需要本课程的资料文件，请关注微信公众号获取，回复“小张DevOps”" class="headerlink" title="十一、需要本课程的资料文件，请关注微信公众号获取，回复“小张DevOps”"></a>十一、需要本课程的资料文件，请关注微信公众号获取，回复“小张DevOps”</h2><p><img src="/../images/pwx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 云计算 </tag>
            
            <tag> Devops </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘优化工具spacesniffer</title>
      <link href="/9a299a77.html"/>
      <url>/9a299a77.html</url>
      
        <content type="html"><![CDATA[<p>SpaceSniffer是一款免费的磁盘空间分析工具，它可以帮助用户快速了解磁盘上的文件和文件夹占用空间情况，方便用户进行磁盘清理和优化。</p><h2 id="界面简介"><a href="#界面简介" class="headerlink" title="界面简介"></a>界面简介</h2><p>SpaceSniffer的界面非常直观，它会以图形化的方式展示磁盘上的文件和文件夹。用户可以通过缩放和移动来查看不同层级的文件夹和文件，同时还可以通过颜色区分不同类型的文件和文件夹。</p><p><img src="/../images/spw.png"></p><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><p>除了基本的文件大小和占用空间信息外，SpaceSniffer还提供了一些高级功能，比如可以按照文件类型、修改时间、访问时间等进行排序，还可以通过过滤器来快速查找指定类型的文件。</p><p><img src="/../images/spset.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，SpaceSniffer是一款非常实用的磁盘工具，它可以帮助用户快速了解磁盘上的文件和文件夹占用空间情况，方便用户进行磁盘清理和优化。如果你需要对磁盘空间进行管理，SpaceSniffer是一个不错的选择。</p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://wwst.lanzout.com/iJeaE0yp1cxg">https://wwst.lanzout.com/iJeaE0yp1cxg</a></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统优化 </tag>
            
            <tag> window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS入门搭建</title>
      <link href="/ab2c4f2.html"/>
      <url>/ab2c4f2.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、环境介绍"><a href="#一、环境介绍" class="headerlink" title="一、环境介绍"></a>一、环境介绍</h2><p>配置根据自己的电脑配置，设置</p><table><thead><tr><th>系统说明</th><th align="center">服务器&#x2F;Linux</th><th align="center">测试客户端win</th></tr></thead><tbody><tr><td>系统版本</td><td align="center">Centos7.8</td><td align="center">window10专业版</td></tr><tr><td>配置</td><td align="center">2G,4cpu</td><td align="center">4G,2 vcpu</td></tr></tbody></table><h2 id="二、配置搭建环境"><a href="#二、配置搭建环境" class="headerlink" title="二、配置搭建环境"></a>二、配置搭建环境</h2><p>1.配置网络镜像源</p><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;备份镜像源[root@xiaozhang ~]# mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-* &#x2F;opt&#x2F;&#x2F;&#x2F;下载阿里云网络镜像源[root@xiaozhang ~]# curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo&#x2F;&#x2F;清除缓存安装包[root@xiaozhang ~]# yum clena all&#x2F;&#x2F;刷新网络镜像源[root@xiaozhang ~]# yum repolist</code></pre><p>2.检查是否关闭Selinux</p><p>检查关闭，如果没有关闭，请关闭Selinx</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@xiaozhang ~]# getenforceDisabled</code></pre><p>如何关闭Selinux</p><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;更改配置文件[root@xiaozhang ~]# sed -i &quot;s&#x2F;SELINUX&#x3D;enforcing&#x2F;SELINUX&#x3D;disabled&#x2F;g&quot; &#x2F;etc&#x2F;selinux&#x2F;config&#x2F;&#x2F;关机重启[root@xiaozhang ~]# reboot</code></pre><p>3.放行DNS端口53</p><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;查看防火墙是否启动[root@xiaozhang ~]# firewall-cmd --staterunning&#x2F;&#x2F;如果不是防火墙没有启动，无需执行下面的的命令[root@xiaozhang ~]# firewall-cmd --zone&#x3D;public --add-port&#x3D;53&#x2F;tcp --permanentsuccess[root@xiaozhang ~]# firewall-cmd --zone&#x3D;public --add-port&#x3D;53&#x2F;udp --permanentsuccess[root@xiaozhang ~]# firewall-cmd --reloadsuccess[root@xiaozhang ~]# firewall-cmd --zone&#x3D;public --list-ports53&#x2F;tcp 53&#x2F;udp</code></pre><h2 id="三、搭建DNS服务"><a href="#三、搭建DNS服务" class="headerlink" title="三、搭建DNS服务"></a>三、搭建DNS服务</h2><p>1.安装DNS软件</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@xiaozhang ~]# yum install bind-* -y</code></pre><p>2.配置文件修改</p><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;打开文件&#x2F;etc&#x2F;named.confvim &#x2F;etc&#x2F;named.confoptions &#123;        listen-on port 53 &#123; any; &#125;; &#x2F;&#x2F;更改了监听的IP地址，any表示允许任何IP地址连接        listen-on-v6 port 53 &#123; ::1; &#125;;        directory       &quot;&#x2F;var&#x2F;named&quot;;        dump-file       &quot;&#x2F;var&#x2F;named&#x2F;data&#x2F;cache_dump.db&quot;;        statistics-file &quot;&#x2F;var&#x2F;named&#x2F;data&#x2F;named_stats.txt&quot;;        memstatistics-file &quot;&#x2F;var&#x2F;named&#x2F;data&#x2F;named_mem_stats.txt&quot;;        recursing-file  &quot;&#x2F;var&#x2F;named&#x2F;data&#x2F;named.recursing&quot;;        secroots-file   &quot;&#x2F;var&#x2F;named&#x2F;data&#x2F;named.secroots&quot;;        allow-query     &#123; any; &#125;; &#x2F;&#x2F;更改了允许查询的IP地址，any表示允许任何IP地址查询        recursion yes; &#x2F;&#x2F;开启了递归查询        forwarders &#123;  114.114.114.114;223.5.5.5;&#125;;  &#x2F;&#x2F;增加转发域名DNS服务器        dnssec-enable no;  &#x2F;&#x2F;禁用了DNSSEC功能        dnssec-validation no;  &#x2F;&#x2F;禁用了DNSSEC验证        &#x2F;* Path to ISC DLV key *&#x2F;        bindkeys-file &quot;&#x2F;etc&#x2F;named.root.key&quot;;        managed-keys-directory &quot;&#x2F;var&#x2F;named&#x2F;dynamic&quot;;        pid-file &quot;&#x2F;run&#x2F;named&#x2F;named.pid&quot;;        session-keyfile &quot;&#x2F;run&#x2F;named&#x2F;session.key&quot;;&#125;;logging &#123;        channel default_debug &#123;                file &quot;data&#x2F;named.run&quot;;                severity dynamic;        &#125;;&#125;;zone &quot;.&quot; IN &#123;        type hint;        file &quot;named.ca&quot;;&#125;;include &quot;&#x2F;etc&#x2F;named.rfc1912.zones&quot;;include &quot;&#x2F;etc&#x2F;named.root.key&quot;;</code></pre><p>3.配置解析的域名</p><p>解析域名</p><pre class="language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;named.rfc1912.zones……&#x2F;&#x2F;正向解析zone &quot;skillzhang.com&quot; IN &#123;    type master;    file &quot;skillzhang.com.zone&quot;;    allow-update &#123; none; &#125;;&#125;;&#x2F;&#x2F;反向解析zone &quot;127.168.192.in-addr.arpa&quot; IN &#123;        type master;        file &quot;192.168.127.arpa&quot;;        allow-update &#123; none; &#125;;&#125;;&#x2F;&#x2F;正向解析文件vim skillzhang.com.zone$TTL 1D@    IN SOA    @ rname.invalid. (                    0    ; serial                    1D    ; refresh                    1H    ; retry                    1W    ; expire                    3H )    ; minimum    NS    @    A    192.168.127.100www IN A 192.168.127.100&#x2F;&#x2F;反向解析文件vim 192.168.127.arpa$TTL 1D@    IN SOA    skillzhang.com. root (                    0    ; serial                    1D    ; refresh                    1H    ; retry                    1W    ; expire                    3H )    ; minimum    NS    skillzhang.com.    A     192.168.127.100100 IN PTR skillzhang.com. &#x2F;&#x2F;100为ip地址&#x2F;&#x2F;启动DNS服务[root@xiaozhang named]# systemctl  restart named[root@xiaozhang named]# systemctl  enable  namedCreated symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;named.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;named.service.</code></pre><h2 id="四、检查验证服务"><a href="#四、检查验证服务" class="headerlink" title="四、检查验证服务"></a>四、检查验证服务</h2><p>1.Linux系统测试验证</p><p>替换本地DNS服务器地址</p><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;修改本地DNS[root@xiaozhang named]# vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33TYPE&#x3D;EthernetPROXY_METHOD&#x3D;noneBROWSER_ONLY&#x3D;noBOOTPROTO&#x3D;noneDEFROUTE&#x3D;yesIPV4_FAILURE_FATAL&#x3D;noIPV6INIT&#x3D;yesIPV6_AUTOCONF&#x3D;yesIPV6_DEFROUTE&#x3D;yesIPV6_FAILURE_FATAL&#x3D;noIPV6_ADDR_GEN_MODE&#x3D;stable-privacyNAME&#x3D;ens33UUID&#x3D;94092393-3b2d-40c4-ac97-e406ba043ad9DEVICE&#x3D;ens33ONBOOT&#x3D;yesIPADDR&#x3D;192.168.127.100PREFIX&#x3D;24GATEWAY&#x3D;192.168.127.2DNS1&#x3D;192.168.127.100 &#x2F;&#x2F;修改IPV6_PRIVACY&#x3D;noZONE&#x3D;public&#x2F;&#x2F;重新启动网络[root@xiaozhang ~]# systemctl  restart network</code></pre><p>验证DNS服务解析</p><pre class="language-none"><code class="language-none">[root@xiaozhang named]# nslookup  &#x2F;&#x2F;检查命令&gt; killbobo.com                     &#x2F;&#x2F;域名正向解析检查Server:         192.168.127.100Address:        192.168.127.100#53** server can&#39;t find killbobo.com: NXDOMAIN&gt; 192.168.127.100                  &#x2F;&#x2F;域名反向解析检查100.127.168.192.in-addr.arpa    name &#x3D; skillzhang.com.&gt; baidu.com                        &#x2F;&#x2F;域名缓存检查Server:         192.168.127.100Address:        192.168.127.100#53Non-authoritative answer:Name:   baidu.comAddress: 39.156.66.10Name:   baidu.comAddress: 110.242.68.66</code></pre><p>2.Window系统验证</p><p>更改DNS配置</p><p><img src="/../images/winnetwork.png" alt="更改DNS配置"></p><p>验证DNS服务，打开命令行窗口</p><p><img src="/../images/wintest.png" alt="验证DNS服务"></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> window </tag>
            
            <tag> 网络 </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Podman入门</title>
      <link href="/336e2b35.html"/>
      <url>/336e2b35.html</url>
      
        <content type="html"><![CDATA[<h2 id="podman-vs-docker"><a href="#podman-vs-docker" class="headerlink" title="podman vs docker"></a>podman vs docker</h2><h3 id="什么是Podman？"><a href="#什么是Podman？" class="headerlink" title="什么是Podman？"></a><strong>什么是Podman？</strong></h3><p><img src="/../images/podminlog.png" alt="什么是Podman"></p><p>Podman 是一个开源的容器运行时项目，可在大多数 Linux 平台上使用。Podman 提供与 Docker 非常相似的功能。正如前面提到的那样，它不需要在你的系统上运行任何守护进程，并且它也可以在没有 root 权限的情况下运行。</p><p>Podman 可以管理和运行任何符合 OCI（Open Container Initiative）规范的容器和容器镜像。Podman 提供了一个与 Docker 兼容的命令行前端来管理 Docker 镜像。</p><p>Podman 官网地址：<a href="https://podman.io/">https://podman.io/</a></p><h3 id="Podman和Docker的主要区别是什么？"><a href="#Podman和Docker的主要区别是什么？" class="headerlink" title="Podman和Docker的主要区别是什么？"></a><strong>Podman和Docker的主要区别是什么？</strong></h3><ul><li><p>dockers在实现CRI的时候，它需要一个守护进程，其次需要以root运行，因此这也带来了安全隐患。</p></li><li><p>podman不需要守护程序，也不需要root用户运行，从逻辑架构上，比docker更加合理。</p></li><li><p>在docker的运行体系中，需要多个daemon才能调用到OCI的实现RunC。</p></li><li><p>在容器管理的链路中，Docker Engine的实现就是dockerd</p></li><li><p>daemon，它在linux中需要以root运行，dockerd调用containerd，containerd调用containerd-shim，然后才能调用runC。顾名思义shim起的作用也就是“垫片”，避免父进程退出影响容器的运训</p></li><li><p>podman直接调用OCI,runtime（runC），通过common作为容器进程的管理工具，但不需要dockerd这种以root身份运行的守护进程。</p></li><li><p>在podman体系中，有个称之为common的守护进程，其运行路径通常是&#x2F;usr&#x2F;libexec&#x2F;podman&#x2F;conmon，它是各个容器进程的父进程，每个容器各有一个，common的父则通常是1号进程。podman中的common其实相当于docker体系中的containerd-shim。</p><p><img src="/../images/deom.png" alt="vsdocker"></p><p>图中所体现的事情是，podman不需要守护进程，而dorker需要守护进程。在这个图的示意中，dorcker的containerd-shim与podman的common被归在Container一层。</p></li></ul><h3 id="Podman的使用与docker有什么区别？"><a href="#Podman的使用与docker有什么区别？" class="headerlink" title="Podman的使用与docker有什么区别？"></a><strong>Podman的使用与docker有什么区别？</strong></h3><p>podman的定位也是与docker兼容，因此在使用上面尽量靠近docker。在使用方面，可以分成两个方面来说，一是系统构建者的角度，二是使用者的角度。</p><p>在系统构建者方面，用podman的默认软件，与docker的区别不大，只是在进程模型、进程关系方面有所区别。如果习惯了docker几个关联进程的调试方法，在podman中则需要适应。可以通过pstree命令查看进程的树状结构。总体来看，podman比docker要简单。由于podman比docker少了一层daemon，因此重启的机制也就不同了。</p><p>在使用者方面，podman与docker的命令基本兼容，都包括容器运行时（run&#x2F;start&#x2F;kill&#x2F;ps&#x2F;inspect），本地镜像（images&#x2F;rmi&#x2F;build）、镜像仓库（login&#x2F;pull&#x2F;push）等几个方面。因此podman的命令行工具与docker类似，比如构建镜像、启停容器等。甚至可以通过alias</p><p>docker&#x3D;podman可以进行替换。因此，即便使用了podman，仍然可以使用docker.io作为镜像仓库，这也是兼容性最关键的部分。</p><h2 id="Podman常用命令"><a href="#Podman常用命令" class="headerlink" title="Podman常用命令"></a><strong>Podman常用命令</strong></h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a><strong>容器</strong></h3><pre class="language-bash" data-language="bash"><code class="language-bash">podman run           创建并启动容器podman start         启动容器podman ps            查看容器podman stop          终止容器podman restart       重启容器podman attach        进入容器podman exec          进入容器podman export        导出容器podman import        导入容器快照podman rm            删除容器podman logs          查看日志</code></pre><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a><strong>镜像</strong></h3><pre class="language-bash" data-language="bash"><code class="language-bash">podman search        检索镜像podman pull         获取镜像podman images        列出镜像podman image Is       列出镜像podman rmi          删除镜像podman image rm       删除镜像podman save         导出镜像podman load         导入镜像podmanfile          定制镜像（三个） podman build       构建镜像  podman run        运行镜像  podmanfile        常用指令（四个）   COPY         复制文件    ADD         高级复制    CMD         容器启动命令    ENV         环境变量    EXPOSE        暴露端口</code></pre><h3 id="部署-Podman"><a href="#部署-Podman" class="headerlink" title="部署 Podman"></a><strong>部署 Podman</strong></h3><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;安装podman[root@localhost ~]# yum -y install podman</code></pre><h3 id="Podman-加速器"><a href="#Podman-加速器" class="headerlink" title="Podman 加速器"></a><strong>Podman 加速器</strong></h3><p>版本7配置加速器</p><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;仓库配置[root@localhost ~]*# vim &#x2F;etc&#x2F;containers&#x2F;registries.conf*[registries.search]*#registries &#x3D; [&quot;registry.access.redhat.com&quot;, &quot;registry.redhat.io&quot;, &quot;docker.io&quot;] #这个是查找，从这三个地方查找*registries &#x3D; [&quot;docker.io&quot;] *#如果只留一个，则只在一个源里查找*[[docker.io]]location&#x3D;&quot;j3m2itm3.mirror.aliyuncs.com&quot;</code></pre><p>版本8配置加速器</p><pre class="language-bash" data-language="bash"><code class="language-bash">*#unqualified-search-registries &#x3D; [&quot;registry.fedoraproject.org&quot;, &quot;registry.access.redhat.com&quot;, &quot;registry.centos.org&quot;, &quot;docker.io&quot;]  #直接注释掉*unqualified-search-registries &#x3D; [&quot;docker.io&quot;] *#添加一个docker.io*[[registry]]prefix &#x3D; &quot;docker.io&quot;location &#x3D; &quot;j3m2itm3.mirror.aliyuncs.com&quot; （不用加https:&#x2F;&#x2F; 直接加地址）### **使用 Podman**</code></pre><p>使用 Podman 非常的简单，Podman 的指令跟 Docker 大多数都是相同的。下面我们来看几个常用的例子：</p><p>运行一个容器</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# podman run -d --name httpd docker.io&#x2F;library&#x2F;httpdTrying to pull docker.io&#x2F;library&#x2F;httpd...Getting image source signaturesCopying blob e5ae68f74026 done  Copying blob d3576f2b6317 done  Copying blob bc36ee1127ec done  Copying blob f1aa5f54b226 done  Copying blob aa379c0cedc2 done  Copying config ea28e1b82f done  Writing manifest to image destinationStoring signatures0492e405b9ecb05e6e6be1fec0ac1a8b6ba3ff949df259b45146037b5f355035&#x2F;&#x2F;查看镜像[root@localhost ~]# podman imagesREPOSITORY                  TAG      IMAGE ID       CREATED       SIZEdocker.io&#x2F;library&#x2F;httpd     latest   ea28e1b82f31   11 days ago   148 MB</code></pre><p>列出运行的容器</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# podman psCONTAINER ID  IMAGE                             COMMAND           CREATED             STATUS                 PORTS  NAMES0492e405b9ec  docker.io&#x2F;library&#x2F;httpd:latest    httpd-foreground  About a minute ago  Up About a minute ago         httpd</code></pre><p>注意：如果在ps命令中添加-a，Podman 将显示所有容器。</p><p>检查正在运行的容器</p><p>您可以“检查”正在运行的容器的元数据和有关其自身的详细信息。我们甚至可以使用 inspect 子命令查看分配给容器的 IP 地址。由于容器以无根模式运行，因此未分配 IP 地址，并且该值将在检查的输出中列为“无”。</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# podman inspect -l | grep IPAddress\&quot;:             &quot;SecondaryIPAddresses&quot;: null,             &quot;IPAddress&quot;: &quot;10.88.0.5&quot;,[root@localhost ~]# curl 10.88.0.5It works!</code></pre><p>注意：-l 是最新容器的便利参数。您还可以使用容器的 ID 代替 -l。</p><p>查看一个运行中容器的日志</p><pre class="language-bash" data-language="bash"><code class="language-bash">选项 --latest  #最近的 [root@localhost ~]# podman logs --latestAH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using 10.88.0.5. Set the &#39;ServerName&#39; directive globally to suppress this messageAH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using 10.88.0.5. Set the &#39;ServerName&#39; directive globally to suppress this message[Mon Dec 13 15:17:53.690844 2021] [mpm_event:notice] [pid 1:tid 140665160166720] AH00489: Apache&#x2F;2.4.51 (Unix) configured -- resuming normal operations[Mon Dec 13 15:17:53.690946 2021] [core:notice] [pid 1:tid 140665160166720] AH00094: Command line: &#39;httpd -D FOREGROUND&#39;10.88.0.1 - - [13&#x2F;Dec&#x2F;2021:15:19:48 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 4510.88.0.1 - - [13&#x2F;Dec&#x2F;2021:15:20:47 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 45</code></pre><p>查看一个运行容器中的进程资源使用情况，可以使用top观察容器中的 nginx pid</p><pre class="language-bash" data-language="bash"><code class="language-bash">语法： podman top &lt;container_id&gt;   [root@localhost ~]# podman top httpdUSER       PID   PPID   %CPU    ELAPSED            TTY   TIME   COMMANDroot       1     0      0.000   15m38.599711321s   ?     0s     httpd -DFOREGROUND www-data   7     1      0.000   15m38.599783256s   ?     0s     httpd -DFOREGROUND www-data   8     1      0.000   15m38.599845342s   ?     0s     httpd -DFOREGROUND www-data   9     1      0.000   15m38.599880444s   ?     0s     httpd -DFOREGROUND </code></pre><p>停止一个运行中的容器</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# podman stop --latest2f3edf712621d3a41e03fa8c7f6a5cdba56fbbad43a7a59ede26cc88f31006c4[root@localhost ~]# podman psCONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES</code></pre><p>删除一个容器</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# podman rm --latest2f3edf712621d3a41e03fa8c7f6a5cdba56fbbad43a7a59ede26cc88f31006c4[root@localhost ~]# podman ps -aCONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES</code></pre><p>以上这些特性基本上都和 Docker 一样，Podman 除了兼容这些特性外，还支持了一些新的特性。</p><p>上传镜像</p><p>例如，如果我们想在 docker.io 上分享我们新建的 Nginx 容器镜像，这很容易。首先登录码头：</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost nginx]# tree .├── Dockerfile└── files    └── nginx-1.20.1.tar.gz[root@localhost nginx]# cat Dockerfile FROM docker.io&#x2F;library&#x2F;centosENV PATH &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin:$PATHADD files&#x2F;nginx-1.20.1.tar.gz &#x2F;usr&#x2F;srcRUN useradd -r -M -s &#x2F;sbin&#x2F;nologin nginx &amp;&amp; \    yum -y install pcre-devel openssl openssl-devel gd-devel gcc gcc-c++ make &amp;&amp; \    mkdir -p &#x2F;var&#x2F;log&#x2F;nginx &amp;&amp; \    cd &#x2F;usr&#x2F;src&#x2F;nginx-1.20.1 &amp;&amp; \    .&#x2F;configure \    --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx \    --user&#x3D;nginx \    --group&#x3D;nginx \    --with-debug \    --with-http_ssl_module \    --with-http_realip_module \    --with-http_image_filter_module \    --with-http_gunzip_module \    --with-http_gzip_static_module \    --with-http_stub_status_module \    --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log \    --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log &amp;&amp; \  make &amp;&amp; make installCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off&quot;][root@localhost nginx]# podman build -t nginx .&#x2F;&#x2F; 修改镜像名 [root@localhost ~]# podman tag docker.io&#x2F;library&#x2F;nginx:latest docker.io&#x2F;1314444&#x2F;test:latest&#x2F;&#x2F; 登录并上传镜像[root@localhost ~]# podman login docker.io &#x2F;&#x2F; 需要告诉其要登录到docker仓库[root@localhost ~]# podman login docker.ioUsername: 1314444  #账户Password: ********  #密码Login Succeeded![root@localhost nginx]# podman push docker.io&#x2F;1314444&#x2F;test:latest  &#x2F;&#x2F;上传镜像Getting image source signaturesCopying blob 38c40d6c2c85 doneCopying blob fee76a531659 doneCopying blob c2adabaecedb doneCopying config 7f3589c0b8 doneWriting manifest to image destinationCopying config 7f3589c0b8 doneWriting manifest to image destinationStoring signatures&#x2F;&#x2F;请注意，我们将四层推送到我们的注册表，现在可供其他人共享。快速浏览一下：[root@localhost ~]# podman inspect 1314444&#x2F;test:nginx&#x2F;&#x2F;输出：[    &#123;        &quot;Id&quot;: &quot;7f3589c0b8849a9e1ff52ceb0fcea2390e2731db9d1a7358c2f5fad216a48263&quot;,        &quot;Digest&quot;: &quot;sha256:7822b5ba4c2eaabdd0ff3812277cfafa8a25527d1e234be028ed381a43ad5498&quot;,        &quot;RepoTags&quot;: [            &quot;docker.io&#x2F;1314444&#x2F;test:nginx&quot;,  ......</code></pre><p>总而言之，Podman 使查找、运行、构建和共享容器变得容易。</p><p>配置别名</p><p>如果习惯了使用 Docker 命令，可以直接给 Podman 配置一个别名来实现无缝转移。你只需要在 .bashrc 下加入以下行内容即可：</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# echo &quot;alias docker&#x3D;podman&quot; &gt;&gt; .bashrcsource .bashrc[root@localhost ~]# aliasalias cp&#x3D;&#39;cp -i&#39;alias docker&#x3D;&#39;podman&#39;.......</code></pre><h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a><strong>用户操作</strong></h3><p>在允许没有root特权的用户运行Podman之前，管理员必须安装或构建Podman并完成以下配置</p><p>cgroup V2Linux内核功能允许用户限制普通用户容器可以使用的资源，如果使用cgroupV2启用了运行Podman的Linux发行版，则可能需要更改默认的OCI运行时。某些较旧的版本runc不适用于cgroupV2，必须切换到备用OCI运行时crun。</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# yum -y install crun     &#x2F;&#x2F;centos8系统自带[root@localhost ~]# vi &#x2F;usr&#x2F;share&#x2F;containers&#x2F;containers.conf     446 # Default OCI runtime    447 #     448 runtime &#x3D; &quot;crun&quot;      &#x2F;&#x2F;取消注释并将runc改为crun[root@localhost ~]# podman run -d --name web -p 80:80 docker.io&#x2F;library&#x2F;nginxc8664d2e43c872e1e5219f82d41f63048ed3a5ed4fb6259c225a14d6c243677f[root@localhost ~]# podman inspect web | grep crun        &quot;OCIRuntime&quot;: &quot;crun&quot;,            &quot;crun&quot;,</code></pre><p>安装slirp4netns和fuse-overlayfs</p><p>在普通用户环境中使用Podman时，建议使用fuse-overlayfs而不是VFS文件系统，至少需要版本0.7.6。现在新版本默认就是了。</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# yum -y install slirp4netns[root@localhost ~]# yum -y install fuse-overlayfs[root@localhost ~]# vi &#x2F;etc&#x2F;containers&#x2F;storage.conf77 mount_program &#x3D; &quot;&#x2F;usr&#x2F;bin&#x2F;fuse-overlayfs&quot;     &#x2F;&#x2F;取消注释</code></pre><p>&#x2F; etc &#x2F; subuid和&#x2F; etc &#x2F; subgid配置</p><p>Podman要求运行它的用户在&#x2F; etc &#x2F; subuid和&#x2F; etc &#x2F; subgid文件中列出一系列UID,shadow-utils或newuid包提供这些文件</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# yum -y install shadow-utils可以在&#x2F; etc &#x2F; subuid和&#x2F; etc &#x2F; subgid查看，每个用户的值必须唯一且没有任何重叠。[root@localhost ~]# useradd zz[root@localhost ~]# cat &#x2F;etc&#x2F;subuidzz:100000:65536[root@localhost ~]# cat &#x2F;etc&#x2F;subgidzz:100000:65536&#x2F;&#x2F; 启动非特权ping [root@localhost ~]# sysctl -w &quot;net.ipv4.ping_group_range&#x3D;0 200000&quot; &#x2F;&#x2F;大于100000这个就表示tom可以操作podmannet.ipv4.ping_group_range &#x3D; 0 200000</code></pre><p>这个文件的格式是 USERNAME:UID:RANGE中&#x2F;etc&#x2F;passwd或输出中列出的用户名getpwent。</p><ul><li>为用户分配的初始 UID。</li><li>为用户分配的 UID 范围的大小。</li></ul><p>该usermod程序可用于为用户分配 UID 和 GID，而不是直接更新文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# usermod --add-subuids 200000-201000 --add-subgids 200000-201000 hhgrep hh &#x2F;etc&#x2F;subuid &#x2F;etc&#x2F;subgid&#x2F;etc&#x2F;subuid:hh:200000:1001&#x2F;etc&#x2F;subgid:hh:200000:1001</code></pre><p>用户配置文件</p><p>三个主要的配置文件是<strong>container.conf</strong> 、<strong>storage.conf</strong> 和<strong>r</strong> <strong>egistries.conf</strong> 。用户可以根据需要修改这些文件。</p><p>container.conf</p><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F; 用户配置文件[root@localhost ~]*# cat &#x2F;usr&#x2F;share&#x2F;containers&#x2F;containers.conf*[root@localhost ~]*# cat &#x2F;etc&#x2F;containers&#x2F;containers.conf*[root@localhost ~]*# cat ~&#x2F;.config&#x2F;containers&#x2F;containers.conf &#x2F;&#x2F;优先级最高*</code></pre><p>如果它们以该顺序存在。每个文件都可以覆盖特定字段的前一个文件。</p><p>配置storage.conf文件</p><pre class="language-bash" data-language="bash"><code class="language-bash">1.&#x2F;etc&#x2F;containers&#x2F;storage.conf2.$HOME&#x2F;.config&#x2F;containers&#x2F;storage.conf</code></pre><p>在普通用户中**&#x2F;etc&#x2F;containers&#x2F;storage.conf** 的一些字段将被忽略</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]#  vi &#x2F;etc&#x2F;containers&#x2F;storage.conf[storage]&gt; 推荐下自己做的 Spring Cloud 的实战项目：&gt;&gt; &lt;https:&#x2F;&#x2F;github.com&#x2F;YunaiV&#x2F;onemall&gt;# Default Storage Driver, Must be set for proper operation.driver &#x3D; &quot;overlay&quot;  #此处改为overlay.......mount_program &#x3D; &quot;&#x2F;usr&#x2F;bin&#x2F;fuse-overlayfs&quot;  #取消注释[root@localhost ~]# sysctl user.max_user_namespaces&#x3D;15000  #如果版本为8以下，则需要做以下操作：</code></pre><p>在普通用户中这些字段默认</p><pre class="language-bash" data-language="bash"><code class="language-bash">graphroot&#x3D;&quot;$HOME&#x2F;.local&#x2F;share&#x2F;containers&#x2F;storage&quot;runroot&#x3D;&quot;$XDG_RUNTIME_DIR&#x2F;containers&quot;</code></pre><p>registries.conf</p><p>配置按此顺序读入,这些文件不是默认创建的,可以从&#x2F;usr&#x2F;share&#x2F;containers 或复制文件&#x2F;etc&#x2F;containers并进行修改。</p><pre class="language-bash" data-language="bash"><code class="language-bash">1.&#x2F;etc&#x2F;containers&#x2F;registries.conf2.&#x2F;etc&#x2F;containers&#x2F;registries.d&#x2F;*3.HOME&#x2F;.config&#x2F;containers&#x2F;registries.conf</code></pre><p>授权文件</p><p>此文件里面写了docker账号的密码，以加密方式显示</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# podman loginUsername: 1314444Password: Login Succeeded![root@localhost ~]# cat &#x2F;run&#x2F;user&#x2F;0&#x2F;containers&#x2F;auth.json &#123;        &quot;auths&quot;: &#123;                &quot;registry.fedoraproject.org&quot;: &#123;                        &quot;auth&quot;: &quot;MTMxNDQ0NDpIMjAxNy0xOA&#x3D;&#x3D;&quot;                &#125;        &#125;&#125;</code></pre><p>普通用户是无法看见root用户的镜像的</p><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F;root用户[root@localhost ~]# podman imagesREPOSITORY                  TAG      IMAGE ID       CREATED       SIZEdocker.io&#x2F;library&#x2F;httpd     latest   ea28e1b82f31   11 days ago   146 MB&#x2F;&#x2F;普通用户[root@localhost ~]# su - zz[zz@localhost ~]$ podman imagesREPOSITORY  TAG         IMAGE ID    CREATED     SIZE</code></pre><h3 id="卷"><a href="#卷" class="headerlink" title="卷"></a><strong>卷</strong></h3><ul><li>容器与root用户一起运行，则root容器中的用户实际上就是主机上的用户。</li><li>UID GID是在&#x2F;etc&#x2F;subuid和&#x2F;etc&#x2F;subgid等中用户映射中指定的第一个UID GID。</li><li>如果普通用户的身份从主机目录挂载到容器中，并在该目录中以根用户身份创建文件，则会看到它实际上是你的用户在主机上拥有的。</li></ul><p>使用卷</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# su - zz[zz@localhost ~]$ pwd&#x2F;home&#x2F;zz[zz@localhost ~]$ mkdir &#x2F;home&#x2F;zz&#x2F;data[zz@localhost ~]$ podman run -it -v &quot;$(pwd)&quot;&#x2F;data:&#x2F;data docker.io&#x2F;library&#x2F;busybox &#x2F;bin&#x2F;shTrying to pull docker.io&#x2F;library&#x2F;busybox:latest...Getting image source signaturesCopying blob 3cb635b06aa2 done  Copying config ffe9d497c3 done  Writing manifest to image destinationStoring signatures&#x2F; # lsbin   data  dev   etc   home  proc  root  run   sys   tmp   usr   var&#x2F; # cd data&#x2F;&#x2F;data # ls&#x2F;data # touch 123&#x2F;data # ls -ltotal 0-rw-r--r--    1 root     root             0 Dec 13 00:17 123</code></pre><p>在主机上查看</p><pre class="language-bash" data-language="bash"><code class="language-bash">[zz@localhost ~]$ ll data&#x2F;总用量 0-rw-r--r-- 1 zz zz 0 12月 13 00:17 123&#x2F;&#x2F;写入文件[zz@localhost ~]$ echo &quot;hell world&quot; &gt;&gt; 123[zz@localhost ~]$ cat 123hell world</code></pre><p>容器里查看</p><pre class="language-bash" data-language="bash"><code class="language-bash">&#x2F;data # cat 123hell world&#x2F;&#x2F;我们可以发现在容器里面的文件的属主和属组都属于root，那么如何才能让其属于tom用户呢？下面告诉你答案&#x2F;data # ls -ltotal 4-rw-rw-r--    1 root     root            12 Dec 13 00:20 123&#x2F;&#x2F;只要在运行容器的时候加上一个--userns&#x3D;keep-id即可。[zz@localhost ~]$ podman run -it --name test -v &quot;$(pwd)&quot;&#x2F;data:&#x2F;data --userns&#x3D;keep-id docker.io&#x2F;library&#x2F;busybox &#x2F;bin&#x2F;sh~ $ cd data&#x2F;&#x2F;data $ ls -ltotal 4-rw-r--r--    1 zz       zz              11 Dec 13 00:21 123</code></pre><p>使用普通用户映射容器端口时会报“ permission denied”的错误</p><pre class="language-bash" data-language="bash"><code class="language-bash">[zz@localhost ~]$ podman run  -d -p 80:80 httpdError: rootlessport cannot expose privileged port 80, you can add &#39;net.ipv4.ip_unprivileged_port_start&#x3D;80&#39; to &#x2F;etc&#x2F;sysctl.conf (currently 1024), or choose a larger port number (&gt;&#x3D; 1024): listen tcp 0.0.0.0:80: bind: permission denied</code></pre><p>普通用户可以映射&gt;&#x3D; 1024的端口</p><pre class="language-bash" data-language="bash"><code class="language-bash">[zz@localhost ~]$ podman run  -d -p 1024:80 httpd58613a6bdc70d4d4f9f624583f795a62a610596d166f0873bdff8fb26aa15092[zz@localhost ~]$ ss -anltState       Recv-Q      Send-Q           Local Address:Port           Peer Address:Port      Process      LISTEN      0           128                    0.0.0.0:22                  0.0.0.0:*                      LISTEN      0           128                          *:1024                      *:*                      LISTEN      0           128                       [::]:22                     [::]:* </code></pre><p>配置echo ‘net.ipv4.ip_unprivileged_port_start&#x3D;80’ &gt;&gt; &#x2F;etc&#x2F;sysctl.conf后可以映射大于等于80的端口</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# echo  &#39;net.ipv4.ip_unprivileged_port_start&#x3D;80&#39;  &gt;&gt; &#x2F;etc&#x2F;sysctl.conf[root@localhost ~]# sysctl -pnet.ipv4.ip_unprivileged_port_start &#x3D; 80[zz@localhost ~]$ podman run -d -p 80:80 httpd1215455a0c300d78e7bf6afaefc9873f818c6b0f26affeee4e2bc17954e72d8e[zz@localhost ~]$ ss -anltState       Recv-Q      Send-Q           Local Address:Port           Peer Address:Port      Process      LISTEN      0           128                    0.0.0.0:22                  0.0.0.0:*                      LISTEN      0           128                          *:1024                      *:*                      LISTEN      0           128                          *:80                        *:*                      LISTEN      0           128                       [::]:22                     [::]:*  </code></pre><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>Podman网络操作与Docker类似，但也有一些不同之处。以下是一些常见的Podman网络操作：</p><p>创建网络：可以使用<code>podman network create</code>命令创建一个新的网络。例如，创建一个名为<code>my-network</code>的桥接网络：</p><pre class="language-bash" data-language="bash"><code class="language-bash">podman network create my-network --driver bridge</code></pre><p>查看网络：可以使用<code>podman network ls</code>命令查看所有可用的网络。</p><p>连接容器到网络：可以使用<code>--network</code>选项将容器连接到指定的网络。例如，将名为<code>my-container</code>的容器连接到<code>my-network</code>网络：</p><pre class="language-bash" data-language="bash"><code class="language-bash">podman run --name my-container --network my-network -d my-image</code></pre><p>断开容器与网络的连接：可以使用<code>podman network disconnect</code>命令将容器与网络断开连接。例如，将名为<code>my-container</code>的容器与<code>my-network</code>网络断开连接：</p><pre class="language-bash" data-language="bash"><code class="language-bash">podman network disconnect my-network my-container</code></pre><p>删除网络：可以使用<code>podman network rm</code>命令删除指定的网络。例如，删除名为<code>my-network</code>的网络：</p><pre class="language-bash" data-language="bash"><code class="language-bash">podman network rm my-network</code></pre><p>这些是一些常见的Podman网络操作，您可以根据您的具体需求和环境来使用它们。</p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> Podman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见品牌电脑与服务器BIOS快捷键大全</title>
      <link href="/32ad5fca.html"/>
      <url>/32ad5fca.html</url>
      
        <content type="html"><![CDATA[<p>在维护和管理台式电脑、笔记本电脑和服务器时，进入BIOS设置是一个常见的需求。BIOS（Basic Input&#x2F;Output System）是一种固件，它提供了计算机硬件与操作系统之间的底层通信。不同品牌的设备通常使用不同的快捷键进入BIOS设置界面。在本篇博客中，我们将介绍一些常见品牌电脑和服务器中进入BIOS的快捷键，方便您在需要时快速操作。</p><h2 id="台式电脑"><a href="#台式电脑" class="headerlink" title="台式电脑"></a>台式电脑</h2><h3 id="Dell"><a href="#Dell" class="headerlink" title="Dell"></a>Dell</h3><ul><li>F2：大多数戴尔台式电脑使用此快捷键进入BIOS设置。开机后，持续按下F2键直到出现BIOS界面。</li></ul><h3 id="HP"><a href="#HP" class="headerlink" title="HP"></a>HP</h3><ul><li>F10：通常，惠普台式电脑使用F10键进入BIOS。重启电脑，按下F10键直到BIOS配置屏幕出现。</li></ul><h3 id="Lenovo"><a href="#Lenovo" class="headerlink" title="Lenovo"></a>Lenovo</h3><ul><li>F1或F2：联想台式电脑中，F1或F2键可用于进入BIOS。一般情况下，开机后按下F1或F2键即可。</li></ul><h3 id="Acer"><a href="#Acer" class="headerlink" title="Acer"></a>Acer</h3><ul><li>Del或F2：大部分Acer台式电脑可以通过按Delete键或F2键进入BIOS。启动电脑后迅速按下相应键。</li></ul><h2 id="笔记本电脑"><a href="#笔记本电脑" class="headerlink" title="笔记本电脑"></a>笔记本电脑</h2><h3 id="Asus"><a href="#Asus" class="headerlink" title="Asus"></a>Asus</h3><ul><li>F2：华硕笔记本电脑使用F2键进入BIOS设置。开机后按下F2键，直到BIOS界面出现。</li></ul><h3 id="Lenovo-1"><a href="#Lenovo-1" class="headerlink" title="Lenovo"></a>Lenovo</h3><ul><li>F1或F2：联想笔记本电脑中，F1或F2键可以用于进入BIOS设置。重启电脑后按下相应键。</li></ul><h3 id="HP-1"><a href="#HP-1" class="headerlink" title="HP"></a>HP</h3><ul><li>Esc或F10：大多数惠普笔记本电脑使用Esc或F10键进入BIOS设置。开机后迅速按下相应键即可。</li></ul><h3 id="Dell-1"><a href="#Dell-1" class="headerlink" title="Dell"></a>Dell</h3><ul><li>F2：戴尔笔记本电脑通常使用F2键进入BIOS设置。开机后按下F2键直到BIOS界面出现。</li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="HP-ProLiant"><a href="#HP-ProLiant" class="headerlink" title="HP ProLiant"></a>HP ProLiant</h3><ul><li>F9：惠普ProLiant服务器使用F9键进入系统设置。重启服务器后按下F9键即可进入BIOS配置。</li></ul><h3 id="Dell-PowerEdge"><a href="#Dell-PowerEdge" class="headerlink" title="Dell PowerEdge"></a>Dell PowerEdge</h3><ul><li>F2：戴尔PowerEdge服务器使用F2键进入BIOS设置。开机后按下F2键直到出现BIOS界面。</li></ul><h3 id="IBM-x2F-Lenovo-System-x"><a href="#IBM-x2F-Lenovo-System-x" class="headerlink" title="IBM&#x2F;Lenovo System x"></a>IBM&#x2F;Lenovo System x</h3><ul><li>F1：IBM&#x2F;Lenovo System x服务器可以通过按F1键进入BIOS设置。重启服务器后按下F1键即可。</li></ul><p>注意事项：</p><ul><li>不同的电脑型号和硬件配置可能会有所不同，以上快捷键仅适用于常见品牌的设备。</li><li>在进入BIOS设置之前，请确保您知道自己要做什么，并小心操作。不正确的设置可能会导致系统不稳定或无法启动。</li></ul><p>这里仅列出了一些常见品牌的快捷键，其他品牌或特定型号可能会有所不同。如果您使用的是其他品牌的设备，请查阅相关手册或官方支持文档获取更多信息。</p><p>希望这篇博客对您有所帮助！如果您有更多关于硬件运维或其他技术问题，欢迎随时向我咨询。祝您管理和维护设备顺利！</p>]]></content>
      
      
      <categories>
          
          <category> IT科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BIOS </tag>
            
            <tag> 硬件内容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区分机械、固态和M2</title>
      <link href="/c74dd02.html"/>
      <url>/c74dd02.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何快速从型号上鉴别电脑硬盘是机械、固态和M2"><a href="#如何快速从型号上鉴别电脑硬盘是机械、固态和M2" class="headerlink" title="如何快速从型号上鉴别电脑硬盘是机械、固态和M2"></a>如何快速从型号上鉴别电脑硬盘是机械、固态和M2</h1><ol><li><p>机械硬盘：<br><img src="/../images/hhd.png" alt="机械硬盘"><br>机械硬盘的型号通常以“HDD”（Hard Disk Drive）结尾，例如“Seagate Barracuda 2TB HDD”。</p></li><li><p>固态硬盘：</p></li></ol><p>固态硬盘的型号通常以“SSD”（Solid State Drive）结尾，例如“Samsung 860 EVO 1TB SSD”。<br><img src="/../images/ssd.png" alt="固态硬盘"></p><ol start="3"><li>M2硬盘：</li></ol><p>M2硬盘的型号通常以“M.2”结尾，例如“WD Blue 1TB M.2 2280 Internal SSD”。<br><img src="/../images/m2.png" alt="M2硬盘"></p><p>通过硬盘型号的后缀，可以快速鉴别电脑硬盘是机械、固态还是M2硬盘。</p>]]></content>
      
      
      <categories>
          
          <category> IT科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电脑硬件 </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑优化的方法</title>
      <link href="/85378675.html"/>
      <url>/85378675.html</url>
      
        <content type="html"><![CDATA[<h1 id="电脑卡的原因和优化方法"><a href="#电脑卡的原因和优化方法" class="headerlink" title="电脑卡的原因和优化方法"></a>电脑卡的原因和优化方法</h1><p>电脑卡的原因可能有很多，比如系统过于老旧、软件冲突、病毒感染等等。以下是一些电脑优化的基本方法：</p><ol><li><p>清理垃圾文件：使用系统自带的磁盘清理工具或第三方清理软件，清理系统中的垃圾文件，释放硬盘空间。</p></li><li><p>卸载不必要的软件：卸载不常用或不必要的软件，减少系统负担。</p></li><li><p>更新系统和驱动程序：更新系统和驱动程序可以修复一些已知的问题和漏洞，提高系统的稳定性和性能。</p></li><li><p>关闭不必要的启动项：在系统启动时，关闭不必要的启动项，减少系统启动时间和资源占用。</p></li><li><p>安装杀毒软件：安装杀毒软件可以保护系统免受病毒和恶意软件的攻击，提高系统的安全性和稳定性。</p></li><li><p>清理注册表：使用注册表清理工具清理系统中的无效注册表项，提高系统的稳定性和性能。</p></li><li><p>增加内存：如果电脑配置较低，可以考虑增加内存，提高系统的运行速度和稳定性。</p></li><li><p>优化硬盘：使用硬盘优化工具对硬盘进行优化，提高硬盘读写速度和稳定性。</p></li><li><p>关闭特效：关闭系统特效可以减少系统资源占用，提高系统的运行速度和稳定性。</p></li><li><p>定期清理系统：定期清理系统中的临时文件、缓存文件等，保持系统的清洁和稳定。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> IT科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 系统优化 </tag>
            
            <tag> Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础环境安装教程</title>
      <link href="/74b57a6d.html"/>
      <url>/74b57a6d.html</url>
      
        <content type="html"><![CDATA[<p>好的，以下是使用Markdown方式写Python环境安装和Pycharm环境安装的教程，并附带图片，图片也使用Markdown方式进行显示。</p><h1 id="Python环境安装和Pycharm环境安装"><a href="#Python环境安装和Pycharm环境安装" class="headerlink" title="Python环境安装和Pycharm环境安装"></a>Python环境安装和Pycharm环境安装</h1><h2 id="Python环境安装"><a href="#Python环境安装" class="headerlink" title="Python环境安装"></a>Python环境安装</h2><ol><li>打开Python官网：<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></li><li>在下载页面中，选择适合你操作系统的Python版本，点击下载。<br><img src="/../images/pythonversion.jpg" alt="Python下载页面"></li><li>下载完成后，双击安装程序，按照提示进行安装。</li><li>在安装过程中，记得勾选“Add Python to PATH”选项，这样可以方便在命令行中使用Python。<br><img src="/../images/pythonpath.jpg" alt="Python安装页面"></li><li>安装完成后，打开命令行，输入<code>python</code>，如果出现以下信息，则说明Python环境已经安装成功。<pre class="language-none"><code class="language-none">Python 3.9.0 (tags&#x2F;v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32</code></pre></li></ol><h2 id="Pycharm环境安装"><a href="#Pycharm环境安装" class="headerlink" title="Pycharm环境安装"></a>Pycharm环境安装</h2><ol><li>打开Pycharm官网：<a href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a></li><li>在下载页面中，选择适合你操作系统的Pycharm版本，点击下载。<br><img src="/../images/pycharmd.png" alt="Pycharm下载页面"></li><li>下载完成后，双击安装程序，按照提示进行安装。</li><li>在安装过程中，可以选择安装的组件，也可以使用默认设置。<br><img src="/../images/pycharmpath.png" alt="Pycharm安装页面"></li><li>安装完成后，打开Pycharm，选择创建一个新项目，或者打开一个已有的项目。<br><img src="/../images/pythonpro.png" alt="Pycharm主界面"></li></ol><p>至此，Python环境和Pycharm环境已经安装完成。可以开始愉快的Python编程啦！</p>]]></content>
      
      
      <categories>
          
          <category> 编程教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小爱音箱智能家居控制</title>
      <link href="/4a08a452.html"/>
      <url>/4a08a452.html</url>
      
        <content type="html"><![CDATA[<p>小爱音箱是一款智能音箱，可以通过语音控制智能家居设备。以下是小爱音箱智能家居控制的介绍：</p><h2 id="支持的智能家居设备"><a href="#支持的智能家居设备" class="headerlink" title="支持的智能家居设备"></a>支持的智能家居设备</h2><p>小爱音箱支持多种智能家居设备，包括但不限于：</p><ul><li>灯光设备：如智能灯泡、智能灯带等；</li><li>空调设备：如智能空调、智能风扇等；</li><li>家电设备：如智能电视、智能音响等；</li><li>安防设备：如智能门锁、智能摄像头等；</li><li>其他设备：如智能窗帘、智能插座等。<br><img src="/../images/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85.png" alt="image"></li></ul><h2 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h2><p>小爱音箱可以通过语音控制智能家居设备，也可以通过小爱同学App进行控制。以下是具体的控制方式：</p><h3 id="语音控制"><a href="#语音控制" class="headerlink" title="语音控制"></a>语音控制</h3><p>用户可以通过语音控制小爱音箱，例如：</p><ul><li>“小爱同学，打开卧室的灯。”</li><li>“小爱同学，关闭客厅的电视。”</li><li>“小爱同学，调高客厅的温度。”</li></ul><h3 id="小爱同学App控制"><a href="#小爱同学App控制" class="headerlink" title="小爱同学App控制"></a>小爱同学App控制</h3><p>用户可以通过小爱同学App进行智能家居设备的控制，例如：</p><ul><li>在App中添加智能家居设备；</li><li>在App中设置智能家居设备的定时开关；</li><li>在App中查看智能家居设备的使用记录。<br><img src="/../images/xiaomiapp.jpg" alt="image"></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小爱音箱是一款智能音箱，可以通过语音控制智能家居设备。用户可以通过语音控制或者小爱同学App进行控制，支持多种智能家居设备。</p>]]></content>
      
      
      <categories>
          
          <category> IT科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小米 </tag>
            
            <tag> 智能家居 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp内容穿透后台启动</title>
      <link href="/fe1704c8.html"/>
      <url>/fe1704c8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Frp后台自动启动的几个方法"><a href="#Frp后台自动启动的几个方法" class="headerlink" title="Frp后台自动启动的几个方法"></a>Frp后台自动启动的几个方法</h1><p>本文介绍了在Linux和Windows系统中实现Frp后台自动启动的几种方法。</p><h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><h3 id="方法一：使用nohup来启动"><a href="#方法一：使用nohup来启动" class="headerlink" title="方法一：使用nohup来启动"></a>方法一：使用nohup来启动</h3><p>使用nohup命令可以在后台启动Frp，具体步骤如下：</p><ol><li>打开终端，输入以下命令启动frps：</li></ol><pre class="language-none"><code class="language-none">nohup &#x2F;path&#x2F;to&#x2F;your&#x2F;fprs -c-c &#x2F;path&#x2F;to&#x2F;your&#x2F;frps.ini &amp;</code></pre><ol start="2"><li>如果要查看日志，可以使用以下命令：</li></ol><pre class="language-none"><code class="language-none">cat nohup.out</code></pre><ol start="3"><li>同样的，使用以下命令启动frpc：</li></ol><pre class="language-none"><code class="language-none">nohup &#x2F;path&#x2F;to&#x2F;your&#x2F;fprc -c-c &#x2F;path&#x2F;to&#x2F;your&#x2F;frpc.ini &amp;</code></pre><h3 id="方法二：使用systemctl来控制启动"><a href="#方法二：使用systemctl来控制启动" class="headerlink" title="方法二：使用systemctl来控制启动"></a>方法二：使用systemctl来控制启动</h3><p>使用systemctl命令可以方便地控制Frp的启动和停止，具体步骤如下：</p><ol><li>在<code>/lib/systemd/system/frps.service</code>文件中写入以下内容：</li></ol><pre class="language-none"><code class="language-none">[Unit]Description&#x3D;fraps serviceAfter&#x3D;network.target syslog.targetWants&#x3D;network.target[Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;your&#x2F;path&#x2F;frps -c &#x2F;your&#x2F;path&#x2F;frps.ini[Install]WantedBy&#x3D;multi-user.target</code></pre><ol start="2"><li>启动frps：</li></ol><pre class="language-none"><code class="language-none">sudo systemctl start frps</code></pre><ol start="3"><li>打开自启动：</li></ol><pre class="language-none"><code class="language-none">sudo systemctl enable frps</code></pre><ol start="4"><li>重启应用：</li></ol><pre class="language-none"><code class="language-none">sudo systemctl restart frps</code></pre><ol start="5"><li>停止应用：</li></ol><pre class="language-none"><code class="language-none">sudo systemctl stop frps</code></pre><ol start="6"><li>查看应用的日志：</li></ol><pre class="language-none"><code class="language-none">sudo systemctl status frps</code></pre><h3 id="方法三：使用supervisor来控制"><a href="#方法三：使用supervisor来控制" class="headerlink" title="方法三：使用supervisor来控制"></a>方法三：使用supervisor来控制</h3><p>使用supervisor可以方便地控制Frp的启动和停止，具体步骤如下：</p><ol><li>安装supervisor：</li></ol><pre class="language-none"><code class="language-none">sudo apt install supervisor</code></pre><ol start="2"><li>在<code>/etc/supervisor/conf.d</code>目录下创建<code>frp.conf</code>文件，写入以下内容：</li></ol><pre class="language-none"><code class="language-none">[program:frp]command &#x3D; &#x2F;your&#x2F;path&#x2F;frps -c &#x2F;your&#x2F;path&#x2F;frps.iniautostart &#x3D; true</code></pre><ol start="3"><li>重新加载supervisor：</li></ol><pre class="language-none"><code class="language-none">sudo systemctl restart supervisor</code></pre><ol start="4"><li>查看supervisor运行状态：</li></ol><pre class="language-none"><code class="language-none">sudo supervisorctl status</code></pre><h2 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h2><h3 id="方法一：使用任务计划程序"><a href="#方法一：使用任务计划程序" class="headerlink" title="方法一：使用任务计划程序"></a>方法一：使用任务计划程序</h3><p>使用任务计划程序可以实现Frp开机自启，具体步骤如下：</p><ol><li>打开任务计划程序，点击“创建任务”按钮。</li><li>输入任务名称，选择“使用最高权限运行”选项卡，然后选择“配置为Windows 7、Windows Server 2008 R2”。</li><li>在“触发器”选项卡中，选择“开机时”作为触发器。</li><li>在“操作”选项卡中，输入Frp的启动命令，比如：</li></ol><pre class="language-none"><code class="language-none">C:\frp\frpc.exe -c C:\frp\frpc.ini</code></pre><ol start="5"><li>点击“确定”按钮，保存任务。</li></ol><h3 id="方法二：使用注册表"><a href="#方法二：使用注册表" class="headerlink" title="方法二：使用注册表"></a>方法二：使用注册表</h3><p>使用注册表可以实现Frp开机自启，具体步骤如下：</p><ol><li>按下Win+R键，打开运行对话框，输入“regedit”打开注册表编辑器。</li><li>找到以下路径：</li></ol><pre class="language-none"><code class="language-none">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code></pre><ol start="3"><li>在右侧窗口中，右键点击空白处，选择“新建”-&gt;“字符串值”。</li><li>输入一个名称，比如“Frp”，然后双击该项，输入Frp的启动命令，比如：</li></ol><pre class="language-none"><code class="language-none">C:\frp\frpc.exe -c C:\frp\frpc.ini</code></pre><ol start="5"><li>关闭注册表编辑器，重启电脑，Frp客户端就会自动启动了。</li></ol><p>以上是在Linux和Windows系统中实现Frp后台自动启动的几种方法。</p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> frp </tag>
            
            <tag> win </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门Ansible</title>
      <link href="/4f3a6d14.html"/>
      <url>/4f3a6d14.html</url>
      
        <content type="html"><![CDATA[<h3 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h3><ul><li>运维自动化发展历程及技术应用</li><li>Ansible命令使用</li><li>Ansible常用模块详解</li><li>YAML语法简介</li><li>Ansible playbook基础</li><li>Playbook变量、tags、handlers使用</li><li>Playbook模板templates</li><li>Playbook条件判断 when</li><li>Playbook字典 with_items</li><li>Ansible Roles</li></ul><h3 id="运维自动化发展历程及技术应用"><a href="#运维自动化发展历程及技术应用" class="headerlink" title="运维自动化发展历程及技术应用"></a>运维自动化发展历程及技术应用</h3><p><img src="/../images/%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="image"></p><h3 id="企业实际应用场景分析"><a href="#企业实际应用场景分析" class="headerlink" title="企业实际应用场景分析"></a>企业实际应用场景分析</h3><pre class="language-none"><code class="language-none">Dev开发环境    使用者：程序员    功能：程序员开发软件，测试BUG的环境    管理者：程序员测试环境        使用者：QA测试工程师    功能：测试经过Dev环境测试通过的软件的功能    管理者：运维说明：测试环境往往有多套,测试环境满足测试功能即可，不宜过多1、测试人员希望测试环境有多套,公司的产品多产品线并发，即多个版本，意味着多个版本同步测试2、通常测试环境有多少套和产品线数量保持一样发布环境：代码发布机，有些公司为堡垒机（安全屏障）    使用者：运维    功能：发布代码至生产环境    管理者：运维（有经验）    发布机：往往需要有2台（主备）生产环境    使用者：运维，少数情况开放权限给核心开发人员，极少数公司将权限完全    开放给开发人员并其维护    功能：对用户提供公司产品的服务管理者：只能是运维    生产环境服务器数量：一般比较多，且应用非常重要。往往需要自动工具协助部署配置应用灰度环境（生产环境的一部分）    使用者：运维    功能：在全量发布代码前将代码的功能面向少量精准用户发布的环境,可基    于主机或用户执行灰度发布    案例：共100台生产服务器，先发布其中的10台服务器，这10台服务器就是灰度服务器    管理者：运维    灰度环境：往往该版本功能变更较大，为保险起见特意先让一部分用户优化体验该功能，              待这部分用户使用没有重大问题的时候，再全量发布至所有服务器</code></pre><h3 id="程序发布"><a href="#程序发布" class="headerlink" title="程序发布"></a>程序发布</h3><pre class="language-none"><code class="language-none">程序发布要求：    不能导致系统故障或造成系统完全不可用    不能影响用户体验预发布验证：    新版本的代码先发布到服务器（跟线上环境配置完全相同，只是未接入到调度器）灰度发布：    基于主机，用户，业务发布路径：    &#x2F;webapp&#x2F;tuangou    &#x2F;webapp&#x2F;tuangou-1.1    &#x2F;webapp&#x2F;tuangou-1.2发布过程：在调度器上下线一批主机(标记为maintanance状态) --&gt; 关闭服务 --&gt;          部署新版本的应用程序 --&gt; 启动服务 --&gt; 在调度器上启用这一批服务器自动化灰度发布：脚本、发布平台</code></pre><h3 id="运维自动化发展历程及技术应用-1"><a href="#运维自动化发展历程及技术应用-1" class="headerlink" title="运维自动化发展历程及技术应用"></a>运维自动化发展历程及技术应用</h3><p><img src="/../images/skill.png" alt="image"></p><h3 id="自动化运维应用场景"><a href="#自动化运维应用场景" class="headerlink" title="自动化运维应用场景"></a>自动化运维应用场景</h3><pre class="language-none"><code class="language-none">文件传输应用部署配置管理任务流编排</code></pre><h3 id="常用自动化运维工具"><a href="#常用自动化运维工具" class="headerlink" title="常用自动化运维工具"></a>常用自动化运维工具</h3><pre class="language-none"><code class="language-none">Ansible：python，Agentless，中小型应用环境Saltstack：python，一般需部署agent，执行效率更高Puppet：ruby, 功能强大，配置复杂，重型,适合大型环境Fabric：python，agentlessChef：ruby，国内应用少Cfenginefunc</code></pre><h3 id="企业级自动化运维工具应用实战ansible"><a href="#企业级自动化运维工具应用实战ansible" class="headerlink" title="企业级自动化运维工具应用实战ansible"></a>企业级自动化运维工具应用实战ansible</h3><pre class="language-none"><code class="language-none">公司计划在年底做一次大型市场促销活动，全面冲刺下交易额，为明年的上市做准备。公司要求各业务组对年底大促做准备，运维部要求所有业务容量进行三倍的扩容，并搭建出多套环境可以共开发和测试人员做测试，运维老大为了在年底有所表现，要求运维部门同学尽快实现，当你接到这个任务时，有没有更快的解决方案？</code></pre><h3 id="Ansible发展史"><a href="#Ansible发展史" class="headerlink" title="Ansible发展史"></a>Ansible发展史</h3><pre class="language-none"><code class="language-none">AnsibleMichael DeHaan（ Cobbler 与 Func 作者）名称来自《安德的游戏》中跨越时空的即时通信工具2012-03-09，发布0.0.1版，2015-10-17，Red Hat宣布收购官网：https:&#x2F;&#x2F;www.ansible.com&#x2F;官方文档：https:&#x2F;&#x2F;docs.ansible.com&#x2F;同类自动化工具GitHub关注程度（2016-07-10）</code></pre><p><img src="/../images/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7.png" alt="image"></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><pre class="language-none"><code class="language-none">1&gt; 模块化：调用特定的模块，完成特定任务2&gt; Paramiko（python对ssh的实现），PyYAML，Jinja2（模板语言）三个关键模块3&gt; 支持自定义模块4&gt; 基于Python语言实现5&gt; 部署简单，基于python和SSH(默认已安装)，agentless6&gt; 安全，基于OpenSSH7&gt; 支持playbook编排任务8&gt; 幂等性：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况9&gt; 无需代理不依赖PKI（无需ssl）10&gt; 可使用任何编程语言写模块11&gt; YAML格式，编排任务，支持丰富的数据结构12&gt; 较强大的多层解决方案</code></pre><h3 id="Ansible架构"><a href="#Ansible架构" class="headerlink" title="Ansible架构"></a>Ansible架构</h3><p><img src="/../images/Ansible%E6%9E%B6%E6%9E%84.png" alt="image"></p><pre class="language-none"><code class="language-none">ansible的作用以及工作结构1、ansible简介：ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。主要包括：    (1)、连接插件connection plugins：负责和被监控端实现通信；    (2)、host inventory：指定操作的主机，是一个配置文件里面定义监控的主机；    (3)、各种模块核心模块、command模块、自定义模块；    (4)、借助于插件完成记录日志邮件等功能；    (5)、playbook：剧本执行多个任务时，非必需可以让节点一次性运行多个任务。2、ansible的架构：连接其他主机默认使用ssh协议</code></pre><h3 id="Ansible工作原理"><a href="#Ansible工作原理" class="headerlink" title="Ansible工作原理"></a>Ansible工作原理</h3><p><img src="/../images/Ansible%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="image"></p><h3 id="Ansible主要组成部分"><a href="#Ansible主要组成部分" class="headerlink" title="Ansible主要组成部分"></a>Ansible主要组成部分</h3><pre class="language-none"><code class="language-none">ANSIBLE PLAYBOOKS：任务剧本（任务集），编排定义Ansible任务集的配置文件，                   由Ansible顺序依次执行，通常是JSON格式的YML文件INVENTORY：Ansible管理主机的清单  &#x2F;etc&#x2F;anaible&#x2F;hostsMODULES：  Ansible执行命令的功能模块，多数为内置核心模块，也可自定义PLUGINS：  模块功能的补充，如连接类型插件、循环插件、变量插件、过滤插件等，该功能不常用API：      供第三方程序调用的应用程序编程接口 ANSIBLE：  组合INVENTORY、API、MODULES、PLUGINS的绿框，可以理解为是ansible命令工具，其为核心执行工具</code></pre><pre class="language-none"><code class="language-none">Ansible命令执行来源：    1&gt; USER，普通用户，即SYSTEM ADMINISTRATOR    2&gt; CMDB（配置管理数据库） API 调用    3&gt; PUBLIC&#x2F;PRIVATE CLOUD API调用  (公有私有云的API接口调用)    4&gt; USER-&gt; Ansible Playbook -&gt; Ansibile利用ansible实现管理的方式：    1&gt; Ad-Hoc 即ansible单条命令，主要用于临时命令使用场景    2&gt; Ansible-playbook 主要用于长期规划好的，大型项目的场景，需要有前期的规划过程</code></pre><pre class="language-none"><code class="language-none">Ansible-playbook（剧本）执行过程    将已有编排好的任务集写入Ansible-Playbook    通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行Ansible主要操作对象   HOSTS主机   NETWORKING网络设备注意事项:   执行ansible的主机一般称为主控端，中控，master或堡垒机   主控端Python版本需要2.6或以上   被控端Python版本小于2.4需要安装python-simplejson   被控端如开启SELinux需要安装libselinux-python   windows不能做为主控端   ansible不是服务,不会一直启动,只是需要的时候启动</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class="language-none"><code class="language-none">rpm包安装: EPEL源    yum install ansible编译安装:    yum -y install python-jinja2 PyYAML python-paramiko python-babel    python-crypto    tar xf ansible-1.5.4.tar.gz    cd ansible-1.5.4    python setup.py build    python setup.py install    mkdir &#x2F;etc&#x2F;ansible    cp -r examples&#x2F;* &#x2F;etc&#x2F;ansibleGit方式:    git clone git:&#x2F;&#x2F;github.com&#x2F;ansible&#x2F;ansible.git --recursive    cd .&#x2F;ansible    source .&#x2F;hacking&#x2F;env-setuppip安装： pip是安装Python包的管理器，类似yum    yum install python-pip python-devel    yum install gcc glibc-devel zibl-devel rpm-bulid openssl-devel    pip install --upgrade pip    pip install ansible --upgrade确认安装：    ansible --version</code></pre><h3 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h3><pre class="language-none"><code class="language-none">配置文件    &#x2F;etc&#x2F;ansible&#x2F;ansible.cfg  主配置文件,配置ansible工作特性(一般无需修改)    &#x2F;etc&#x2F;ansible&#x2F;hosts        主机清单(将被管理的主机放到此文件)    &#x2F;etc&#x2F;ansible&#x2F;roles&#x2F;       存放角色的目录程序    &#x2F;usr&#x2F;bin&#x2F;ansible          主程序，临时命令执行工具    &#x2F;usr&#x2F;bin&#x2F;ansible-doc      查看配置文档，模块功能查看工具    &#x2F;usr&#x2F;bin&#x2F;ansible-galaxy   下载&#x2F;上传优秀代码或Roles模块的官网平台    &#x2F;usr&#x2F;bin&#x2F;ansible-playbook 定制自动化任务，编排剧本工具    &#x2F;usr&#x2F;bin&#x2F;ansible-pull     远程执行命令的工具    &#x2F;usr&#x2F;bin&#x2F;ansible-vault    文件加密工具    &#x2F;usr&#x2F;bin&#x2F;ansible-console  基于Console界面与用户交互的执行工具</code></pre><h3 id="主机清单inventory"><a href="#主机清单inventory" class="headerlink" title="主机清单inventory"></a>主机清单inventory</h3><pre class="language-none"><code class="language-none">Inventory 主机清单1&gt; ansible的主要功用在于批量主机操作，为了便捷地使用其中的部分主机，可以在inventory file中将其分组命名 2&gt; 默认的inventory file为&#x2F;etc&#x2F;ansible&#x2F;hosts3&gt; inventory file可以有多个，且也可以通过Dynamic Inventory来动态生成&#x2F;etc&#x2F;ansible&#x2F;hosts文件格式inventory文件遵循INI文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；此外，当如若目标主机使用了非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来标明    ntp.magedu.com   不分组,直接加        [webservers]     webservers组    www1.magedu.com:2222  可以指定端口    www2.magedu.com        [dbservers]    db1.magedu.com    db2.magedu.com    db3.magedu.com如果主机名称遵循相似的命名模式，还可以使用列表的方式标识各主机示例：    [websrvs]    www[1:100].example.com   ip: 1-100        [dbsrvs]    db-[a:f].example.com     dba-dbff</code></pre><h3 id="ansible-配置文件"><a href="#ansible-配置文件" class="headerlink" title="ansible 配置文件"></a>ansible 配置文件</h3><pre class="language-none"><code class="language-none">Ansible 配置文件&#x2F;etc&#x2F;ansible&#x2F;ansible.cfg （一般保持默认）vim &#x2F;etc&#x2F;ansible&#x2F;ansible.cfg[defaults]#inventory     &#x3D; &#x2F;etc&#x2F;ansible&#x2F;hosts      # 主机列表配置文件#library       &#x3D; &#x2F;usr&#x2F;share&#x2F;my_modules&#x2F;  # 库文件存放目录#remote_tmp    &#x3D; $HOME&#x2F;.ansible&#x2F;tmp      # 临时py命令文件存放在远程主机目录#local_tmp     &#x3D; $HOME&#x2F;.ansible&#x2F;tmp      # 本机的临时命令执行目录  #forks         &#x3D; 5                       # 默认并发数,同时可以执行5次#sudo_user     &#x3D; root                    # 默认sudo 用户#ask_sudo_pass &#x3D; True                    # 每次执行ansible命令是否询问ssh密码#ask_pass      &#x3D; True                    # 每次执行ansible命令是否询问ssh口令#remote_port   &#x3D; 22                      # 远程主机的端口号(默认22)建议优化项： host_key_checking &#x3D; False               # 检查对应服务器的host_key，建议取消注释log_path&#x3D;&#x2F;var&#x2F;log&#x2F;ansible.log           # 日志文件,建议取消注释module_name   &#x3D; command                 # 默认模块</code></pre><h3 id="ansible系列命令"><a href="#ansible系列命令" class="headerlink" title="ansible系列命令"></a>ansible系列命令</h3><pre class="language-none"><code class="language-none">Ansible系列命令    ansible ansible-doc ansible-playbook ansible-vault ansible-console    ansible-galaxy ansible-pullansible-doc: 显示模块帮助    ansible-doc [options] [module...]        -a            显示所有模块的文档        -l, --list    列出可用模块        -s, --snippet 显示指定模块的playbook片段(简化版,便于查找语法)示例：    ansible-doc -l      列出所有模块    ansible-doc ping    查看指定模块帮助用法    ansible-doc -s ping 查看指定模块帮助用法</code></pre><h3 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h3><pre class="language-none"><code class="language-none">ansible通过ssh实现配置管理、应用部署、任务执行等功能，建议配置ansible端能基于密钥认证的方式联系各被管理节点ansible &lt;host-pattern&gt; [-m module_name] [-a args]ansible +被管理的主机(ALL) +模块  +参数    --version              显示版本    -m module              指定模块，默认为command    -v                     详细过程 –vv -vvv更详细    --list-hosts           显示主机列表，可简写 --list    -k, --ask-pass         提示输入ssh连接密码,默认Key验证    -C, --check            检查，并不执行    -T, --timeout&#x3D;TIMEOUT  执行命令的超时时间,默认10s    -u, --user&#x3D;REMOTE_USER 执行远程执行的用户    -b, --become           代替旧版的sudo切换        --become-user&#x3D;USERNAME 指定sudo的runas用户,默认为root    -K, --ask-become-pass  提示输入sudo时的口令</code></pre><pre class="language-none"><code class="language-none">ansible all --list  列出所有主机ping模块: 探测网络中被管理主机是否能够正常使用  走ssh协议          如果对方主机网络正常,返回pongansible-doc -s ping   查看ping模块的语法 检测所有主机的网络状态1&gt;  默认情况下连接被管理的主机是ssh基于key验证,如果没有配置key,权限将会被拒绝    因此需要指定以谁的身份连接,输入用户密码,必须保证被管理主机用户密码一致    ansible all -m ping -k2&gt; 或者实现基于key验证 将公钥ssh-copy-id到被管理的主机上 , 实现免密登录   ansible all -m ping</code></pre><h3 id="ansible的Host-pattern"><a href="#ansible的Host-pattern" class="headerlink" title="ansible的Host-pattern"></a>ansible的Host-pattern</h3><pre class="language-none"><code class="language-none">ansible的Host-pattern匹配主机的列表    All ：表示所有Inventory中的所有主机        ansible all –m ping    * :通配符        ansible &quot;*&quot; -m ping  (*表示所有主机)        ansible 192.168.1.* -m ping        ansible &quot;*srvs&quot; -m ping    或关系 &quot;:&quot;        ansible &quot;websrvs:appsrvs&quot; -m ping        ansible “192.168.1.10:192.168.1.20” -m ping    逻辑与 &quot;:&amp;&quot;        ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping        在websrvs组并且在dbsrvs组中的主机    逻辑非 &quot;:!&quot;        ansible &#39;websrvs:!dbsrvs&#39; –m ping        在websrvs组，但不在dbsrvs组中的主机        注意：此处为单引号    综合逻辑        ansible &#39;websrvs:dbsrvs:&amp;appsrvs:!ftpsrvs&#39; –m ping    正则表达式        ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping        ansible &quot;~(web|db).*\.magedu\.com&quot; –m ping</code></pre><h3 id="ansible命令执行过程"><a href="#ansible命令执行过程" class="headerlink" title="ansible命令执行过程"></a>ansible命令执行过程</h3><pre class="language-none"><code class="language-none">ansible命令执行过程    1. 加载自己的配置文件 默认&#x2F;etc&#x2F;ansible&#x2F;ansible.cfg    2. 加载自己对应的模块文件，如command    3. 通过ansible将模块或命令生成对应的临时py文件，       并将该文件传输至远程服务器的对应执行用户$HOME&#x2F;.ansible&#x2F;tmp&#x2F;ansible-tmp-数字&#x2F;XXX.PY文件    4. 给文件+x执行    5. 执行并返回结果    6. 删除临时py文件，sleep 0退出执行状态：    绿色：执行成功并且不需要做改变的操作    黄色：执行成功并且对目标主机做变更    红色：执行失败</code></pre><h3 id="ansible使用示例"><a href="#ansible使用示例" class="headerlink" title="ansible使用示例"></a>ansible使用示例</h3><pre class="language-none"><code class="language-none">示例    以wang用户执行ping存活检测        ansible all -m ping -u wang -k    以wang sudo至root执行ping存活检测        ansible all -m ping -u wang -k -b    以wang sudo至mage用户执行ping存活检测        ansible all -m ping -u wang -k -b --become-user&#x3D;mage    以wang sudo至root用户执行ls        ansible all -m command -u wang -a &#39;ls &#x2F;root&#39; -b --become-user&#x3D;root -k -Kansible ping模块测试连接    ansible 192.168.38.126,192.168.38.127 -m ping -k </code></pre><h3 id="ansible常用模块"><a href="#ansible常用模块" class="headerlink" title="ansible常用模块"></a>ansible常用模块</h3><pre class="language-none"><code class="language-none">模块文档：https:&#x2F;&#x2F;docs.ansible.com&#x2F;ansible&#x2F;latest&#x2F;modules&#x2F;modules_by_category.htmlCommand：在远程主机执行命令，默认模块，可忽略-m选项    &gt; ansible srvs -m command -a &#39;service vsftpd start&#39;    &gt; ansible srvs -m command -a &#39;echo adong |passwd --stdin 123456&#39;此命令不支持 $VARNAME &lt; &gt; | ; &amp; 等,用shell模块实现    chdir:   进入到被管理主机目录    creates: 如果有一个目录是存在的,步骤将不会运行Command命令    ansible websrvs -a &#39;chdir&#x3D;&#x2F;data&#x2F; ls&#39;Shell：和command相似，用shell执行命令    &gt; ansible all -m shell  -a &#39;getenforce&#39;  查看SELINUX状态    &gt;  ansible all -m shell  -a &quot;sed -i &#39;s&#x2F;SELINUX&#x3D;.*&#x2F;SELINUX&#x3D;disabled&#39; &#x2F;etc&#x2F;selinux&#x2F;config&quot;    &gt; ansible srv -m shell -a &#39;echo magedu |passwd –stdin wang&#39;          调用bash执行命令 类似 cat &#x2F;tmp&#x2F;stanley.md | awk -F&#39;|&#39; &#39;&#123;print $1,$2&#125;&#39; &amp;&gt; &#x2F;tmp&#x2F;example.txt         这些复杂命令，即使使用shell也可能会失败，    解决办法：写到脚本时，copy到远程执行，再把需要的结果拉回执行命令的机器    修改配置文件,使shell作为默认模块            vim &#x2F;etc&#x2F;ansible&#x2F;ansible.cfg        module_name &#x3D; shellScript：在远程主机上运行ansible服务器上的脚本    &gt; -a &quot;&#x2F;PATH&#x2F;TO&#x2F;SCRIPT_FILE&quot;    &gt; ansible websrvs -m script -a &#x2F;data&#x2F;test.shCopy：从主控端复制文件到远程主机      src : 源文件  指定拷贝文件的本地路径  (如果有&#x2F; 则拷贝目录内容,比拷贝目录本身)      dest: 指定目标路径      mode: 设置权限      backup: 备份源文件      content: 代替src  指定本机文件内容,生成目标主机文件            &gt; ansible websrvs -m copy -a &quot;src&#x3D;&#x2F;root&#x2F;test1.sh dest&#x3D;&#x2F;tmp&#x2F;test2.showner&#x3D;wang mode&#x3D;600 backup&#x3D;yes&quot;        如果目标存在，默认覆盖，此处指定先备份      &gt; ansible websrvs -m copy -a &quot;content&#x3D;&#39;test content\nxxx&#39; dest&#x3D;&#x2F;tmp&#x2F;test.txt&quot;        指定内容，直接生成目标文件Fetch：从远程主机提取文件至主控端，copy相反，目前不支持目录,可以先打包,再提取文件     &gt; ansible websrvs -m fetch -a &#39;src&#x3D;&#x2F;root&#x2F;test.sh dest&#x3D;&#x2F;data&#x2F;scripts&#39;     会生成每个被管理主机不同编号的目录,不会发生文件名冲突          &gt; ansible all -m shell -a &#39;tar jxvf test.tar.gz &#x2F;root&#x2F;test.sh&#39;     &gt; ansible all -m fetch -a &#39;src&#x3D;&#x2F;root&#x2F;test.tar.gz dest&#x3D;&#x2F;data&#x2F;&#39;File：设置文件属性    path: 要管理的文件路径 (强制添加)    recurse: 递归,文件夹要用递归    src:  创建硬链接,软链接时,指定源目标,配合&#39;state&#x3D;link&#39; &#39;state&#x3D;hard&#39; 设置软链接,硬链接    state: 状态          absent 缺席,删除              &gt; ansible websrvs -m file -a &#39;path&#x3D;&#x2F;app&#x2F;test.txt state&#x3D;touch&#39;       创建文件    &gt; ansible websrvs -m file -a &quot;path&#x3D;&#x2F;data&#x2F;testdir state&#x3D;directory&quot;   创建目录        &gt; ansible websrvs -m file -a &quot;path&#x3D;&#x2F;root&#x2F;test.sh owner&#x3D;wang mode&#x3D;755&quot;  设置权限755    &gt; ansible websrvs -m file -a &#39;src&#x3D;&#x2F;data&#x2F;testfile dest&#x3D;&#x2F;data&#x2F;testfile-link state&#x3D;link&#39; 创建软链接        unarchive：解包解压缩，有两种用法：    1、将ansible主机上的压缩包传到远程主机后解压缩至特定目录，设置copy&#x3D;yes.    2、将远程主机上的某个压缩包解压缩到指定路径下，设置copy&#x3D;no    常见参数：        copy：默认为yes，当copy&#x3D;yes，拷贝的文件是从ansible主机复制到远程主机上，              如果设置为copy&#x3D;no，会在远程主机上寻找src源文件        src： 源路径，可以是ansible主机上的路径，也可以是远程主机上的路径，              如果是远程主机上的路径，则需要设置copy&#x3D;no        dest：远程主机上的目标路径        mode：设置解压缩后的文件权限        示例：        ansible websrvs -m unarchive -a &#39;src&#x3D;foo.tgz dest&#x3D;&#x2F;var&#x2F;lib&#x2F;foo&#39;            #默认copy为yes ,将本机目录文件解压到目标主机对应目录下        ansible websrvs -m unarchive -a &#39;src&#x3D;&#x2F;tmp&#x2F;foo.zip dest&#x3D;&#x2F;data copy&#x3D;no mode&#x3D;0777&#39;          # 解压被管理主机的foo.zip到data目录下, 并设置权限777        ansible websrvs -m unarchive -a &#39;src&#x3D;https:&#x2F;&#x2F;example.com&#x2F;example.zip dest&#x3D;&#x2F;data copy&#x3D;no&#39;Archive：打包压缩    &gt; ansible all -m archive -a &#39;path&#x3D;&#x2F;etc&#x2F;sysconfig dest&#x3D;&#x2F;data&#x2F;sysconfig.tar.bz2 format&#x3D;bz2 owner&#x3D;wang mode&#x3D;0777&#39;    将远程主机目录打包         path:   指定路径        dest:   指定目标文件        format: 指定打包格式        owner:  指定所属者        mode:   设置权限Hostname：管理主机名    ansible appsrvs -m hostname -a &quot;name&#x3D;app.adong.com&quot;  更改一组的主机名    ansible 192.168.38.103 -m hostname -a &quot;name&#x3D;app2.adong.com&quot; 更改单个主机名Cron：计划任务    支持时间：minute,hour,day,month,weekday    &gt; ansible websrvs -m cron -a &quot;minute&#x3D;*&#x2F;5 job&#x3D;&#39;&#x2F;usr&#x2F;sbin&#x2F;ntpdate 172.16.0.1 &amp;&gt;&#x2F;dev&#x2F;null&#39; name&#x3D;Synctime&quot;     创建任务    &gt; ansible websrvs -m cron -a &#39;state&#x3D;absent name&#x3D;Synctime&#39;     删除任务    &gt; ansible websrvs -m cron -a &#39;minute&#x3D;*&#x2F;10 job&#x3D;&#39;&#x2F;usr&#x2F;sbin&#x2F;ntpdate 172.30.0.100&quot; name&#x3D;synctime disabled&#x3D;yes&#39;    注释任务,不在生效Yum：管理包    ansible websrvs -m yum -a &#39;list&#x3D;httpd&#39;  查看程序列表        ansible websrvs -m yum -a &#39;name&#x3D;httpd state&#x3D;present&#39; 安装    ansible websrvs -m yum -a &#39;name&#x3D;httpd state&#x3D;absent&#39;  删除    可以同时安装多个程序包    Service：管理服务    ansible srv -m service -a &#39;name&#x3D;httpd state&#x3D;stopped&#39;  停止服务    ansible srv -m service -a &#39;name&#x3D;httpd state&#x3D;started enabled&#x3D;yes&#39; 启动服务,并设为开机自启    ansible srv -m service -a &#39;name&#x3D;httpd state&#x3D;reloaded&#39;  重新加载    ansible srv -m service -a &#39;name&#x3D;httpd state&#x3D;restarted&#39; 重启服务User：管理用户    home   指定家目录路径    system 指定系统账号    group  指定组    remove 清除账户    shell  指定shell类型        ansible websrvs -m user -a &#39;name&#x3D;user1 comment&#x3D;&quot;test user&quot; uid&#x3D;2048 home&#x3D;&#x2F;app&#x2F;user1 group&#x3D;root&#39;    ansible websrvs -m user -a &#39;name&#x3D;sysuser1 system&#x3D;yes home&#x3D;&#x2F;app&#x2F;sysuser1&#39;    ansible websrvs -m user -a &#39;name&#x3D;user1 state&#x3D;absent remove&#x3D;yes&#39;  清空用户所有数据    ansible websrvs -m user -a &#39;name&#x3D;app uid&#x3D;88 system&#x3D;yes home&#x3D;&#x2F;app groups&#x3D;root shell&#x3D;&#x2F;sbin&#x2F;nologin password&#x3D;&quot;$1$zfVojmPy$ZILcvxnXljvTI2PhP2Iqv1&quot;&#39;  创建用户    ansible websrvs -m user -a &#39;name&#x3D;app state&#x3D;absent&#39;  不会删除家目录        安装mkpasswd     yum insatll expect     mkpasswd 生成口令    openssl passwd -1  生成加密口令    删除用户及家目录等数据    Group：管理组        ansible srv -m group -a &quot;name&#x3D;testgroup system&#x3D;yes&quot;   创建组        ansible srv -m group -a &quot;name&#x3D;testgroup state&#x3D;absent&quot; 删除组</code></pre><h3 id="ansible系列命令-1"><a href="#ansible系列命令-1" class="headerlink" title="ansible系列命令"></a>ansible系列命令</h3><pre class="language-none"><code class="language-none">可以通过网上写好的ansible-galaxy    &gt; 连接 https:&#x2F;&#x2F;galaxy.ansible.com       下载相应的roles(角色)        &gt; 列出所有已安装的galaxy        ansible-galaxy list        &gt; 安装galaxy        ansible-galaxy install geerlingguy.redis        &gt; 删除galaxy        ansible-galaxy remove geerlingguy.redis        ansible-pull    推送命令至远程，效率无限提升，对运维要求较高    ansible-playbook  可以引用按照标准的yml语言写的脚本    执行playbook    示例：ansible-playbook hello.yml        cat hello.yml        #hello world yml file        - hosts: websrvs          remote_user: root          tasks:            - name: hello world              command: &#x2F;usr&#x2F;bin&#x2F;wall hello worldansible-vault  (了解)功能：管理加密解密yml文件    ansible-vault [create|decrypt|edit|encrypt|rekey|view]        ansible-vault encrypt hello.yml 加密        ansible-vault decrypt hello.yml 解密        ansible-vault view hello.yml    查看        ansible-vault edit hello.yml    编辑加密文件        ansible-vault rekey hello.yml   修改口令        ansible-vault create new.yml    创建新文件Ansible-console：2.0+新增，可交互执行命令，支持tab  (了解)    root@test (2)[f:10] $    执行用户@当前操作的主机组 (当前组的主机数量)[f:并发数]$    设置并发数：         forks n   例如： forks 10    切换组：             cd 主机组 例如： cd web    列出当前组主机列表： list    列出所有的内置命令： ?或help    示例：        root@all (2)[f:5]$ list        root@all (2)[f:5]$ cd appsrvs        root@appsrvs (2)[f:5]$ list        root@appsrvs (2)[f:5]$ yum name&#x3D;httpd state&#x3D;present        root@appsrvs (2)[f:5]$ service name&#x3D;httpd state&#x3D;started</code></pre><h3 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h3><pre class="language-none"><code class="language-none">&gt; playbook是由一个或多个&quot;play&quot;组成的列表&gt; play的主要功能在于将预定义的一组主机，装扮成事先通过ansible中的task定义好的角色。  Task实际是调用ansible的一个module，将多个play组织在一个playbook中，  即可以让它们联合起来，按事先编排的机制执行预定义的动作&gt; Playbook采用YAML语言编写</code></pre><h3 id="playbook图解"><a href="#playbook图解" class="headerlink" title="playbook图解"></a>playbook图解</h3><p><img src="/../images/playbook%E5%9B%BE%E8%A7%A3.png" alt="image">  </p><pre class="language-none"><code class="language-none">用户通过ansible命令直接调用yml语言写好的playbook,playbook由多条play组成每条play都有一个任务(task)相对应的操作,然后调用模块modules，应用在主机清单上,通过ssh远程连接从而控制远程主机或者网络设备</code></pre><h3 id="YAML介绍"><a href="#YAML介绍" class="headerlink" title="YAML介绍"></a>YAML介绍</h3><pre class="language-none"><code class="language-none">YAML是一个可读性高的用来表达资料序列的格式。    YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822等。    Clark Evans在2001年在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者YAML Ain&#39;t Markup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）特性    YAML的可读性好    YAML和脚本语言的交互性好    YAML使用实现语言的数据类型    YAML有一个一致的信息模型    YAML易于实现    YAML可以基于流来处理    YAML表达能力强，扩展性好更多的内容及规范参见：http:&#x2F;&#x2F;www.yaml.org</code></pre><h3 id="YAML语法简介"><a href="#YAML语法简介" class="headerlink" title="YAML语法简介"></a>YAML语法简介</h3><pre class="language-none"><code class="language-none">&gt; 在单一档案中，可用连续三个连字号(——)区分多个档案。  另外，还有选择性的连续三个点号( ... )用来表示档案结尾&gt; 次行开始正常写Playbook的内容，一般建议写明该Playbook的功能&gt; 使用#号注释代码&gt; 缩进必须是统一的，不能空格和tab混用&gt; 缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结合换行来实现的&gt; YAML文件内容是区别大小写的，k&#x2F;v的值均需大小写敏感&gt; 多个k&#x2F;v可同行写也可换行写，同行使用:分隔&gt; v可是个字符串，也可是另一个列表[]&gt; 一个完整的代码块功能需最少元素需包括 name 和 task&gt; 一个name只能包括一个task&gt; YAML文件扩展名通常为yml或yaml</code></pre><h3 id="YAML语法简介-1"><a href="#YAML语法简介-1" class="headerlink" title="YAML语法简介"></a>YAML语法简介</h3><pre class="language-none"><code class="language-none">List：列表，其所有元素均使用“-”打头      列表代表同一类型的元素示例：# A list of tasty fruits- Apple- Orange- Strawberry- MangoDictionary：字典，通常由多个key与value构成 键值对示例：---# An employee recordname: Example Developerjob: Developerskill: Elite也可以将key:value放置于&#123;&#125;中进行表示，用,分隔多个key:value示例：---# An employee record&#123;name: Example Developer, job: Developer, skill: Elite&#125;  有空格</code></pre><h3 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h3><pre class="language-none"><code class="language-none">YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用&quot;-&quot;来代表，Map里的键值对用&quot;:&quot;分隔示例    name: John Smith    age: 41    gender: Male    spouse:      name: Jane Smith      age: 37      gender: Female    children:      - name: Jimmy Smith        age: 17        gender: Male      - name: Jenny Smith        age 13        gender: Female</code></pre><h3 id="三种常见的数据交换格式"><a href="#三种常见的数据交换格式" class="headerlink" title="三种常见的数据交换格式"></a>三种常见的数据交换格式</h3><p><img src="/../images/threedata.png" alt="image"></p><h3 id="Playbook核心元素"><a href="#Playbook核心元素" class="headerlink" title="Playbook核心元素"></a>Playbook核心元素</h3><pre class="language-none"><code class="language-none">Hosts          执行的远程主机列表(应用在哪些主机上)Tasks          任务集Variables      内置变量或自定义变量在playbook中调用Templates模板  可替换模板文件中的变量并实现一些简单逻辑的文件Handlers和notify结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行tags标签       指定某条任务执行，用于选择运行playbook中的部分代码。                ansible具有幂等性，因此会自动跳过没有变化的部分，                即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。                此时，如果确信其没有变化，就可以通过tags跳过此些代码片断                ansible-playbook -t tagsname useradd.yml</code></pre><h3 id="playbook基础组件"><a href="#playbook基础组件" class="headerlink" title="playbook基础组件"></a>playbook基础组件</h3><pre class="language-none"><code class="language-none">Hosts：    &gt; playbook中的每一个play的目的都是为了让特定主机以某个指定的用户身份执行任务。      hosts用于指定要执行指定任务的主机，须事先定义在主机清单中    &gt; 可以是如下形式：        one.example.com        one.example.com:two.example.com        192.168.1.50        192.168.1.*    &gt; Websrvs:dbsrvs       或者，两个组的并集    &gt; Websrvs:&amp;dbsrvs      与，两个组的交集    &gt; webservers:!phoenix  在websrvs组，但不在dbsrvs组    示例: - hosts: websrvs：dbsrvsremote_user:     可用于Host和task中。    也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；    此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户    - hosts: websrvs        remote_user: root   (可省略,默认为root)  以root身份连接      tasks:    指定任务    - name: test connection        ping:        remote_user: magedu        sudo: yes           默认sudo为root        sudo_user:wang      sudo为wang    task列表和action    任务列表task:由多个动作,多个任务组合起来的,每个任务都调用的模块,一个模块一个模块执行    1&gt; play的主体部分是task list，task list中的各任务按次序逐个在hosts中指定的所有主机上执行，       即在所有主机上完成第一个任务后，再开始第二个任务    2&gt; task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。       模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致    3&gt; 每个task都应该有其name，用于playbook的执行结果输出，建议其内容能清晰地描述任务执行步骤。       如果未提供name，则action的结果将用于输出</code></pre><pre class="language-none"><code class="language-none">tasks：任务列表两种格式：    (1) action: module arguments    (2) module: arguments 建议使用  模块: 参数    注意：shell和command模块后面跟命令，而非key&#x3D;value某任务的状态在运行后为changed时，可通过&quot;notify&quot;通知给相应的handlers任务可以通过&quot;tags&quot;打标签，可在ansible-playbook命令上使用-t指定进行调用示例：tasks:  - name: disable selinux   描述    command: &#x2F;sbin&#x2F;setenforce 0   模块名: 模块对应的参数</code></pre><pre class="language-none"><code class="language-none">如果命令或脚本的退出码不为零，可以使用如下方式替代tasks:  - name: run this command and ignore the result    shell: &#x2F;usr&#x2F;bin&#x2F;somecommand || &#x2F;bin&#x2F;true      转错为正  如果命令失败则执行 true或者使用ignore_errors来忽略错误信息tasks:  - name: run this command and ignore the result    shell: &#x2F;usr&#x2F;bin&#x2F;somecommand    ignore_errors: True  忽略错误</code></pre><h3 id="运行playbook"><a href="#运行playbook" class="headerlink" title="运行playbook"></a>运行playbook</h3><pre class="language-none"><code class="language-none">运行playbook的方式    ansible-playbook &lt;filename.yml&gt; ... [options]常见选项    --check -C       只检测可能会发生的改变，但不真正执行操作                      (只检查语法,如果执行过程中出现问题,-C无法检测出来)                     (执行playbook生成的文件不存在,后面的程序如果依赖这些文件,也会导致检测失败)    --list-hosts     列出运行任务的主机    --list-tags      列出tag  (列出标签)    --list-tasks     列出task (列出任务)    --limit 主机列表 只针对主机列表中的主机执行    -v -vv -vvv      显示过程示例    ansible-playbook hello.yml --check 只检测    ansible-playbook hello.yml --list-hosts  显示运行任务的主机    ansible-playbook hello.yml --limit websrvs  限制主机</code></pre><h3 id="Playbook-VS-ShellScripts"><a href="#Playbook-VS-ShellScripts" class="headerlink" title="Playbook VS ShellScripts"></a>Playbook VS ShellScripts</h3><p>安装httpd</p><pre class="language-none"><code class="language-none">SHELL脚本#!&#x2F;bin&#x2F;bash# 安装Apacheyum install --quiet -y httpd# 复制配置文件cp &#x2F;tmp&#x2F;httpd.conf &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.confcp&#x2F;tmp&#x2F;vhosts.conf &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;# 启动Apache，并设置开机启动service httpd startchkconfig httpd on</code></pre><pre class="language-none"><code class="language-none">Playbook定义---- hosts: all  remote_user: root    tasks:    - name: &quot;安装Apache&quot;      yum: name&#x3D;httpd       yum模块:安装httpd    - name: &quot;复制配置文件&quot;      copy: src&#x3D;&#x2F;tmp&#x2F;httpd.conf dest&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;  copy模块: 拷贝文件    - name: &quot;复制配置文件&quot;      copy: src&#x3D;&#x2F;tmp&#x2F;vhosts.conf dest&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;      - name: &quot;启动Apache，并设置开机启动&quot;      service: name&#x3D;httpd state&#x3D;started enabled&#x3D;yes   service模块: 启动服务 </code></pre><h3 id="示例-Playbook-创建用户"><a href="#示例-Playbook-创建用户" class="headerlink" title="示例:Playbook 创建用户"></a>示例:Playbook 创建用户</h3><pre class="language-none"><code class="language-none">示例：sysuser.yml---- hosts: all  remote_user: root  tasks:    - name: create mysql user      user: name&#x3D;mysql system&#x3D;yes uid&#x3D;36    - name: create a group      group: name&#x3D;httpd system&#x3D;yes</code></pre><h3 id="Playbook示例-安装httpd服务"><a href="#Playbook示例-安装httpd服务" class="headerlink" title="Playbook示例  安装httpd服务"></a>Playbook示例  安装httpd服务</h3><pre class="language-none"><code class="language-none">示例：httpd.yml- hosts: websrvs  remote_user: root  tasks:    - name: Install httpd      yum: name&#x3D;httpd state&#x3D;present    - name: Install configure file      copy: src&#x3D;files&#x2F;httpd.conf dest&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;    - name: start service      service: name&#x3D;httpd state&#x3D;started enabled&#x3D;yes</code></pre><h3 id="Playbook示例-安装nginx服务"><a href="#Playbook示例-安装nginx服务" class="headerlink" title="Playbook示例  安装nginx服务"></a>Playbook示例  安装nginx服务</h3><pre class="language-none"><code class="language-none">示例 nginx.yml- hosts: all  remote_user: root  tasks:    - name: add group nginx      user: name&#x3D;nginx state&#x3D;present    - name: add user nginx      user: name&#x3D;nginx state&#x3D;present group&#x3D;nginx    - name: Install Nginx      yum: name&#x3D;nginx state&#x3D;present    - name: Start Nginx      service: name&#x3D;nginx state&#x3D;started enabled&#x3D;yes</code></pre><h3 id="handlers和notify结合使用触发条件"><a href="#handlers和notify结合使用触发条件" class="headerlink" title="handlers和notify结合使用触发条件"></a>handlers和notify结合使用触发条件</h3><pre class="language-none"><code class="language-none">Handlers 实际上就是一个触发器是task列表，这些task与前述的task并没有本质上的不同,用于当关注的资源发生变化时，才会采取一定的操作Notify此action可用于在每个play的最后被触发，这样可避免多次有改变发生时每次都执行指定的操作，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作</code></pre><h3 id="Playbook中handlers使用"><a href="#Playbook中handlers使用" class="headerlink" title="Playbook中handlers使用"></a>Playbook中handlers使用</h3><pre class="language-none"><code class="language-none">- hosts: websrvs  remote_user: root  tasks:    - name: Install httpd      yum: name&#x3D;httpd state&#x3D;present    - name: Install configure file      copy: src&#x3D;files&#x2F;httpd.conf dest&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;      notify: restart httpd    - name: ensure apache is running      service: name&#x3D;httpd state&#x3D;started enabled&#x3D;yes    handlers:    - name: restart httpd      service: name&#x3D;httpd state&#x3D;restarted</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">- hosts: webnodes  vars:    http_port: 80    max_clients: 256  remote_user: root    tasks:    - name: ensure apache is at the latest version      yum: name&#x3D;httpd state&#x3D;latest    - name: ensure apache is running      service: name&#x3D;httpd state&#x3D;started    - name: Install configure file      copy: src&#x3D;files&#x2F;httpd.conf dest&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;      notify: restart httpd    handlers:      - name: restart httpd         service: name&#x3D;httpd state&#x3D;restarted</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">- hosts: websrvs  remote_user: root    tasks:    - name: add group nginx      tags: user      user: name&#x3D;nginx state&#x3D;present    - name: add user nginx      user: name&#x3D;nginx state&#x3D;present group&#x3D;nginx    - name: Install Nginx      yum: name&#x3D;nginx state&#x3D;present    - name: config      copy: src&#x3D;&#x2F;root&#x2F;config.txt dest&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf      notify:        - Restart Nginx        - Check Nginx Process    handlers:    - name: Restart Nginx      service: name&#x3D;nginx state&#x3D;restarted enabled&#x3D;yes    - name: Check Nginx process      shell: killall -0 nginx &gt; &#x2F;tmp&#x2F;nginx.log</code></pre><h3 id="Playbook中tags使用"><a href="#Playbook中tags使用" class="headerlink" title="Playbook中tags使用"></a>Playbook中tags使用</h3><pre class="language-none"><code class="language-none">tage: 添加标签 可以指定某一个任务添加一个标签,添加标签以后,想执行某个动作可以做出挑选来执行多个动作可以使用同一个标签示例：httpd.yml- hosts: websrvs  remote_user: root    tasks:    - name: Install httpd      yum: name&#x3D;httpd state&#x3D;present      tage: install     - name: Install configure file      copy: src&#x3D;files&#x2F;httpd.conf dest&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;      tags: conf    - name: start httpd service      tags: service      service: name&#x3D;httpd state&#x3D;started enabled&#x3D;yesansible-playbook –t install,conf httpd.yml   指定执行install,conf 两个标签</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">&#x2F;&#x2F;heartbeat.yaml- hosts: hbhosts  remote_user: root    tasks:    - name: ensure heartbeat latest version      yum: name&#x3D;heartbeat state&#x3D;present    - name: authkeys configure file      copy: src&#x3D;&#x2F;root&#x2F;hb_conf&#x2F;authkeys dest&#x3D;&#x2F;etc&#x2F;ha.d&#x2F;authkeys    - name: authkeys mode 600      file: path&#x3D;&#x2F;etc&#x2F;ha.d&#x2F;authkeys mode&#x3D;600      notify:        - restart heartbeat    - name: ha.cf configure file      copy: src&#x3D;&#x2F;root&#x2F;hb_conf&#x2F;ha.cf dest&#x3D;&#x2F;etc&#x2F;ha.d&#x2F;ha.cf      notify:        - restart heartbeat  handlers:    - name: restart heartbeat      service: name&#x3D;heartbeat state&#x3D;restarted</code></pre><h3 id="Playbook中tags使用-1"><a href="#Playbook中tags使用-1" class="headerlink" title="Playbook中tags使用"></a>Playbook中tags使用</h3><pre class="language-none"><code class="language-none">- hosts: testsrv  remote_user: root  tags: inshttpd   针对整个playbook添加tage  tasks:    - name: Install httpd      yum: name&#x3D;httpd state&#x3D;present    - name: Install configure file      copy: src&#x3D;files&#x2F;httpd.conf dest&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;      tags: rshttpd      notify: restart httpd  handlers:    - name: restart httpd      service: name&#x3D;httpd status&#x3D;restarted     ansible-playbook –t rshttpd httpd2.yml</code></pre><h3 id="Playbook中变量的使用"><a href="#Playbook中变量的使用" class="headerlink" title="Playbook中变量的使用"></a>Playbook中变量的使用</h3><pre class="language-none"><code class="language-none">变量名：仅能由字母、数字和下划线组成，且只能以字母开头变量来源：    1&gt; ansible setup facts 远程主机的所有变量都可直接调用 (系统自带变量)       setup模块可以实现系统中很多系统信息的显示                可以返回每个主机的系统信息包括:版本、主机名、cpu、内存       ansible all -m setup -a &#39;filter&#x3D;&quot;ansible_nodename&quot;&#39;     查询主机名       ansible all -m setup -a &#39;filter&#x3D;&quot;ansible_memtotal_mb&quot;&#39;  查询主机内存大小       ansible all -m setup -a &#39;filter&#x3D;&quot;ansible_distribution_major_version&quot;&#39;  查询系统版本       ansible all -m setup -a &#39;filter&#x3D;&quot;ansible_processor_vcpus&quot;&#39; 查询主机cpu个数        2&gt; 在&#x2F;etc&#x2F;ansible&#x2F;hosts(主机清单)中定义变量        普通变量：主机组中主机单独定义，优先级高于公共变量(单个主机 )        公共(组)变量：针对主机组中所有主机定义统一变量(一组主机的同一类别)        3&gt; 通过命令行指定变量，优先级最高       ansible-playbook –e varname&#x3D;value        4&gt; 在playbook中定义       vars:        - var1: value1        - var2: value2        5&gt; 在独立的变量YAML文件中定义        6&gt; 在role中定义变量命名:    变量名仅能由字母、数字和下划线组成，且只能以字母开头变量定义：key&#x3D;value    示例：http_port&#x3D;80变量调用方式：    1&gt; 通过&#123;&#123; variable_name &#125;&#125; 调用变量，且变量名前后必须有空格，有时用“&#123;&#123; variable_name &#125;&#125;”才生效    2&gt; ansible-playbook –e 选项指定       ansible-playbook test.yml -e &quot;hosts&#x3D;www user&#x3D;magedu&quot;</code></pre><pre class="language-none"><code class="language-none">在主机清单中定义变量,在ansible中使用变量vim &#x2F;etc&#x2F;ansible&#x2F;hosts[appsrvs]192.168.38.17 http_port&#x3D;817 name&#x3D;www192.168.38.27 http_port&#x3D;827 name&#x3D;web调用变量ansible appsrvs -m hostname -a&#39;name&#x3D;&#123;&#123;name&#125;&#125;&#39;  更改主机名为各自被定义的变量 针对一组设置变量[appsrvs:vars]make&#x3D;&quot;-&quot;ansible appsrvs -m hostname -a &#39;name&#x3D;&#123;&#123;name&#125;&#125;&#123;&#123;mark&#125;&#125;&#123;&#123;http_port&#125;&#125;&#39;  ansible调用变量</code></pre><pre class="language-none"><code class="language-none">将变量写进单独的配置文件中引用vim vars.ymlpack: vsftpdservice: vsftpd引用变量文件vars_files:  - vars.yml     </code></pre><h3 id="Ansible基础元素"><a href="#Ansible基础元素" class="headerlink" title="Ansible基础元素"></a>Ansible基础元素</h3><pre class="language-none"><code class="language-none">Facts：是由正在通信的远程目标主机发回的信息，这些信息被保存在ansible变量中。       要获取指定的远程主机所支持的所有facts，可使用如下命令进行       ansible websrvs -m setup通过命令行传递变量    在运行playbook的时候也可以传递一些变量供playbook使用    示例：        ansible-playbook test.yml -e &quot;hosts&#x3D;www user&#x3D;magedu&quot;        register把任务的输出定义为变量，然后用于其他任务示例:tasks:- shell: &#x2F;usr&#x2F;bin&#x2F;foo  register: foo_result  ignore_errors: True</code></pre><h3 id="示例：使用setup变量"><a href="#示例：使用setup变量" class="headerlink" title="示例：使用setup变量"></a>示例：使用setup变量</h3><pre class="language-none"><code class="language-none">示例：var.yml- hosts: websrvs  remote_user: root  tasks:    - name: create log file      file: name&#x3D;&#x2F;var&#x2F;log&#x2F; &#123;&#123; ansible_fqdn &#125;&#125; state&#x3D;touchansible-playbook var.yml</code></pre><h3 id="示例：变量"><a href="#示例：变量" class="headerlink" title="示例：变量"></a>示例：变量</h3><pre class="language-none"><code class="language-none">示例：var.yml- hosts: websrvs  remote_user: root  tasks:    - name: install package      yum: name&#x3D;&#123;&#123; pkname &#125;&#125; state&#x3D;present      ansible-playbook –e pkname&#x3D;httpd var.yml</code></pre><h3 id="示例：变量-1"><a href="#示例：变量-1" class="headerlink" title="示例：变量"></a>示例：变量</h3><pre class="language-none"><code class="language-none">示例：var.yml- hosts: websrvs  remote_user: rootvars:  - username: user1  - groupname: group1tasks:  - name: create group    group: name&#x3D;&#123;&#123; groupname &#125;&#125; state&#x3D;present  - name: create user    user: name&#x3D;&#123;&#123; username &#125;&#125; state&#x3D;presentansible-playbook var.ymlansible-playbook -e &quot;username&#x3D;user2 groupname&#x3D;group2” var2.yml</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre class="language-none"><code class="language-none">主机变量可以在inventory中定义主机时为其添加主机变量以便于在playbook中使用示例：[websrvs]www1.magedu.com http_port&#x3D;80 maxRequestsPerChild&#x3D;808www2.magedu.com http_port&#x3D;8080 maxRequestsPerChild&#x3D;909组变量组变量是指赋予给指定组内所有主机上的在playbook中可用的变量示例：    [websrvs]    www1.magedu.com    www2.magedu.com    [websrvs:vars]    ntp_server&#x3D;ntp.magedu.com    nfs_server&#x3D;nfs.magedu.com</code></pre><h3 id="示例：变量-2"><a href="#示例：变量-2" class="headerlink" title="示例：变量"></a>示例：变量</h3><pre class="language-none"><code class="language-none">普通变量    [websrvs]    192.168.99.101 http_port&#x3D;8080 hname&#x3D;www1    192.168.99.102 http_port&#x3D;80 hname&#x3D;www2公共（组）变量    [websvrs:vars]    http_port&#x3D;808    mark&#x3D;&quot;_&quot;    [websrvs]    192.168.99.101 http_port&#x3D;8080 hname&#x3D;www1    192.168.99.102 http_port&#x3D;80 hname&#x3D;www2    ansible websvrs –m hostname –a ‘name&#x3D;&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; http_port &#125;&#125;’命令行指定变量：    ansible websvrs –e http_port&#x3D;8000 –m hostname –a&#39;name&#x3D;&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; http_port &#125;&#125;&#39;</code></pre><h3 id="使用变量文件"><a href="#使用变量文件" class="headerlink" title="使用变量文件"></a>使用变量文件</h3><pre class="language-none"><code class="language-none">cat vars.ymlvar1: httpdvar2: nginxcat var.yml- hosts: web  remote_user: root  vars_files:    - vars.yml  tasks:    - name: create httpd log      file: name&#x3D;&#x2F;app&#x2F;&#123;&#123; var1 &#125;&#125;.log state&#x3D;touch    - name: create nginx log      file: name&#x3D;&#x2F;app&#x2F;&#123;&#123; var2 &#125;&#125;.log state&#x3D;touch      hostname app_81.magedu.com  hostname 不支持&quot;_&quot;,认为&quot;_&quot;是非法字符hostnamectl set-hostname app_80.magedu.com  可以更改主机名</code></pre><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><pre class="language-none"><code class="language-none">组嵌套inventory中，组还可以包含其它的组，并且也可以向组中的主机指定变量。这些变量只能在ansible-playbook中使用，而ansible命令不支持示例：    [apache]    httpd1.magedu.com    httpd2.magedu.com        [nginx]    ngx1.magedu.com    ngx2.magedu.com        [websrvs:children]    apache    nginx        [webservers:vars]    ntp_server&#x3D;ntp.magedu.com</code></pre><h3 id="invertory参数"><a href="#invertory参数" class="headerlink" title="invertory参数"></a>invertory参数</h3><pre class="language-none"><code class="language-none">invertory参数：用于定义ansible远程连接目标主机时使用的参数，而非传递给playbook的变量    ansible_ssh_host    ansible_ssh_port    ansible_ssh_user    ansible_ssh_pass    ansbile_sudo_pass示例：    cat &#x2F;etc&#x2F;ansible&#x2F;hosts    [websrvs]    192.168.0.1 ansible_ssh_user&#x3D;root ansible_ssh_pass&#x3D;magedu    192.168.0.2 ansible_ssh_user&#x3D;root ansible_ssh_pass&#x3D;magedu</code></pre><h3 id="invertory参数-1"><a href="#invertory参数-1" class="headerlink" title="invertory参数"></a>invertory参数</h3><pre class="language-none"><code class="language-none">inventory参数ansible基于ssh连接inventory中指定的远程主机时，还可以通过参数指定其交互方式；这些参数如下所示：ansible_ssh_hostThe name of the host to connect to, if different from the alias you wishto give to it.ansible_ssh_portThe ssh port number, if not 22ansible_ssh_userThe default ssh user name to use.ansible_ssh_passThe ssh password to use (this is insecure, we strongly recommendusing --ask-pass or SSH keys)ansible_sudo_passThe sudo password to use (this is insecure, we strongly recommendusing --ask-sudo-pass)ansible_connectionConnection type of the host. Candidates are local, ssh or paramiko.The default is paramiko before Ansible 1.2, and &#39;smart&#39; afterwards whichdetects whether usage of &#39;ssh&#39; would be feasible based on whetherControlPersist is supported.ansible_ssh_private_key_filePrivate key file used by ssh. Useful if using multiple keys and you don&#39;t want to use SSH agent.ansible_shell_typeThe shell type of the target system. By default commands are formattedusing &#39;sh&#39;-style syntax by default. Setting this to &#39;csh&#39; or &#39;fish&#39; will causecommands executed on target systems to follow those shell&#39;s syntax instead.ansible_python_interpreterThe target host python path. This is useful for systems with morethan one Python or not located at &quot;&#x2F;usr&#x2F;bin&#x2F;python&quot; such as \*BSD, or where &#x2F;usr&#x2F;bin&#x2F;pythonis not a 2.X series Python. We do not use the &quot;&#x2F;usr&#x2F;bin&#x2F;env&quot; mechanism as that requires the remote user&#39;spath to be set right and also assumes the &quot;python&quot; executable is named python,where the executable mightbe named something like &quot;python26&quot;.ansible\_\*\_interpreterWorks for anything such as ruby or perl and works just like ansible_python_interpreter.This replaces shebang of modules which will run on that host.</code></pre><h3 id="模板templates"><a href="#模板templates" class="headerlink" title="模板templates"></a>模板templates</h3><pre class="language-none"><code class="language-none">文本文件，嵌套有脚本（使用模板编程语言编写） 借助模板生成真正的文件Jinja2语言，使用字面量，有下面形式    字符串：使用单引号或双引号    数字：整数，浮点数    列表：[item1, item2, ...]    元组：(item1, item2, ...)    字典：&#123;key1:value1, key2:value2, ...&#125;    布尔型：true&#x2F;false算术运算：+, -, *, &#x2F;, &#x2F;&#x2F;, %, **比较操作：&#x3D;&#x3D;, !&#x3D;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;逻辑运算：and，or，not流表达式：For，If，When</code></pre><h3 id="Jinja2相关"><a href="#Jinja2相关" class="headerlink" title="Jinja2相关"></a>Jinja2相关</h3><pre class="language-none"><code class="language-none">字面量    1&gt; 表达式最简单的形式就是字面量。字面量表示诸如字符串和数值的 Python对象。如“Hello World”    双引号或单引号中间的一切都是字符串。    2&gt; 无论何时你需要在模板中使用一个字符串（比如函数调用、过滤器或只是包含或继承一个模板的参数），如4242.23    3&gt; 数值可以为整数和浮点数。如果有小数点，则为浮点数，否则为整数。在Python 里， 42 和 42.0 是不一样的</code></pre><h3 id="Jinja2-算术运算"><a href="#Jinja2-算术运算" class="headerlink" title="Jinja2:算术运算"></a>Jinja2:算术运算</h3><pre class="language-none"><code class="language-none">算术运算Jinja 允许你用计算值。这在模板中很少用到，但为了完整性允许其存在支持下面的运算符    +：把两个对象加到一起。       通常对象是素质，但是如果两者是字符串或列表，你可以用这 种方式来衔接它们。       无论如何这不是首选的连接字符串的方式！连接字符串见 ~ 运算符。 &#123;&#123; 1 + 1 &#125;&#125; 等于 2    -：用第一个数减去第二个数。 &#123;&#123; 3 - 2 &#125;&#125; 等于 1    &#x2F;：对两个数做除法。返回值会是一个浮点数。 &#123;&#123; 1 &#x2F; 2 &#125;&#125; 等于 &#123;&#123; 0.5 &#125;&#125;    &#x2F;&#x2F;：对两个数做除法，返回整数商。 &#123;&#123; 20 &#x2F;&#x2F; 7 &#125;&#125; 等于 2    %：计算整数除法的余数。 &#123;&#123; 11 % 7 &#125;&#125; 等于 4    *：用右边的数乘左边的操作数。 &#123;&#123; 2 * 2 &#125;&#125; 会返回 4 。       也可以用于重 复一个字符串多次。&#123;&#123; ‘&#x3D;’ * 80 &#125;&#125; 会打印 80 个等号的横条    **：取左操作数的右操作数次幂。 &#123;&#123; 2**3 &#125;&#125; 会返回 8</code></pre><h3 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h3><pre class="language-none"><code class="language-none">比较操作符&#x3D;&#x3D; 比较两个对象是否相等!&#x3D; 比较两个对象是否不等&gt; 如果左边大于右边，返回 true&gt;&#x3D; 如果左边大于等于右边，返回 true&lt; 如果左边小于右边，返回 true&lt;&#x3D; 如果左边小于等于右边，返回 true逻辑运算符对于 if 语句，在 for 过滤或 if 表达式中，它可以用于联合多个表达式and    如果左操作数和右操作数同为真，返回 trueor    如果左操作数和右操作数有一个为真，返回 truenot    对一个表达式取反（见下）(expr)    表达式组[&#39;list&#39;, &#39;of&#39;, &#39;objects&#39;]:一对中括号括起来的东西是一个列表。列表用于存储和迭代序列化的数据。例如 你可以容易地在 for循环中用列表和元组创建一个链接的列表    &lt;ul&gt;    &#123;% for href, caption in [(&#39;index.html&#39;, &#39;Index&#39;), (&#39;about.html&#39;, &#39;About&#39;), (&#39;downloads.html&#39;,&#39;Downloads&#39;)] %&#125;     &lt;li&gt; &lt;a href&#x3D;&quot;&#123;&#123; href &#125;&#125;&quot;&gt; &#123;&#123; caption &#125;&#125; &lt;&#x2F;a&gt;   &lt;&#x2F;li&gt;    &#123;% endfor %&#125;    &lt;&#x2F;ul&gt;    (&#39;tuple&#39;, &#39;of&#39;, &#39;values&#39;):元组与列表类似，只是你不能修改元组。如果元组中只有一个项，你需要以逗号结尾它。元组通常用于表示两个或更多元素的项。更多细节见上面的例子    &#123;&#39;dict&#39;: &#39;of&#39;, &#39;key&#39;: &#39;and&#39;, &#39;value&#39;: &#39;pairs&#39;&#125;:Python 中的字典是一种关联键和值的结构。键必须是唯一的，并且键必须只有一个 值。字典在模板中很少使用，罕用于诸如 xmlattr() 过滤器之类    true &#x2F; false:    true 永远是 true ，而 false 始终是 false</code></pre><h3 id="template-的使用"><a href="#template-的使用" class="headerlink" title="template 的使用"></a>template 的使用</h3><pre class="language-none"><code class="language-none">template功能：根据模块文件动态生成对应的配置文件   &gt; template文件必须存放于templates目录下，且命名为 .j2 结尾   &gt; yaml&#x2F;yml 文件需和templates目录平级，目录结构如下：    .&#x2F;     ├── temnginx.yml     └── templates        └── nginx.conf.j2</code></pre><h3 id="template示例"><a href="#template示例" class="headerlink" title="template示例"></a>template示例</h3><pre class="language-none"><code class="language-none">示例：利用template 同步nginx配置文件准备templates&#x2F;nginx.conf.j2文件vim temnginx.yml- hosts: websrvs  remote_user: root    tasks:    - name: template config to remote hosts      template: src&#x3D;nginx.conf.j2 dest&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.confansible-playbook temnginx.yml</code></pre><h3 id="Playbook中template变更替换"><a href="#Playbook中template变更替换" class="headerlink" title="Playbook中template变更替换"></a>Playbook中template变更替换</h3><pre class="language-none"><code class="language-none">修改文件nginx.conf.j2 下面行为worker_processes &#123;&#123; ansible_processor_vcpus &#125;&#125;;cat temnginx2.yml- hosts: websrvs  remote_user: root  tasks:    - name: template config to remote hosts      template: src&#x3D;nginx.conf.j2 dest&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.confansible-playbook temnginx2.yml</code></pre><h3 id="Playbook中template算术运算"><a href="#Playbook中template算术运算" class="headerlink" title="Playbook中template算术运算"></a>Playbook中template算术运算</h3><pre class="language-none"><code class="language-none">算法运算：示例：    vim nginx.conf.j2    worker_processes &#123;&#123; ansible_processor_vcpus**2 &#125;&#125;;    worker_processes &#123;&#123; ansible_processor_vcpus+2 &#125;&#125;;</code></pre><h3 id="when-实现条件判断"><a href="#when-实现条件判断" class="headerlink" title="when  实现条件判断"></a>when  实现条件判断</h3><pre class="language-none"><code class="language-none">条件测试:如果需要根据变量、facts或此前任务的执行结果来做为某task执行与否的前提时要用到条件测试,通过when语句实现，在task中使用，jinja2的语法格式when语句    在task后添加when子句即可使用条件测试；when语句支持Jinja2表达式语法示例：tasks:  - name: &quot;shutdown RedHat flavored systems&quot;    command: &#x2F;sbin&#x2F;shutdown -h now    when: ansible_os_family &#x3D;&#x3D; &quot;RedHat&quot;  当系统属于红帽系列,执行command模块  when语句中还可以使用Jinja2的大多&quot;filter&quot;，例如要忽略此前某语句的错误并基于其结果(failed或者success)运行后面指定的语句，可使用类似如下形式：tasks:  - command: &#x2F;bin&#x2F;false    register: result    ignore_errors: True  - command: &#x2F;bin&#x2F;something    when: result|failed  - command: &#x2F;bin&#x2F;something_else    when: result|success  - command: &#x2F;bin&#x2F;still&#x2F;something_else    when: result|skipped此外，when语句中还可以使用facts或playbook中定义的变量</code></pre><h3 id="示例：when条件判断"><a href="#示例：when条件判断" class="headerlink" title="示例：when条件判断"></a>示例：when条件判断</h3><pre class="language-none"><code class="language-none">- hosts: websrvs  remote_user: root  tasks:    - name: add group nginx      tags: user      user: name&#x3D;nginx state&#x3D;present    - name: add user nginx      user: name&#x3D;nginx state&#x3D;present group&#x3D;nginx    - name: Install Nginx      yum: name&#x3D;nginx state&#x3D;present    - name: restart Nginx      service: name&#x3D;nginx state&#x3D;restarted      when: ansible_distribution_major_version &#x3D;&#x3D; &quot;6&quot;</code></pre><h3 id="示例：when条件判断-1"><a href="#示例：when条件判断-1" class="headerlink" title="示例：when条件判断"></a>示例：when条件判断</h3><pre class="language-none"><code class="language-none">示例：tasks:  - name: install conf file to centos7    template: src&#x3D;nginx.conf.c7.j2 dest&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf    when: ansible_distribution_major_version &#x3D;&#x3D; &quot;7&quot;  - name: install conf file to centos6    template: src&#x3D;nginx.conf.c6.j2 dest&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf    when: ansible_distribution_major_version &#x3D;&#x3D; &quot;6&quot;</code></pre><h3 id="Playbook中when条件判断"><a href="#Playbook中when条件判断" class="headerlink" title="Playbook中when条件判断"></a>Playbook中when条件判断</h3><pre class="language-none"><code class="language-none">---- hosts: srv120  remote_user: root  tasks:    - name:      template: src&#x3D;nginx.conf.j2 dest&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf      when: ansible_distribution_major_version &#x3D;&#x3D; &quot;7&quot;</code></pre><p><img src="/../images/whenplaybook.png" alt="image"></p><h3 id="迭代：with-items"><a href="#迭代：with-items" class="headerlink" title="迭代：with_items"></a>迭代：with_items</h3><pre class="language-none"><code class="language-none">迭代：当有需要重复性执行的任务时，可以使用迭代机制    &gt; 对迭代项的引用，固定变量名为&quot;item&quot;    &gt; 要在task中使用with_items给定要迭代的元素列表    &gt; 列表格式：         字符串         字典</code></pre><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">示例： 创建用户- name: add several users  user: name&#x3D;&#123;&#123; item &#125;&#125; state&#x3D;present groups&#x3D;wheel   #&#123;&#123; item &#125;&#125; 系统自定义变量  with_items:       # 定义&#123;&#123; item &#125;&#125; 的值和个数    - testuser1    - testuser2上面语句的功能等同于下面的语句：- name: add user testuser1  user: name&#x3D;testuser1 state&#x3D;present groups&#x3D;wheel- name: add user testuser2  user: name&#x3D;testuser2 state&#x3D;present groups&#x3D;wheel  with_items中可以使用元素还可为hashes示例：- name: add several users  user: name&#x3D;&#123;&#123; item.name &#125;&#125; state&#x3D;present groups&#x3D;&#123;&#123; item.groups &#125;&#125;  with_items:    - &#123; name: &#39;testuser1&#39;, groups: &#39;wheel&#39; &#125;    - &#123; name: &#39;testuser2&#39;, groups: &#39;root&#39; &#125;ansible的循环机制还有更多的高级功能，具体请参见官方文档http:&#x2F;&#x2F;docs.ansible.com&#x2F;playbooks_loops.html</code></pre><h3 id="示例：迭代"><a href="#示例：迭代" class="headerlink" title="示例：迭代"></a>示例：迭代</h3><pre class="language-none"><code class="language-none">示例：将多个文件进行copy到被控端---- hosts: testsrv  remote_user: root  tasks  - name: Create rsyncd config    copy: src&#x3D;&#123;&#123; item &#125;&#125; dest&#x3D;&#x2F;etc&#x2F;&#123;&#123; item &#125;&#125;    with_items:  - rsyncd.secrets  - rsyncd.conf</code></pre><h3 id="示例：迭代-1"><a href="#示例：迭代-1" class="headerlink" title="示例：迭代"></a>示例：迭代</h3><pre class="language-none"><code class="language-none">- hosts: websrvs  remote_user: root  tasks:    - name: copy file      copy: src&#x3D;&#123;&#123; item &#125;&#125; dest&#x3D;&#x2F;tmp&#x2F;&#123;&#123; item &#125;&#125;      with_items:    - file1    - file2    - file3- name: yum install httpd  yum: name&#x3D;&#123;&#123; item &#125;&#125; state&#x3D;present  with_items:    - apr    - apr-util    - httpd</code></pre><h3 id="示例：迭代-2"><a href="#示例：迭代-2" class="headerlink" title="示例：迭代"></a>示例：迭代</h3><pre class="language-none"><code class="language-none">- hosts：websrvs  remote_user: root  tasks    - name: install some packages      yum: name&#x3D;&#123;&#123; item &#125;&#125; state&#x3D;present      with_items:        - nginx        - memcached        - php-fpm</code></pre><h3 id="示例：迭代嵌套子变量"><a href="#示例：迭代嵌套子变量" class="headerlink" title="示例：迭代嵌套子变量"></a>示例：迭代嵌套子变量</h3><pre class="language-none"><code class="language-none">- hosts：websrvs  remote_user: root    tasks:    - name: add some groups      group: name&#x3D;&#123;&#123; item &#125;&#125; state&#x3D;present      with_items:        - group1        - group2        - group3    - name: add some users      user: name&#x3D;&#123;&#123; item.name &#125;&#125; group&#x3D;&#123;&#123; item.group &#125;&#125; state&#x3D;present      with_items:        - &#123; name: &#39;user1&#39;, group: &#39;group1&#39; &#125;        - &#123; name: &#39;user2&#39;, group: &#39;group2&#39; &#125;        - &#123; name: &#39;user3&#39;, group: &#39;group3&#39; &#125;</code></pre><h3 id="with-itmes-嵌套子变量"><a href="#with-itmes-嵌套子变量" class="headerlink" title="with_itmes 嵌套子变量"></a>with_itmes 嵌套子变量</h3><pre class="language-none"><code class="language-none">with_itmes 嵌套子变量示例---- hosts: testweb  remote_user: root  tasks:    - name: add several users      user: name&#x3D;&#123;&#123; item.name &#125;&#125; state&#x3D;present groups&#x3D;&#123;&#123; item.groups &#125;&#125;      with_items:    - &#123; name: &#39;testuser1&#39; , groups: &#39;wheel&#39;&#125;    - &#123; name: &#39;testuser2&#39; , groups: &#39;root&#39;&#125;</code></pre><h3 id="Playbook字典-with-items"><a href="#Playbook字典-with-items" class="headerlink" title="Playbook字典 with_items"></a>Playbook字典 with_items</h3><pre class="language-none"><code class="language-none">- name: 使用ufw模块来管理哪些端口需要开启  ufw:  rule: “&#123;&#123; item.rule &#125;&#125;”  port: “&#123;&#123; item.port &#125;&#125;”  proto: “&#123;&#123; item.proto &#125;&#125;”  with_items:    - &#123; rule: &#39;allow&#39;, port: 22, proto: &#39;tcp&#39; &#125;    - &#123; rule: &#39;allow&#39;, port: 80, proto: &#39;tcp&#39; &#125;    - &#123; rule: &#39;allow&#39;, port: 123, proto: &#39;udp&#39; &#125;- name: 配置网络进出方向的默认规则  ufw:  direction: &quot;&#123;&#123; item.direction &#125;&#125;&quot;  policy: &quot;&#123;&#123; item.policy &#125;&#125;&quot;  state: enabled  with_items:    - &#123; direction: outgoing, policy: allow &#125;    - &#123; direction: incoming, policy: deny &#125;</code></pre><h3 id="Playbook中template-for-if-when循环"><a href="#Playbook中template-for-if-when循环" class="headerlink" title="Playbook中template for if  when循环"></a>Playbook中template for if  when循环</h3><pre class="language-none"><code class="language-none">&#123;% for vhost in nginx_vhosts %&#125;server &#123;    #重复执行server代码listen &#123;&#123; vhost.listen | default(&#39;80 default_server&#39;) &#125;&#125;;&#123;% if vhost.server_name is defined %&#125;server_name &#123;&#123; vhost.server_name &#125;&#125;;&#123;% endif %&#125;&#123;% if vhost.root is defined %&#125;root &#123;&#123; vhost.root &#125;&#125;;&#123;% endif %&#125;&#123;% endfor %&#125;</code></pre><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">&#x2F;&#x2F; temnginx.yml---- hosts: testweb  remote_user: root  vars:      # 调用变量    nginx_vhosts:      - listen: 8080  #列表 键值对&#x2F;&#x2F;templates&#x2F;nginx.conf.j2&#123;% for vhost in nginx_vhosts %&#125;  server &#123;  listen &#123;&#123; vhost.listen &#125;&#125;&#125;&#123;% endfor %&#125;生成的结果server &#123;  listen 8080&#125;</code></pre><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">&#x2F;&#x2F; temnginx.yml---- hosts: mageduweb  remote_user: root  vars:    nginx_vhosts:      - web1      - web2      - web3  tasks:    - name: template config      template: src&#x3D;nginx.conf.j2 dest&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&#x2F;&#x2F; templates&#x2F;nginx.conf.j2&#123;% for vhost in nginx_vhosts %&#125;server &#123;    listen &#123;&#123; vhost &#125;&#125;&#125;&#123;% endfor %&#125;生成的结果：server &#123;    listen web1&#125;server &#123;    listen web2&#125;server &#123;    listen web3&#125;</code></pre><h3 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h3><pre class="language-none"><code class="language-none">roles    ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。    roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。    要使用roles只需要在playbook中使用include指令即可。    简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，    并可以便捷地include它们的一种机制。    角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中复杂场景：建议使用roles，代码复用度高    变更指定主机或主机组    如命名不规范维护和传承成本大    某些功能需多个Playbook，通过includes即可实现</code></pre><h3 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h3><pre class="language-none"><code class="language-none">角色(roles)：角色集合roles&#x2F;    mysql&#x2F;    httpd&#x2F;    nginx&#x2F;    memcached&#x2F;    可以互相调用</code></pre><h3 id="Ansible-Roles目录编排"><a href="#Ansible-Roles目录编排" class="headerlink" title="Ansible Roles目录编排"></a>Ansible Roles目录编排</h3><p><img src="/../images/roles.png" alt="image"> </p><h3 id="roles目录结构"><a href="#roles目录结构" class="headerlink" title="roles目录结构"></a>roles目录结构</h3><pre class="language-none"><code class="language-none">每个角色，以特定的层级目录结构进行组织roles目录结构：playbook.yml  调用角色roles&#x2F;  project&#x2F; (角色名称)    tasks&#x2F;    files&#x2F;    vars&#x2F;    templates&#x2F;    handlers&#x2F;    default&#x2F; 不常用    meta&#x2F;    不常用</code></pre><h3 id="Roles各目录作用"><a href="#Roles各目录作用" class="headerlink" title="Roles各目录作用"></a>Roles各目录作用</h3><pre class="language-none"><code class="language-none">&#x2F;roles&#x2F;project&#x2F; :项目名称,有以下子目录    files&#x2F; ：存放由copy或script模块等调用的文件    templates&#x2F;：template模块查找所需要模板文件的目录    tasks&#x2F;：定义task,role的基本元素，至少应该包含一个名为main.yml的文件；            其它的文件需要在此文件中通过include进行包含    handlers&#x2F;：至少应该包含一个名为main.yml的文件；               其它的文件需要在此文件中通过include进行包含    vars&#x2F;：定义变量，至少应该包含一个名为main.yml的文件；           其它的文件需要在此文件中通过include进行包含    meta&#x2F;：定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，           其它文件需在此文件中通过include进行包含    default&#x2F;：设定默认变量时使用此目录中的main.yml文件    roles&#x2F;appname 目录结构    tasks目录：至少应该包含一个名为main.yml的文件，其定义了此角色的任务列表；               此文件可以使用include包含其它的位于此目录中的task文件    files目录：存放由copy或script等模块调用的文件；    templates目录：template模块会自动在此目录中寻找Jinja2模板文件    handlers目录：此目录中应当包含一个main.yml文件，用于定义此角色用到的各handler；                  在handler中使用include包含的其它的handler文件也应该位于此目录中；    vars目录：应当包含一个main.yml文件，用于定义此角色用到的变量；    meta目录：应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；              ansible1.3及其以后的版本才支持；    default目录：为当前角色设定默认变量时使用此目录；应当包含一个main.yml文件roles&#x2F;example_role&#x2F;files&#x2F;             所有文件，都将可存放在这里roles&#x2F;example_role&#x2F;templates&#x2F;         所有模板都存放在这里roles&#x2F;example_role&#x2F;tasks&#x2F;main.yml：   主函数，包括在其中的所有任务将被执行roles&#x2F;example_role&#x2F;handlers&#x2F;main.yml：所有包括其中的 handlers 将被执行roles&#x2F;example_role&#x2F;vars&#x2F;main.yml：    所有包括在其中的变量将在roles中生效roles&#x2F;example_role&#x2F;meta&#x2F;main.yml：    roles所有依赖将被正常登入</code></pre><h3 id="创建role"><a href="#创建role" class="headerlink" title="创建role"></a>创建role</h3><pre class="language-none"><code class="language-none">创建role的步骤(1) 创建以roles命名的目录(2) 在roles目录中分别创建以各角色名称命名的目录，如webservers等(3) 在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录；    用不到的目录可以创建为空目录，也可以不创建(4) 在playbook文件中，调用各角色</code></pre><h3 id="实验-创建httpd角色"><a href="#实验-创建httpd角色" class="headerlink" title="实验: 创建httpd角色"></a>实验: 创建httpd角色</h3><pre class="language-none"><code class="language-none">1&gt; 创建roles目录   mkdir roles&#x2F;&#123;httpd,mysql,redis&#125;&#x2F;tasks -pv   mkdir  roles&#x2F;httpd&#x2F;&#123;handlers,files&#125;查看目录结构tree roles&#x2F;    roles&#x2F;    ├── httpd    │   ├── files    │   ├── handlers    │   └── tasks    ├── mysql    │   └── tasks    └── redis        └── tasks2&gt; 创建目标文件   cd roles&#x2F;httpd&#x2F;tasks&#x2F;   touch install.yml config.yml service.yml3&gt; vim install.yml   - name: install httpd package     yum: name&#x3D;httpd        vim config.yml   - name: config file       copy: src&#x3D;httpd.conf dest&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F; backup&#x3D;yes       vim service.yml   - name: start service      service: name&#x3D;httpd state&#x3D;started enabled&#x3D;yes     4&gt; 创建main.yml主控文件,调用以上单独的yml文件,   main.yml定义了谁先执行谁后执行的顺序   vim main.yml   - include: install.yml   - include: config.yml   - include: service.yml   5&gt; 准备httpd.conf文件,放到httpd单独的文件目录下   cp &#x2F;app&#x2F;ansible&#x2F;flies&#x2F;httpd.conf ..&#x2F;files&#x2F;   6&gt; 创建一个网页   vim flies&#x2F;index.html   &lt;h1&gt; welcome to weixiaodong home &lt;\h1&gt;7&gt; 创建网页的yml文件   vim tasks&#x2F;index.yml   - name: index.html     copy: src&#x3D;index.html dest&#x3D;&#x2F;var&#x2F;www&#x2F;html 8&gt; 将网页的yml文件写进mian.yml文件中   vim mian.yml   - include: install.yml   - include: config.yml   - include: index.yml   - include: service.yml9&gt; 在handlers目录下创建handler文件mian.yml   vim handlers&#x2F;main.yml   - name: restart service httpd     service: name&#x3D;httpd state&#x3D;restarted10&gt; 创建文件调用httpd角色    cd &#x2F;app&#x2F;ansidle&#x2F;roles    vim role_httpd.yml    ---    # httpd role    - hosts: appsrvs      remote_user: root       roles:       #调用角色        - role: httpd          11&gt; 查看目录结构    tree     .    httpd    ├── files    │   ├── httpd.conf    │   └── index.html    ├── handlers    │   └── main.yml    └── tasks        ├── config.yml        ├── index.yml        ├── install.yml        ├── main.yml        └── service.yml12&gt; ansible-playbook role_httpd.yml</code></pre><h3 id="针对大型项目使用Roles进行编排"><a href="#针对大型项目使用Roles进行编排" class="headerlink" title="针对大型项目使用Roles进行编排"></a>针对大型项目使用Roles进行编排</h3><pre class="language-none"><code class="language-none">roles目录结构：playbook.ymlroles&#x2F;  project&#x2F;    tasks&#x2F;    files&#x2F;    vars&#x2F;    templates&#x2F;    handlers&#x2F;    default&#x2F; # 不经常用    meta&#x2F;    # 不经常用示例：nginx-role.ymlroles&#x2F;└── nginx    ├── files    │ └── main.yml    ├── tasks    │ ├── groupadd.yml    │ ├── install.yml    │ ├── main.yml    │ ├── restart.yml    │ └── useradd.yml    └── vars        └── main.yml</code></pre><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">roles的示例如下所示：site.ymlwebservers.ymldbservers.ymlroles&#x2F;  common&#x2F;    files&#x2F;    templates&#x2F;    tasks&#x2F;    handlers&#x2F;    vars&#x2F;    meta&#x2F;  webservers&#x2F;    files&#x2F;    templates&#x2F;    tasks&#x2F;  handlers&#x2F;    vars&#x2F;    meta&#x2F;</code></pre><h3 id="实验：-创建一个nginx角色"><a href="#实验：-创建一个nginx角色" class="headerlink" title="实验： 创建一个nginx角色"></a>实验： 创建一个nginx角色</h3><pre class="language-none"><code class="language-none">建立nginx角色在多台主机上来部署nginx需要安装 创建账号1&gt; 创建nginx角色目录     cd &#x2F;app&#x2F;ansible&#x2F;role     mkdir nginx&#123;tesks,templates,hanslers&#125; -pv2&gt; 创建任务目录     cd tasks&#x2F;     touch insatll.yml config.yml service.yml file.yml user.yml   创建main.yml文件定义任务执行顺序     vim main.yml     - include: user.yml     - include: insatll.yml     - include: config.yml     - include: file.yml     - include: service.yml  3&gt; 准备配置文件(centos7、8)   ll &#x2F;app&#x2F;ansible&#x2F;role&#x2F;nginx&#x2F;templates&#x2F;   nginx7.conf.j2   nginx8.conf.j24&gt; 定义任务   vim tasks&#x2F;install.yml   - name: install     yum: name&#x3D;nginx        vim tasks&#x2F;config.yml    - name: config file      template: src&#x3D;nginx7.conf.j2 dest&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf      when: ansible_distribution_major_version&#x3D;&#x3D;&quot;7&quot;      notify: restrat          - name: config file      template: src&#x3D;nginx8.conf.j2 dest&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf      when: ansible_distribution_major_version&#x3D;&#x3D;&quot;8&quot;      notify: restrat          vim tasks&#x2F;file.yml   跨角色调用file.yum文件,实现文件复用    - name: index.html      copy: src&#x3D;roles&#x2F;httpd&#x2F;files&#x2F;index.html dest&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;        vim tasks&#x2F;service.yml    - nmae: start service      service: name&#x3D;nginx state&#x3D;started enabled&#x3D;yes          vim handlers&#x2F;main.yml    - name: restrat      service: name&#x3D;nginx state&#x3D;restarted          vim roles&#x2F;role_nginix.yml    ---     #test rcle    - hosts: appsrvs          roles:         - role: nginx        5&gt; 测试安装   ansible-playbook role_nginx.yml</code></pre><h3 id="Roles案例"><a href="#Roles案例" class="headerlink" title="Roles案例"></a>Roles案例</h3><p>Roles目录编排<br><img src="/../images/roles1.png" alt="image"></p><p>Playbook中调用<br><img src="/../images/roles2.png" alt="image"></p><h3 id="playbook调用角色"><a href="#playbook调用角色" class="headerlink" title="playbook调用角色"></a>playbook调用角色</h3><pre class="language-none"><code class="language-none">调用角色方法1：- hosts: websrvs  remote_user: root    roles:    - mysql    - memcached    - nginx    调用角色方法2：传递变量给角色- hosts:  remote_user:  roles:    - mysql    - &#123; role: nginx, username: nginx &#125;   #不同的角色调用不同的变量      键role用于指定角色名称    后续的k&#x2F;v用于传递变量给角色调用角色方法3：还可基于条件测试实现角色调用roles:  - &#123; role: nginx, username: nginx, when: ansible_distribution_major_version &#x3D;&#x3D; &#39;7&#39; &#125;</code></pre><h3 id="通过roles传递变量"><a href="#通过roles传递变量" class="headerlink" title="通过roles传递变量"></a>通过roles传递变量</h3><pre class="language-none"><code class="language-none">通过roles传递变量当给一个主机应用角色的时候可以传递变量，然后在角色内使用这些变量示例：- hosts: webservers  roles:    - common    - &#123; role: foo_app_instance, dir: &#39;&#x2F;web&#x2F;htdocs&#x2F;a.com&#39;, port: 8080 &#125;</code></pre><h3 id="向roles传递参数"><a href="#向roles传递参数" class="headerlink" title="向roles传递参数"></a>向roles传递参数</h3><pre class="language-none"><code class="language-none">而在playbook中，可以这样使用roles：---- hosts: webservers  roles:    - common    - webservers也可以向roles传递参数示例：---- hosts: webservers  roles:    - common    - &#123; role: foo_app_instance, dir: &#39;&#x2F;opt&#x2F;a&#39;, port: 5000 &#125;    - &#123; role: foo_app_instance, dir: &#39;&#x2F;opt&#x2F;b&#39;, port: 5001 &#125;</code></pre><h3 id="条件式地使用roles"><a href="#条件式地使用roles" class="headerlink" title="条件式地使用roles"></a>条件式地使用roles</h3><pre class="language-none"><code class="language-none">甚至也可以条件式地使用roles示例：---- hosts: webservers  roles:    - &#123; role: some_role, when: &quot;ansible_os_family &#x3D;&#x3D; &#39;RedHat&#39;&quot; &#125;</code></pre><h3 id="Roles条件及变量等案例"><a href="#Roles条件及变量等案例" class="headerlink" title="Roles条件及变量等案例"></a>Roles条件及变量等案例</h3><pre class="language-none"><code class="language-none">When条件    roles:      - &#123;role: nginx, when: &quot;ansible_distribution_major_version &#x3D;&#x3D; &#39;7&#39; &quot; ,username: nginx &#125;变量调用- hosts: zabbix-proxy  sudo: yes  roles:    - &#123; role: geerlingguy.php-mysql &#125;    - &#123; role: dj-wasabi.zabbix-proxy, zabbix_server_host: 192.168.37.167 &#125;</code></pre><h3 id="完整的roles架构"><a href="#完整的roles架构" class="headerlink" title="完整的roles架构"></a>完整的roles架构</h3><pre class="language-none"><code class="language-none">&#x2F;&#x2F; nginx-role.yml 顶层任务调用yml文件---- hosts: testweb  remote_user: root  roles:    - role: nginx    - role: httpd 可执行多个rolecat roles&#x2F;nginx&#x2F;tasks&#x2F;main.yml---- include: groupadd.yml- include: useradd.yml- include: install.yml- include: restart.yml- include: filecp.yml&#x2F;&#x2F; roles&#x2F;nginx&#x2F;tasks&#x2F;groupadd.yml---- name: add group nginx  user: name&#x3D;nginx state&#x3D;presentcat roles&#x2F;nginx&#x2F;tasks&#x2F;filecp.yml---- name: file copy  copy: src&#x3D;tom.conf dest&#x3D;&#x2F;tmp&#x2F;tom.conf以下文件格式类似：useradd.yml,install.yml,restart.ymlls roles&#x2F;nginx&#x2F;files&#x2F;tom.conf</code></pre><h3 id="roles-playbook-tags使用"><a href="#roles-playbook-tags使用" class="headerlink" title="roles playbook tags使用"></a>roles playbook tags使用</h3><pre class="language-none"><code class="language-none">roles playbook tags使用    ansible-playbook --tags&#x3D;&quot;nginx,httpd,mysql&quot; nginx-role.yml  对标签进行挑选执行&#x2F;&#x2F; nginx-role.yml---- hosts: testweb  remote_user: root  roles:    - &#123; role: nginx ,tags: [ &#39;nginx&#39;, &#39;web&#39; ] ,when: ansible_distribution_major_version &#x3D;&#x3D; &quot;6“ &#125;    - &#123; role: httpd ,tags: [ &#39;httpd&#39;, &#39;web&#39; ] &#125;    - &#123; role: mysql ,tags: [ &#39;mysql&#39;, &#39;db&#39; ] &#125;    - &#123; role: marridb ,tags: [ &#39;mysql&#39;, &#39;db&#39; ] &#125;    - &#123; role: php &#125;</code></pre><h3 id="实验-创建角色memcached"><a href="#实验-创建角色memcached" class="headerlink" title="实验: 创建角色memcached"></a>实验: 创建角色memcached</h3><pre class="language-none"><code class="language-none">memcacched 当做缓存用,会在内存中开启一块空间充当缓存cat &#x2F;etc&#x2F;sysconfig&#x2F;memcached     PORT&#x3D;&quot;11211&quot;    USER&#x3D;&quot;memcached&quot;    MAXCONN&#x3D;&quot;1024&quot;    CACHESIZE&#x3D;&quot;64&quot;    # 缓存空间默认64M     OPTIONS&#x3D;&quot;&quot;1&gt; 创建对用目录   cd &#x2F;app&#x2F;ansible   mkdir roles&#x2F;memcached&#x2F;&#123;tasks,templates&#125; -pv   2&gt; 拷贝memcached配置文件模板   cp &#x2F;etc&#x2F;sysconfig&#x2F;memcached  templates&#x2F;memcached.j2   vim templates&#x2F;memcached.j2   CACHESIZE&#x3D;&quot;&#123;&#123;ansible_memtotal_mb&#x2F;&#x2F;4&#125;&#125;&quot;   #物理内存的1&#x2F;4用做缓存   3&gt; 创建对应yml文件,并做相应配置   cd tasks&#x2F;   touch install.yml config.yml service.yml   创建main.yml文件定义任务执行顺序   vim main.yml   - include: install.yml   - include: config.yml   - include: service.yml        vim install.yml   - name: install      yum: name&#x3D;memcached        vim config.yml   - name: config file     template: src&#x3D;memcached.j2 dets&#x3D;&#x2F;etc&#x2F;sysconfig&#x2F;memcached   vim service.yml   - name: service     service: name&#x3D;memcached state&#x3D;started enabled&#x3D;yes4&gt; 创建调用角色文件   cd &#x2F;app&#x2F;ansible&#x2F;roles&#x2F;   vim role_memcached.yml    ---    - hosts: appsrvs          roles:         - role: memcached5&gt; 安装   ansible-playbook  role_memcached.yml    memcached端口号11211</code></pre><h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><pre class="language-none"><code class="language-none">委任（指定某一台机器做某一个task）    delegate_to    local_action (专指针对ansible命令执行的机器做的变更操作)交互提示    prompt*暂停（java）    wait_forDebug    debug: msg&#x3D;&quot;This always executes.&quot;IncludeTemplate 多值合并Template 动态变量配置</code></pre><h3 id="Ansible-Roles"><a href="#Ansible-Roles" class="headerlink" title="Ansible Roles"></a>Ansible Roles</h3><pre class="language-none"><code class="language-none">委任    delegate_to交互提示    prompt暂停    wait_forDebug    debug: msg&#x3D;&quot;This always executes.&quot;IncludeTemplate 多值合并Template 动态变量配置</code></pre><h3 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h3><pre class="language-none"><code class="language-none">http:&#x2F;&#x2F;galaxy.ansible.comhttps:&#x2F;&#x2F;galaxy.ansible.com&#x2F;explore#&#x2F;http:&#x2F;&#x2F;github.com&#x2F;http:&#x2F;&#x2F;ansible.com.cn&#x2F;https:&#x2F;&#x2F;github.com&#x2F;ansible&#x2F;ansiblehttps:&#x2F;&#x2F;github.com&#x2F;ansible&#x2F;ansible-examples</code></pre><h3 id="实验-实现二进制安装mysql的卸载"><a href="#实验-实现二进制安装mysql的卸载" class="headerlink" title="实验: 实现二进制安装mysql的卸载"></a>实验: 实现二进制安装mysql的卸载</h3><pre class="language-none"><code class="language-none">cat remove_mysql.yml ---# install mariadb server - hosts: appsrvs:!192.168.38.108  remote_user: root  tasks:    - name: stop service       shell: &#x2F;etc&#x2F;init.d&#x2F;mysqld stop    - name: delete user       user: name&#x3D;mysql state&#x3D;absent remove&#x3D;yes    - name: delete      file: path&#x3D;&#123;&#123;item&#125;&#125; state&#x3D;absent      with_items:         - &#x2F;usr&#x2F;local&#x2F;mysql        - &#x2F;usr&#x2F;local&#x2F;mariadb-10.2.27-linux-x86_64        - &#x2F;etc&#x2F;init.d&#x2F;mysqld        - &#x2F;etc&#x2F;profile.d&#x2F;mysql.sh        - &#x2F;etc&#x2F;my.cnf        - &#x2F;data&#x2F;mysqlansible-playbook  remove_mysql.yml</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mdadm命令详解</title>
      <link href="/c901ebd9.html"/>
      <url>/c901ebd9.html</url>
      
        <content type="html"><![CDATA[<p>Linux内核中有一个md(multiple devices)模块在底层管理RAID设备，它会在应用层给我们提供一个应用程序的工具mdadm ，mdadm是linux下用于创建和管理软件RAID的命令。</p><h2 id="mdadm命令常见参数解释："><a href="#mdadm命令常见参数解释：" class="headerlink" title="mdadm命令常见参数解释："></a>mdadm命令常见参数解释：</h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>检测设备名称，添加磁盘</td></tr><tr><td>-n</td><td>指定设备数量</td></tr><tr><td>-l</td><td>指定RAID级别</td></tr><tr><td>-C</td><td>创建</td></tr><tr><td>-v</td><td>显示过程</td></tr><tr><td>-f</td><td>模拟设备损坏</td></tr><tr><td>-r</td><td>移除设备</td></tr><tr><td>-Q</td><td>查看摘要信息</td></tr><tr><td>-D</td><td>查看详细信息</td></tr><tr><td>-S</td><td>停止RAID磁盘阵列</td></tr></tbody></table><h2 id="搭建raid10阵列"><a href="#搭建raid10阵列" class="headerlink" title="搭建raid10阵列"></a>搭建raid10阵列</h2><ol><li>新添加4块硬盘——在centos关机的情况下添加4块新的硬盘。</li></ol><pre class="language-none"><code class="language-none"># ls &#x2F;dev&#x2F;sd*</code></pre><ol start="2"><li>下载mdadm</li></ol><pre class="language-none"><code class="language-none"># yum install mdadm -y</code></pre><ol start="3"><li>创建RAID10阵列</li></ol><pre class="language-none"><code class="language-none"># mdadm -C -v &#x2F;dev&#x2F;md10 -l 10 -n 4 &#x2F;dev&#x2F;sd&#123;b,c,d,e&#125;</code></pre><p>这里的选项是多个，对照上表查看。磁盘阵列名需要以md开头，这里创建的是md10。</p><ol start="4"><li>查看阵列信息</li></ol><pre class="language-none"><code class="language-none"># mdadm -D &#x2F;dev&#x2F;md10</code></pre><ol start="5"><li>格式化</li></ol><pre class="language-none"><code class="language-none"># mkfs.xfs &#x2F;dev&#x2F;md10</code></pre><ol start="6"><li>挂载使用</li></ol><pre class="language-none"><code class="language-none"># mount &#x2F;dev&#x2F;md10 &#x2F;ken</code></pre><ol start="7"><li>写入到文件</li></ol><p>方法一、</p><pre class="language-none"><code class="language-none"># echo “mount &#x2F;dev&#x2F;md10 &#x2F;ken” &gt;&gt; &#x2F;etc&#x2F;rc.local</code></pre><p>方法二、</p><pre class="language-none"><code class="language-none"># echo “&#x2F;dev&#x2F;md10 &#x2F;ken xfs defaults 0 0 ” &gt;&gt; &#x2F;etc&#x2F;fstab</code></pre><h2 id="mdadm管理RAID10阵列–模拟磁盘损坏后的处理方式"><a href="#mdadm管理RAID10阵列–模拟磁盘损坏后的处理方式" class="headerlink" title="mdadm管理RAID10阵列–模拟磁盘损坏后的处理方式"></a>mdadm管理RAID10阵列–模拟磁盘损坏后的处理方式</h2><ol><li>模拟损坏磁盘</li></ol><pre class="language-none"><code class="language-none"># mdadm &#x2F;dev&#x2F;md10 -f &#x2F;dev&#x2F;sdd</code></pre><p>选项f是用于模拟磁盘损坏。</p><pre class="language-none"><code class="language-none"># mdadm -D &#x2F;dev&#x2F;md10</code></pre><p>查看详细信息，这时候已经显示磁盘损坏了。</p><ol start="2"><li><p>重启</p></li><li><p>添加磁盘</p></li></ol><pre class="language-none"><code class="language-none"># mdadm &#x2F;dev&#x2F;md10 -a &#x2F;dev&#x2F;sdd</code></pre><p>选项a是用于添加磁盘。</p><pre class="language-none"><code class="language-none"># mdadm -D &#x2F;dev&#x2F;md10</code></pre><p>添加成功，然后照常使用。</p><h2 id="mdadm创建RAID阵列–RAID5-热备盘"><a href="#mdadm创建RAID阵列–RAID5-热备盘" class="headerlink" title="mdadm创建RAID阵列–RAID5+热备盘"></a>mdadm创建RAID阵列–RAID5+热备盘</h2><ol><li>添加四块磁盘并查看。</li></ol><pre class="language-none"><code class="language-none"># ls &#x2F;dev&#x2F;sd*</code></pre><ol start="2"><li>创建磁盘阵列RAID5</li></ol><pre class="language-none"><code class="language-none"># mdadm -C &#x2F;dev&#x2F;md5 -l 5 -n 3 -x 1 &#x2F;dev&#x2F;sd&#123;b,c,d,e&#125;</code></pre><ol start="3"><li>查看阵列信息</li></ol><pre class="language-none"><code class="language-none"># mdadm -D &#x2F;dev&#x2F;md5</code></pre><ol start="4"><li>格式化</li></ol><pre class="language-none"><code class="language-none"># mkfs.xfs &#x2F;dev&#x2F;md5</code></pre><ol start="5"><li>挂载</li></ol><pre class="language-none"><code class="language-none"># mkdir &#x2F;ken# mount &#x2F;dev&#x2F;md5 &#x2F;ken</code></pre><ol start="6"><li>补充</li></ol><p>在使用mdadm命令创建RAID阵列时，需要先将磁盘分区并格式化，然后再将分区设备加入到RAID阵列中。如果RAID阵列中的磁盘出现故障，可以使用mdadm命令进行磁盘的移除和添加，以及磁盘阵列的重建。</p><p>在创建RAID阵列时，需要注意以下几点：</p><ol><li><p>磁盘数量必须是偶数，且至少需要两个磁盘。</p></li><li><p>磁盘容量应该相同，否则会浪费磁盘空间。</p></li><li><p>RAID级别的选择应该根据实际需求进行，不同的RAID级别有不同的优缺点。</p></li><li><p>在创建RAID阵列时，可以使用-x选项指</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git代码更新报错</title>
      <link href="/9bf068a.html"/>
      <url>/9bf068a.html</url>
      
        <content type="html"><![CDATA[<h2 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h2><p>git同步代码出现错误的原因有多种多样，本章给大家介绍一个window系统的git仓库权限问题,由于win10重装系统后，文件夹所有者变了，导致git pull等都出现了该问题。</p><pre class="language-bash" data-language="bash"><code class="language-bash">PS D:\小萌计划\liberty\微信小程序&gt; git pullfatal: detected dubious ownership in repository at &#39;D:&#x2F;小萌计划&#x2F;liberty&#39;&#39;D:&#x2F;小萌计划&#x2F;liberty&#39; is owned by:        &#39;S-1-5-21-1352026588-2545222877-778235115-1001&#39;but the current user is:        &#39;S-1-5-21-2042668658-433506434-3672517647-1001&#39;To add an exception for this directory, call:        git config --global --add safe.directory &#39;D:&#x2F;小萌计划&#x2F;liberty&#39;</code></pre><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>更改文件权限</p><p><img src="/../images/8862c8a8736247d9ac64f68e7b9ff865.jpeg"></p><p><img src="/../images/f26342fd6f6b43b7aa1cdec2c7fd7e46.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT使用</title>
      <link href="/36c4f4bb.html"/>
      <url>/36c4f4bb.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、获取openAI-的key"><a href="#一、获取openAI-的key" class="headerlink" title="一、获取openAI 的key"></a><strong>一、获取openAI 的key</strong></h1><h2 id="1-关注公众号"><a href="#1-关注公众号" class="headerlink" title="1.关注公众号"></a>1.关注公众号</h2><p><img src="/../images/pwxgz.jpg" alt="微信公众号"></p><h2 id="2-输入关键字获取key"><a href="#2-输入关键字获取key" class="headerlink" title="2.输入关键字获取key"></a>2.输入关键字获取key</h2><p>​在消息输入框回复关键词“小张我需要ChatGPT的key”</p><p><img src="/../images/getkey.png" alt="获取密钥"></p><h1 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a><strong>二、使用方法</strong></h1><p>​点击设置里面填充openAI key<br><img src="/../images/setok.png" alt="设置"></p><p><img src="/../images/openkey.jpg" alt="打开密钥.jpg"></p><h1 id="三、测试结果"><a href="#三、测试结果" class="headerlink" title="三、测试结果"></a><strong>三、测试结果</strong></h1><p>再测点击设置，在对话框里面输入“你好”，有正常返回结果就可以了。</p><p><img src="/../images/hi.jpg" alt="嗨.jpg"></p><h1 id="四、网站使用方法"><a href="#四、网站使用方法" class="headerlink" title="四、网站使用方法"></a><strong>四、网站使用方法</strong></h1><h2 id="1-设置选项介绍"><a href="#1-设置选项介绍" class="headerlink" title="1.设置选项介绍"></a>1.设置选项介绍</h2><ul><li>OpenAI API Key:  填写openAI的秘钥</li><li>系统角色指令：发送系统指令的类型，可以不用填写</li><li>思维发散程度： 根据自己需求自行调整</li><li>记录对话内容，刷新不会消失： 保留会话记录</li><li>开启连续对话，将加倍消耗Token: 作用是做到上下文内容联系</li></ul><p><img src="/../images/seting.jpg" alt="设置.jpg"></p><h2 id="2-使用存在的问题介绍"><a href="#2-使用存在的问题介绍" class="headerlink" title="2.使用存在的问题介绍"></a>2.使用存在的问题介绍</h2><ul><li>常见网站错误如下，解决办法刷新网页</li></ul><p>​TypeError: Failed to fetch<br>​error</p><ul><li>对话数据不要太长，网页上下文联系错误长出现error错误，需要刷新网页</li></ul>]]></content>
      
      
      <categories>
          
          <category> AI话题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PXE安装系统iventoy</title>
      <link href="/e3dd6c7c.html"/>
      <url>/e3dd6c7c.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>作用</li></ul><p>​       简单来说，iVentoy 可以看成是一个增强版的 PXE 服务器。 使用iVentoy 你可以通过网络同时给多台机器启动、安装操作系统。<br>iVentoy 使用极其简单，无需复杂的配置，直接把 ISO 文件放到指定位置，客户机在启动时根据菜单选择要启动的ISO文件即可。<br>iVentoy 同时支持 x86 Legacy BIOS、IA32 UEFI、x86_64 UEFI 和 ARM64 UEFI 模式。</p><ul><li><p>官网</p><p><a href="https://www.iventoy.com/cn/index.html">https://www.iventoy.com/cn/index.html</a></p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>参考手册</li></ul><p>​       <a href="https://www.iventoy.com/cn/doc_news.html">https://www.iventoy.com/cn/doc_news.html</a></p><ul><li><p>下载地址</p><p><a href="https://www.iventoy.com/cn/download.html">https://www.iventoy.com/cn/download.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> window </tag>
            
            <tag> PXE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业级搭建Gitlab</title>
      <link href="/dded7b2a.html"/>
      <url>/dded7b2a.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、配置主机的基本环境"><a href="#一、配置主机的基本环境" class="headerlink" title="一、配置主机的基本环境"></a>一、配置主机的基本环境</h2><ul><li>所有新Linux主机都需要完成下面的操作</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">[root@localhost ~]# hostnamectl  set-hostname 主机名称         #修改主机名[root@localhost ~]# bash[root@gitlab-server ~]# systemctl  status firewalld           #检查防火墙● firewalld.service - firewalld - dynamic firewall daemon   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service; enabled; vendor preset: enabled)   Active: active (running) since Fri 2023-07-21 18:43:18 CST; 2min 16s ago     Docs: man:firewalld(1) Main PID: 698 (firewalld)   CGroup: &#x2F;system.slice&#x2F;firewalld.service           └─698 &#x2F;usr&#x2F;bin&#x2F;python -Es &#x2F;usr&#x2F;sbin&#x2F;firewalld --nofork --nopidJul 21 18:43:18 localhost.localdomain systemd[1]: Starting firewalld - dynamic firewall daemon...Jul 21 18:43:18 localhost.localdomain systemd[1]: Started firewalld - dynamic firewall daemon.[root@gitlab-server ~]# systemctl  stop firewalld             #防火墙为running，需要关闭防火墙[root@gitlab-server ~]# systemctl  disable firewalld          #关闭关机自启防火墙设置Removed symlink &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;firewalld.service.Removed symlink &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;dbus-org.fedoraproject.FirewallD1.service.[root@gitlab-server ~]# getenforce                            #检查Selinux开启状态Enforcing                                                     #状态是开启状态[root@gitlab-server ~]# yum install wget vim                  #安装Linux系统工具[root@gitlab-server ~]# vim &#x2F;etc&#x2F;selinux&#x2F;config               #需要关闭SelinuxSELINUX&#x3D;disabled                                              #修改配置文件[root@gitlab-server ~]# reboot                                #重新启动服务器让所有配置生效</code></pre><h2 id="二、gitlab-server主机安装"><a href="#二、gitlab-server主机安装" class="headerlink" title="二、gitlab-server主机安装"></a>二、gitlab-server主机安装</h2><ul><li>配置gitlab网络镜像源</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">[root@gitlab-server ~]# vim &#x2F;etc&#x2F;yum.repos.d&#x2F;gitlab.repo      #编写网络镜像源[gitlab-ce]name&#x3D;gitlabbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;el7&#x2F;enabled&#x3D;1gpgcheck&#x3D;0[root@gitlab-server ~]# yum clean all                         #删除安装软件缓存[root@gitlab-server ~]# yum repolist                          #刷新网络安装源</code></pre><ul><li>部署gitlab服务器</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">[root@gitlab-server ~]# yum install -y gitlab-ce              #安装gitlab-ce[root@gitlab-server ~]# vim +32 &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb         #修改配置文件external_url &#39;http:&#x2F;&#x2F;192.168.127.100&#39;                         #修改成自己的客户机的IP地址[root@gitlab-server ~]# gitlab-ctl  reconfigure               #初始化gitlab环境,需要的时间比较长，请耐心等待[root@gitlab-server ~]# gitlab-ctl  status                    #查看gitlab服务组件状态，都是run说明服务组件运行正常run: alertmanager: (pid 9666) 9s; run: log: (pid 9346) 41srun: gitaly: (pid 9546) 19s; run: log: (pid 8285) 138srun: gitlab-exporter: (pid 9631) 10s; run: log: (pid 9167) 57srun: gitlab-kas: (pid 9603) 12s; run: log: (pid 8517) 127srun: gitlab-workhorse: (pid 9612) 11s; run: log: (pid 8948) 76srun: logrotate: (pid 8117) 153s; run: log: (pid 8131) 152srun: nginx: (pid 8987) 73s; run: log: (pid 9028) 70srun: node-exporter: (pid 9626) 11s; run: log: (pid 9077) 63srun: postgres-exporter: (pid 9674) 8s; run: log: (pid 9404) 35srun: postgresql: (pid 8340) 134s; run: log: (pid 8422) 131srun: prometheus: (pid 9645) 10s; run: log: (pid 9292) 47srun: puma: (pid 8783) 91s; run: log: (pid 8816) 88srun: redis: (pid 8182) 147s; run: log: (pid 8197) 146srun: redis-exporter: (pid 9633) 10s; run: log: (pid 9223) 51srun: sidekiq: (pid 8841) 85s; run: log: (pid 8880) 81s</code></pre><ul><li>检查gitlab服务是否正常使用，访问<a href="http://192.168.127.100/">http://192.168.127.100/</a></li></ul><p><img src="/../images/gitlab%E5%AE%89%E8%A3%85%E4%BC%81%E4%B8%9A.png"></p><p>登录gitlab服务，默认生成用户名和密码,默认的用户名是root</p><pre class="language-bash" data-language="bash"><code class="language-bash">[root@gitlab-server ~]# cat &#x2F;etc&#x2F;gitlab&#x2F;initial_root_password# WARNING: This value is valid only in the following conditions#          1. If provided manually (either via &#96;GITLAB_ROOT_PASSWORD&#96; environment variable or via &#96;gitlab_rails[&#39;initial_root_password&#39;]&#96; setting in &#96;gitlab.rb&#96;, it was provided before database was seeded for the first time (usually, the first reconfigure run).#          2. Password hasn&#39;t been changed manually, either via UI or via command line.##          If the password shown here doesn&#39;t work, you must reset the admin password following https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;security&#x2F;reset_user_password.html#reset-your-root-password.Password: jN9OAFsPgqOaPEbBDR2qW7CrF2JKOmT4lxca8JHQloo&#x3D;# NOTE: This file will be automatically deleted in the first reconfigure run after 24 hours.</code></pre><p><img src="/../images/gitlablogin%E7%99%BB%E5%BD%95.png"></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老陕小张的技能介绍</title>
      <link href="/7d4ff147.html"/>
      <url>/7d4ff147.html</url>
      
        <content type="html"><![CDATA[<h1 id="老陕小张"><a href="#老陕小张" class="headerlink" title="老陕小张"></a>老陕小张</h1><p>我们是一家专注于部署服务器软件、网络环境、企业官网编写以及Linux和Windows系统优化的组织。我们的团队由一群技术精湛、经验丰富的IT专家组成，致力于为客户提供高质量的技术服务。</p><h2 id="服务范围"><a href="#服务范围" class="headerlink" title="服务范围"></a>服务范围</h2><p>我们的服务范围涵盖了各种企业级软件的部署和优化，包括但不限于Web服务器、数据库服务器、邮件服务器、虚拟化平台等。我们还提供网络环境的规划和部署，确保客户的网络安全和稳定性。此外，我们还拥有一支专业的网站开发团队，能够为客户提供高质量的企业官网设计和开发服务。</p><h2 id="技术团队"><a href="#技术团队" class="headerlink" title="技术团队"></a>技术团队</h2><p>我们的技术团队拥有丰富的Linux和Windows系统优化经验，能够为客户提供系统性能优化、安全加固、容灾备份等服务，确保客户的系统运行稳定、高效、安全。我们的目标是为客户提供最优质的技术服务，帮助客户提高业务效率，降低IT成本，让客户在激烈的市场竞争中获得更大的优势。我们相信，通过我们的专业技术和贴心服务，我们能够成为客户信赖的长期合作伙伴。</p><h2 id="网络优化和部署"><a href="#网络优化和部署" class="headerlink" title="网络优化和部署"></a>网络优化和部署</h2><p>我们的网络优化主要是针对家庭网络和中小型企业。我们的专业团队能够为客户提供网络性能优化、网络安全加固、网络拓扑规划等服务，确保客户的网络稳定、高效、安全。我们还能够为客户提供网络部署服务，包括网络设备的选型、配置、安装和调试，确保客户的网络环境能够满足业务需求。我们的目标是为客户提供全方位的网络服务，让客户的网络环境更加稳定、高效、安全。</p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h2><p>总之，我们的团队致力于为客户提供最优质的技术服务，让客户在激烈的市场竞争中获得更大的优势。如果您需要我们的服务，请随时联系我们，我们将竭诚为您服务。<br><img src="/../images/pwx.png" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> 关于我们 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关于我们 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="//404.html"/>
      <url>//404.html</url>
      
        <content type="html"><![CDATA[<h1 id="抱歉，页面未找到"><a href="#抱歉，页面未找到" class="headerlink" title="抱歉，页面未找到"></a>抱歉，页面未找到</h1><p>很抱歉，您所访问的页面不存在或已被删除。</p><p>请检查您输入的网址是否正确，或者返回<a href="/">主页</a>继续浏览其他内容。</p><p>如果您认为这是一个错误，请联系我们的网站管理员进行处理。</p><p>谢谢您的访问！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
